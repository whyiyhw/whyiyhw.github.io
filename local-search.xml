<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024-周记汇总</title>
    <link href="/posts/44a0f9d7/"/>
    <url>/posts/44a0f9d7/</url>
    
    <content type="html"><![CDATA[<p>本周开始了练字的训练，每天练习30-60分钟，3天的练习下来，我发现最重要的是如何捏住笔，以及腕部与手指的配合<br>具体的捏法可以参考这位老师的视频：<a href="https://www.bilibili.com/video/BV1qD4y1K7Q9/">如何正确的捏笔</a> ，<br>在其中最重要的点是，如何把笔拿稳以及下意识的使用 手腕以及手指的配合，这样才能保证字迹的稳定性。</p><p>第一天会有强烈的不适应感觉，因为实在纠正写了20多年的习惯，但是第二天，耐心去写一段话，你会发现，你的稳定性以及字迹的工整度有了明显的改善，也许还谈不上，可以拿出去给别人看<br>但是对比之前是有了很明显的对比。所以呢我打算继续练习3个月，看看效果如何。</p><p>第二个体会就是 从控笔，到偏旁，到实践再到临摹，以及给了很完整的步骤去提升，这个知识点还基本是免费的。<br>不得不说，知识的普及，会让更多的人受益。 老师的作用在于，提醒与指导，加速进步曲线，而不是知识的传授，这一点很重要。<br>基本上绝大部分的普遍性的工作都是如此了，再搭配上 ai 给出一个基础的训练计划，自觉以及可以坚持的稳定环境就能提升技能。</p><hr><p>本周的另外一个点就是 读完了 《人性的弱点》 这本书，这本书按照我的认知是不会认同的，不是圭臬，因为我的思想是知行合一，但是这本书读完<br>我实践不了，或者实践起来，对我本体的压力会很大，所以我才会说，也许你是对的，但是至少现在我还不能接受，也许会慢慢来。</p><p>第二个就是 对于<a href="https://www.bilibili.com/video/BV14M4m1z7hc/">现代性的探讨</a> 我们能否精算出完美的人生，就我的个人体会来说，<br>很难 ， individual will 对于个人的要求太高了，说实话我没想过会这么难，我以为 一个人，经济上独立，然后精神上独立 就可以了，但是<br>爱情跟婚姻，家庭，朋友，社会，这些都是会给你要求，你的 individual will 能否在这些压力下不变性，依旧坚持自我，这个才是最难的。<br>你要是能做到，也就意味着，你在社会上是属于强者， individual will 是属于强者的，这个是我现在的体会。</p><p>绝大数个人想要 individual will ，是不现实的，所以我不再要求别人去践行这个理念，这个反而跟人性弱点这本书关联起来了，要入世，要理解不同阶层人的想法，<br>要解构自我，去理解其他人，重构自己的认知框架，我可能就是在打碎重组的过程中…</p><hr><p>经济&amp;个人</p><ul><li>兴趣 + 深度 + 商业思考 ，可能是普通人最应该思考的东西</li><li>普通人的思考框架与商人思维父母一代与年轻人的思维差异：年轻人应该及早思考未来五到十年，做好预判，选择正确的行业和方向，才有可能性~</li><li>宏观环境，中观的行业，微观公司（个人）</li></ul><p>商业的思维与行动</p><ul><li>交易机会与赚钱的方法<ul><li>我们买什么</li><li>我们通过什么渠道，卖什么？<ul><li><strong>交易机会的存在和赚钱的方法</strong></li><li><strong>套利机会</strong></li></ul></li></ul></li></ul><blockquote><p>价差套利、利差 和 信息差，其分享了自己倒卖车辆和房子的经验，以及如何利用信息差赚取差价。倒卖房产和二手车赚钱的机会</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ai与教育（一）</title>
    <link href="/posts/7d10a5fe/"/>
    <url>/posts/7d10a5fe/</url>
    
    <content type="html"><![CDATA[<p>我想以一些问题来开启这个话题。作为长期以来缺乏教育资源的群体之一，我也将长期关注这个话题，期待各位的理解～</p><h3 id="国内的小学与中学学生能使用AI来完成作业吗？"><a href="#国内的小学与中学学生能使用AI来完成作业吗？" class="headerlink" title="国内的小学与中学学生能使用AI来完成作业吗？"></a>国内的小学与中学学生能使用AI来完成作业吗？</h3><p>不建议。原因在于，人的基础能力需要通过理解、刻意练习、间歇性回忆（对抗艾宾浩斯遗忘曲线）以及睡眠来加强，以形成长期记忆，从而促使大脑和肌肉记忆。如果直接忽视这些基础步骤，让AI来完成作业，虽然你可能能在日常生活中应对，但当面临考试，AI被禁用时，你可能会因为理解不深入，练习不足，而在考场上抓瞎。</p><p>有一种例外就是，你确定你已经理解与熟练了，但是作业量过大，且都是重复性的任务时，使用AI 来保证睡眠时间是可取的。</p><p>除了上述的情况，可以在知识性辅导方面使用AI。比如，如果你不理解老师的讲解，或者所在地区没有足够的教育资源，那么使用AI辅助你自我学习是完全没有问题的。每个人小时候都有足够的好奇心来打砂锅问到底，家长也没知识储备去应付时，AI的大百科全书属性就能很好的发挥作用，我觉得叫它知识平权更合适。通过自己提出问题和基础思路，让 AI 辅助你进行思考，与理解，最终解决问题，这才是在这个阶段的正确操作。</p><h3 id="大学生或者成年人如何通过-AI-进行学习？"><a href="#大学生或者成年人如何通过-AI-进行学习？" class="headerlink" title="大学生或者成年人如何通过 AI 进行学习？"></a>大学生或者成年人如何通过 AI 进行学习？</h3><p>在大学时，第一门课可能就是如何使用 AI，理解其优点和缺点，以及掌握基础的使用技巧，例如<code>prompt</code>和上下文等。AI的使用场景可以总结为：<strong>如果你理解但不想花时间去做，这是合理的应用；如果你不理解却想省时间去做，那就是作弊行为。</strong></p><p>如果你想在某个领域脱颖而出，采用框架思维和阅读大部头的书籍是必不可少的。这个过程可能会慢，但却是必要的。</p><p>如果你更加注重实际效果，或者说更加现实（在现实中，只有解决问题才能获得收益），我们往往需要整合大量的流程来实现目标，而不需要对每一个流程的原理和发展有深入的理解。</p><p>在这种情况下，AI不再只是加强理解，而是快速给出基础框架与逻辑。你需要 <strong>面向问题或方案去学习</strong>，以最终的 <strong>结果为导向</strong>。它在整个过程中都会增强你的信息收集与处理能力。你需要做的就是判断AI给出的信息在逻辑上是否合理。</p><p>这就是我对 AI 时代学习与传统学习最大不同的理解：知识性的内容被大量压缩，人们需要学习的是如何去整合，去判断合理性，然后去强力实施，以观察结果。</p><h3 id="AI能否取代当前的教师？"><a href="#AI能否取代当前的教师？" class="headerlink" title="AI能否取代当前的教师？"></a>AI能否取代当前的教师？</h3><p>在国内，教师的角色是多元化且复合的，AI只能在知识教授领域中起到替代和辅助的作用。</p><p>也就是说，如果老师的工作仅仅是教授知识，那么AI的替代性就越高。</p><p>当前的AI只能被动地接收信息和执行指令，而教师则是主动的引导者。他们不仅教授知识，还能激发学生的创新思维和批判性思考。</p><p>因此，尽管AI可能会改变教育的形式，但它无法完全取代教师。</p><h3 id="在AI时代，哪些学习内容具有更高的性价比？"><a href="#在AI时代，哪些学习内容具有更高的性价比？" class="headerlink" title="在AI时代，哪些学习内容具有更高的性价比？"></a>在AI时代，哪些学习内容具有更高的性价比？</h3><ol><li><strong>学习提问的技巧</strong>，因为在这个信息爆炸的时代，提出正确的问题比寻找答案更重要。</li><li><strong>流程设计和领导能力</strong>，你需要设计流程并通过人类与虚拟AI的协作来运行，这样你一个人就能成为一个公司。</li><li><strong>数据分析和解读</strong>，在AI时代，数据是新的石油。能够识别真假信息并懂得如何处理和解读数据的人，将更可能抓住未来的机会。</li><li><strong>加强思维逻辑训练</strong>，拥有多种思考框架可以更好地分析和解决问题，从而提高问题解决和决策制定的能力。</li><li><strong>适应能力</strong>，除了知识，我们还需要其他能力，如在变化中保持平衡，适应新环境，面对未知不感到恐惧。</li></ol><hr><p><strong>终身学习不再是一句口号，而是我们每个人都要面对的现实～</strong></p>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>教育</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地大模型在obsidian中的实践</title>
    <link href="/posts/57e41d6f/"/>
    <url>/posts/57e41d6f/</url>
    
    <content type="html"><![CDATA[<h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><blockquote><p>Obsidian: 一种支持多平台的知识管理和笔记应用，它允许用户创建、编辑和链接他们的笔记，支持Markdown格式，可以帮助用户更好地组织和查找他们的知识。</p></blockquote><blockquote><p>Ollama: 是一个 local AI 工具，它可以在本地运行，并提供与openai 类似的API，无需联网便能实现强大的计算和数据分析功能。</p></blockquote><blockquote><p><strong>2B</strong>&#x2F;<strong>7B</strong> : 指的是模型的大小，2B 指的是20亿参数模型，7B 指的是70亿参数模型。这些参数决定了模型的复杂度和处理能力。</p></blockquote><blockquote><p>GitHub Copilot : 是一个由GitHub和OpenAI共同开发的人工智能编程助手。它可以根据你的代码和注释，自动生成代码建议，帮助你更快地编写代码。</p></blockquote><blockquote><p>FP16 : 16位浮点数 , 1 字节 8位，所以需要 2字节进行存储。</p></blockquote><h2 id="0x01-起源"><a href="#0x01-起源" class="headerlink" title="0x01 起源"></a>0x01 起源</h2><p>本篇将会介绍，如何在 Obsidian 中，通过 <code>ollama</code> &#x2F; <code>openai</code> 的能力进行文章编写。这个想法的来源是 GitHub Copilot 中的 idea。</p><p>在软件开发中，GitHub Copilot 已经展示了其强大的编程辅助能力，那么为何我们不能在文章编写中也利用到类似的技术呢？这就是我想在 Obsidian 中利用 ollama 或 openai 能力进行快速文章编写的初衷。</p><p>首先，我们在 GitHub 上找到了一个 插件 <a href="https://github.com/pfrankov/obsidian-local-gpt">Local GPT</a>提供了 Obsidian 链接 到 <code>OpenAI</code>&amp;<code>ollama</code> 的功能，这使我们可以直接在 Obsidian 中调用AI的能力。这个插件的使用非常简单，只需要简单的安装和配置，就可以开始我们的AI写作旅程了。</p><h2 id="0x02-本地modelVSopenai"><a href="#0x02-本地modelVSopenai" class="headerlink" title="0x02 本地modelVSopenai"></a>0x02 本地<code>model</code>VS<code>openai</code></h2><blockquote><p>最大的问题就在于<strong>隐私和数据安全</strong>这一方面。虽然OpenAI已经采取了严格的数据安全措施，但数据仍然需要通过网络发送，而OpenAI本身也会存储这些数据。</p></blockquote><blockquote><p><strong>成本</strong>是另一个需要考虑的问题。当本地模型的硬件足够时，我们最多需要考虑的是电费，但OpenAI 的 gpt4 api 的价格并不便宜。</p></blockquote><blockquote><p>在谈到<strong>可定制性</strong>时，这需要你具备一定的开发能力，以及对硬件设备、数据采集和模型训练的经验。然而，随着开源产品的不断迭代和改进，这种要求将会变得更为普遍且操作更为简便。</p></blockquote><h3 id="ollama"><a href="#ollama" class="headerlink" title="ollama"></a>ollama</h3><p>通过 <a href="https://ollama.ai/">https://ollama.ai</a> 下载安装，然后根据你的电脑配置选择合适的模型。</p><blockquote><p>实际上在装好 ollama 之后，它本身也只是一个模型推理服务上，为了更加直观的使用，推荐与其配套的一个前端，<a href="https://github.com/open-webui/open-webui">https://github.com/open-webui/open-webui</a>。就目前的体验来说，已经很不错了, 除了 docker 运行容器有点大以外。</p></blockquote><h4 id="如何-在-ollama-中给你的电脑选择合适的模型？"><a href="#如何-在-ollama-中给你的电脑选择合适的模型？" class="headerlink" title="如何 在 ollama 中给你的电脑选择合适的模型？"></a>如何 在 ollama 中给你的电脑选择合适的模型？</h4><h5 id="模型大小跟显存大小的关系是什么？"><a href="#模型大小跟显存大小的关系是什么？" class="headerlink" title="模型大小跟显存大小的关系是什么？"></a>模型大小跟显存大小的关系是什么？</h5><blockquote><p>首先要回答这么一个问题，FP16的模型，每增加1B参数量需要增加 2GB 的显存去加载是怎么推算出来的？</p></blockquote><p>在深度学习模型中，模型的参数通常以权重的形式存储。每个权重通常是一个浮点数，一般使用16位浮点数，那么每个权重就需要16位，即2字节的存储空间。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>,<span class="hljs-number">000</span>,<span class="hljs-number">000</span>,<span class="hljs-number">000</span> x <span class="hljs-number">2</span> (字节/byte)  / <span class="hljs-number">1024</span> = <span class="hljs-number">1</span>,<span class="hljs-number">953</span>,<span class="hljs-number">125</span> (KB) <br><span class="hljs-attribute">1</span>,<span class="hljs-number">953</span>,<span class="hljs-number">125</span> / <span class="hljs-number">1024</span> = <span class="hljs-number">1</span>,<span class="hljs-number">907</span>.<span class="hljs-number">3486328125</span> (MB)<br><span class="hljs-attribute">1</span>,<span class="hljs-number">907</span>.<span class="hljs-number">3486328125</span> / <span class="hljs-number">1024</span> = <span class="hljs-number">1</span>.<span class="hljs-number">8626451</span> (GB)<br></code></pre></td></tr></table></figure><p>也就是说使用 fb16 的模型，每1B的模型就需要 2GB 的显存。</p><h5 id="什么是模型量化？"><a href="#什么是模型量化？" class="headerlink" title="什么是模型量化？"></a>什么是模型量化？</h5><p>搞清楚 模型大小跟显存大小的关系后，这个问题之后 ，我们来接受一个概念 <strong>模型量化</strong>，既然用 fb16 能存数据，那么我们用更小的数据类型是不是也能存，通过减少模型权重的精度，从而减小模型大小和运行时间，这就是 <strong>模型量化</strong> 。</p><p>模型量化技术通常将浮点数权重转换为定点数权重。例如，原本需要16位精度（即float16）的权重，经过量化后，通常会损失一些精度，但可能只需要8位精度（即int8）就足够了。这样的话，模型的大小就可以减小到原来的1&#x2F;2，而且计算速度也会显著提高。</p><p>但是 <strong>量化会导致模型的准确性下降</strong>  ， 目前大模型中性价比最高的是，量化 Q4 也就是将 FP16 转为 int4 , 单个参数的大小降低为原来的1&#x2F;4, 理论上模型加载耗费也为原来的 1&#x2F;4 。</p><p>让我们来大致预估计算下 7B模型，量化Q4 需要多少显存才能运行</p><blockquote><p><code>7B * 2 = 14GB  ，14GB * 1/4 = 3.5GB</code><br><code>13B * 2 = 26GB  ，28GB * 1/4 = 6.5GB</code> </p></blockquote><p>所以理论上本地只需要 4G 显存就能运行7B-Q4 的模型，8G 就能运行 13B-Q4 模型</p><h5 id="我的电脑是什么配置？"><a href="#我的电脑是什么配置？" class="headerlink" title="我的电脑是什么配置？"></a>我的电脑是什么配置？</h5><blockquote><p>显卡 1060 6GB , CPU I5-8400 , 内存 ddr3 2400 32GB</p></blockquote><p>所以理论上，我能加载可以选择 运行 7B 的模型，想想还有点小开心~</p><p>接下来进入实践，我去找了下相关模型的 Q4 量化版本，发现模型大小一般都在 3.8GB 起 比如</p><ul><li><code>llama2:7b-chat-q4_0</code> -&gt; <strong>3.8GB</strong></li><li><code>mistral:7b-instruct-q4_0</code> -&gt; <strong>4.1GB</strong></li><li><code>llava:7b-v1.5-q4_0</code> -&gt; <strong>4.5GB</strong></li><li><code>qwen:7b-chat-v1.5-q4_0</code> -&gt; <strong>4.5GB</strong></li><li><code>gemma:7b-instruct-q4_0</code> -&gt; <strong>5.2GB</strong></li></ul><p>这是因为模型的量级不可能是固定的70亿，在这个基础上浮动也很正常，对外统一宣称7B，再加上附加的其他参数，多1-2G 也很正常。</p><p>我进行了本地测试进行验证，结果如下</p><table><thead><tr><th>模型</th><th>大小</th><th>推理速度(tokens&#x2F;s)</th><th>是否可用</th></tr></thead><tbody><tr><td>gemma:2b</td><td>1.7 GB</td><td>61.29</td><td>✔</td></tr><tr><td>qwen:4b-chat-v1.5-q4_0</td><td>2.3 GB</td><td>40.5</td><td>✔</td></tr><tr><td>qwen:4b-chat-v1.5-q5_1</td><td>3.0 GB</td><td>36.54</td><td>✔</td></tr><tr><td>qwen:7b-chat-v1.5-q2_K</td><td>3.1GB</td><td>22.03</td><td>✔</td></tr><tr><td>yi:6b</td><td>3.5 GB</td><td>32.38</td><td>✔</td></tr><tr><td>gemma:7b-instruct-q2_K</td><td>3.7 GB</td><td>12.58</td><td>✔</td></tr><tr><td>llama2:7b-chat-q4_0</td><td>3.8 GB</td><td>14.54</td><td>✔</td></tr><tr><td>gemma:7b</td><td>5.2GB</td><td>6.64</td><td>✔</td></tr></tbody></table><ul><li>注，当模型大小大于 5.2 GB 后，1060 可能就会出现无法加载的问题了，另外 推理速度的快慢对于实际应用非常重要，可以不对，但是慢的话，就真不如使用远程 gpt4 的 api，对于这个点，我个人的感觉是 模型的推理速度低于 20 tokens&#x2F;s 时，用户就会明显感受到延迟，特别是被集成使用的时候，需要 应用对大模型的响应速度进行妥协设计。</li></ul><h5 id="如何去根据模型大小跟设备情况去推算-tokens-的预计值呢？"><a href="#如何去根据模型大小跟设备情况去推算-tokens-的预计值呢？" class="headerlink" title="如何去根据模型大小跟设备情况去推算 tokens 的预计值呢？"></a>如何去根据模型大小跟设备情况去推算 tokens 的预计值呢？</h5><ul><li>分几种情况 只用 GPU，只用 CPU 与混合使用，以 Nvidia 的 GeForce GTX 1060 显卡为例，其显存带宽为 <strong>192GB&#x2F;s</strong>。而本地 DDR3 2400 内存条的理论值是 <strong>19.2 GB&#x2F;s</strong> 的带宽</li><li>在推理过程中，模型首先被加载到内存中，然后每生成一个 token，我们都需要从内存中遍历一遍模型。因此，模型越大，生成每个 token 所需的时间就越长。</li><li><code>192 / 1.7 = 112</code> 是预计 gemma:2b 的速度值，但是实际上只能跑到 61.29 ，也就是说我本地电脑，在各种偏差后 只能达到 预计值的 54% 左右，当加载的模型超过 3GB 时，这个比例可能会降低到预计值的 30%，而当模型超过 5GB 时，可能会进一步降低到预计值的 16.6%。</li><li>而实际观察 cpu 跟内存的负载，在推理时，有了明显的增加，可以认为其也参与了计算，所以 我的理解为 ollama 在Windows 上使用了 gpu跟 cpu 混合计算来进行推理</li></ul><p>跟推理计算直接关联的变量为，<strong>设备类型</strong>（GPU,CPU,）内存、显存大小跟其对应的带宽大小，还有 <strong>模型大小</strong> ，随着 上下文 token 变大，其推理速度也会变小。</p><p>最终我在本地 1060显卡的配置下， 选择的模型是 yi:6b 跟 qwen:4b , 而根据一些实践者的观点 60B 模型才是 ai 有理解能力的关键节点，就算 Q4 量化，也需要 30GB 的显存才能流畅的运行，虽然拿 cpu + 内存也不是不能跑，但是就这个运行效率估计就 1-2 token 的数据 实在难以接受。</p><p>如果你的显存是6G以下，最好选择4B-Q4左右的模型，而如果你有8G或12G的显存，那么7B的模型对你来说已经没有什么压力了。</p><p>至于模型的能力，确实是一分算力一分货。模型的大小与训练时的文本质量，直接影响了生成的文本质量，更大的模型通常能生成更准确，更自然的文本。</p><h3 id="OpenAI"><a href="#OpenAI" class="headerlink" title="OpenAI"></a>OpenAI</h3><p>对于<code>OpenAI</code>，我们需要通过其API进行调用，并且需要注意API的调用次数和费用。我们也需要注意个人敏感信息的安全。虽然 OpenAI 的计算能力强大，但使用它需要一定的编程基础和对API 的使用与限制（内容安全，上下文大小，prompt 工程）有所了解。由于它是云端服务，所以在数据安全方面也存在一定的风险。</p><p>我本身是通过 <code>GitHub Copilot</code> 购买了一年的服务，然后通过 <a href="https://github.com/whyiyhw/copilot-gpt4-service">https://github.com/whyiyhw/copilot-gpt4-service</a> 开放了 <code>GPT-4 API</code>，因此我可以无限制地使用API，而不用担心账单问题。我本身也阅读了 <code>Local GPT</code> 的源码，并确认了使用它是无风险的。其他使用者需要自行关注这些点。</p><h2 id="0x03-如何使用"><a href="#0x03-如何使用" class="headerlink" title="0x03 如何使用"></a>0x03 如何使用</h2><p>一旦你完成了上述的安装和配置，你就可以开始你的AI协作编辑之旅了。</p><p>我自己定义了一些常用的功能，这些功能可以通过 <code>Local GPT &gt; Add new manually</code> 来加入。这些功能包括<strong>续写</strong>，<strong>总结</strong>，<strong>翻译</strong>，<strong>语句语法检查</strong>，<strong>自动给文章加标签</strong>，以及在 obsidian 中特色的<strong>出链</strong>，<strong>画 Mermaid 图</strong>，和<strong>从文本中列出任务</strong>等。</p><p>接下来，我将简单介绍其中的两个功能。</p><h3 id="续写"><a href="#续写" class="headerlink" title="续写"></a>续写</h3><p>你可以在 Obsidian 中创建一个新的文档，然后开始输入你的想法或者草稿，接着，你只需要按下特定的快捷键（比如<code>alt + \</code> 我定义的），ai 就会自动为你生成一段接续的文本， 并且这段文本会紧接着你的原始内容，形成一个完整的故事或者观点。这样你就可以无缝地继续你的写作，而不需要担心受到创作阻塞的困扰。<br>【ps: 🌟其实算是偷懒，大致写出骨架，AI 补全剩下的内容, 不用太关注细节，更加流畅。】</p><p><img src="/img/post/article_ollama_obsidian_01.png" alt="/img/post/article_ollama_obsidian_01"></p><h3 id="事实性错误纠正"><a href="#事实性错误纠正" class="headerlink" title="事实性错误纠正"></a>事实性错误纠正</h3><blockquote><p>写完后让ai检查文章中的错误，相当于 ai 的校正编辑</p></blockquote><p><img src="/img/post/article_ollama_obsidian_03.png" alt="/img/post/article_ollama_obsidian_03"></p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><blockquote><p>通过对指定部分的选中，你可以将其翻译为任何你需要的语言。<br>By selecting the specified part, you can translate it into any language you need.</p></blockquote><p><img src="/img/post/article_ollama_obsidian_02.png" alt="/img/post/article_ollama_obsidian_02"></p><h2 id="0x04-结论"><a href="#0x04-结论" class="headerlink" title="0x04 结论"></a>0x04 结论</h2><ul><li>对比 2023 年的模型遥不可及，到 2024 年的本地小模型可以运行了，期待 1-2年后，可能每个人电脑上都能运行 跟 gpt3.5 同等水平的 ai 。</li><li>利用 AI 技术，极大地增强了 Obsidian 作为文本编辑器的能力。</li><li>最重要的是，这可以提升我持续输出的能力。<strong>write less , do more</strong>。</li></ul><h2 id="0x05-扩展小问题？"><a href="#0x05-扩展小问题？" class="headerlink" title="0x05 扩展小问题？"></a>0x05 扩展小问题？</h2><ol><li><code>ollama</code> 和 <code>openai</code> 有什么区别和优势，该如何选择？</li><li>我可以在本地运行哪些模型？如何选择适合我电脑配置的模型？</li><li>如何在 Obsidian 中使用 AI 功能进行文章编写？</li></ol>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>ollama</tag>
      
      <tag>openai</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>laravel-horizon原理与实践</title>
    <link href="/posts/3139d2fc/"/>
    <url>/posts/3139d2fc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基于 <code>laravel10</code>，<code>laravel-horizon 5.21.4</code> 与 <code>php8.1</code>  得到的结论,（2023-11-30）</p></blockquote><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="安装与发布"><a href="#安装与发布" class="headerlink" title="安装与发布"></a>安装与发布</h3><ul><li>前置条件 <blockquote><p>需要 <code>pcntl,posix</code> 扩展</p></blockquote></li><li>安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">composer require laravel/horizon<br></code></pre></td></tr></table></figure></li><li>发布<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">php artisan horizon:install<br></code></pre></td></tr></table></figure></li><li>重新发布 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">php artisan horizon:publish<br></code></pre></td></tr></table></figure></li></ul><h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><blockquote><p><code>config/horizon.php</code><br>balance 改为 false ，正常 job 逻辑就行</p></blockquote><h3 id="定时器修改"><a href="#定时器修改" class="headerlink" title="定时器修改"></a>定时器修改</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// horizon 统计数据生成  </span><br><span class="hljs-variable">$schedule</span>-&gt;<span class="hljs-title function_ invoke__">command</span>(<span class="hljs-string">&#x27;horizon:snapshot&#x27;</span>)-&gt;<span class="hljs-title function_ invoke__">everyFiveMinutes</span>();<br></code></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><blockquote><p><code>php artisan horizon</code><br>查看 <code>http://&#123;your host&#125;/horizon</code></p></blockquote><h3 id="supervisor-部署"><a href="#supervisor-部署" class="headerlink" title="supervisor 部署"></a>supervisor 部署</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[program:laravel-horizon]</span><br><span class="hljs-attr">process_name</span>=%(program_name)s<br><span class="hljs-attr">command</span> = php artisan horizon<br><span class="hljs-attr">directory</span> = /project/path<br><span class="hljs-attr">autostart</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">startsecs</span> = <span class="hljs-number">5</span><br><span class="hljs-attr">autorestart</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">startretries</span> = <span class="hljs-number">3</span><br><span class="hljs-attr">user</span> = root<br><span class="hljs-attr">redirect_stderr</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">stdout_logfile_maxbytes</span> = <span class="hljs-number">10</span>MB<br><span class="hljs-attr">stdout_logfile_backups</span> = <span class="hljs-number">5</span><br><span class="hljs-attr">stdout_logfile</span> = /var/log/laravel-horizon.log<br></code></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><h3 id="horizon-如何去-hook-队列的？"><a href="#horizon-如何去-hook-队列的？" class="headerlink" title="horizon 如何去 hook 队列的？"></a>horizon 如何去 hook 队列的？</h3><ul><li><p>在应用启动时，服务注册 去注入 QueueManager 的 connector 关联闭包</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//vendor/laravel/horizon/src/HorizonServiceProvider.php:141</span><br><span class="hljs-title class_">\Laravel\Horizon\HorizonServiceProvider</span>::<span class="hljs-title function_ invoke__">register</span>()<br><br><span class="hljs-comment">//vendor/laravel/horizon/src/HorizonServiceProvider.php:153</span><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">registerQueueConnectors</span>();<br><br><span class="hljs-comment">//vendor/laravel/horizon/src/HorizonServiceProvider.php:189</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerQueueConnectors</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-comment">//vendor/laravel/framework/src/Illuminate/Queue/QueueManager.php</span><br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">callAfterResolving</span>(<span class="hljs-title class_">QueueManager</span>::<span class="hljs-variable language_">class</span>, function (<span class="hljs-variable">$manager</span>) &#123;  <br>        <span class="hljs-variable">$manager</span>-&gt;<span class="hljs-title function_ invoke__">addConnector</span>(<span class="hljs-string">&#x27;redis&#x27;</span>, function () &#123;  <br>        <span class="hljs-comment">//vendor/laravel/horizon/src/Connectors/RedisConnector.php </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisConnector</span>(<span class="hljs-variable language_">$this</span>-&gt;app[<span class="hljs-string">&#x27;redis&#x27;</span>]);  <br>        &#125;);    <br>    &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>当 <code>dispatch</code> 被调用的时候</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//vendor/laravel/framework/src/Illuminate/Foundation/Bus/PendingDispatch.php::__destruct():193</span><br><span class="hljs-title function_ invoke__">app</span>(<span class="hljs-title class_">Dispatcher</span>::<span class="hljs-variable language_">class</span>)-&gt;<span class="hljs-title function_ invoke__">dispatch</span>(<span class="hljs-variable">$this</span>-&gt;job);<br><br><span class="hljs-comment">//vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php::dispatch():76</span><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">dispatchToQueue</span>(<span class="hljs-variable">$command</span>)<br><br><span class="hljs-comment">//vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php::dispatchToQueue():229</span><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">pushCommandToQueue</span>(<span class="hljs-variable">$queue</span>, <span class="hljs-variable">$command</span>);<br><br><span class="hljs-comment">//vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php::pushCommandToQueue():253</span><br><span class="hljs-variable">$queue</span>-&gt;<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-variable">$command</span>);<br><br><span class="hljs-comment">// 这里的 $queue 变成了 </span><br><span class="hljs-comment">// vendor/laravel/horizon/src/RedisQueue.php::push():42</span><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">enqueueUsing</span>(  <br>    <span class="hljs-variable">$job</span>,  <br>    <span class="hljs-variable">$this</span>-&gt;<span class="hljs-title function_ invoke__">createPayload</span>(<span class="hljs-variable">$job</span>, <span class="hljs-variable">$this</span>-&gt;<span class="hljs-title function_ invoke__">getQueue</span>(<span class="hljs-variable">$queue</span>), <span class="hljs-variable">$data</span>),  <br>    <span class="hljs-variable">$queue</span>,  <br>    <span class="hljs-literal">null</span>,  <br>    function (<span class="hljs-variable">$payload</span>, <span class="hljs-variable">$queue</span>) <span class="hljs-keyword">use</span> ($<span class="hljs-title">job</span>) &#123;<br>        $<span class="hljs-title">this</span>-&gt;<span class="hljs-title">lastPushed</span> = $<span class="hljs-title">job</span>;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">pushRaw</span>(<span class="hljs-variable">$payload</span>, <span class="hljs-variable">$queue</span>);  <br>    &#125;);<br><br><span class="hljs-comment">//其重载了 </span><br><span class="hljs-comment">//vendor/laravel/framework/src/Illuminate/Queue/RedisQueue.php::push():132</span><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">enqueueUsing</span>(  <br>    <span class="hljs-variable">$job</span>,  <br>    <span class="hljs-variable">$this</span>-&gt;<span class="hljs-title function_ invoke__">createPayload</span>(<span class="hljs-variable">$job</span>, <span class="hljs-variable">$this</span>-&gt;<span class="hljs-title function_ invoke__">getQueue</span>(<span class="hljs-variable">$queue</span>), <span class="hljs-variable">$data</span>),  <br>    <span class="hljs-variable">$queue</span>,  <br>    <span class="hljs-literal">null</span>,  <br>    function (<span class="hljs-variable">$payload</span>, <span class="hljs-variable">$queue</span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">pushRaw</span>(<span class="hljs-variable">$payload</span>, <span class="hljs-variable">$queue</span>);  <br>    &#125;);<br></code></pre></td></tr></table></figure></li><li><p>对比下 两个方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//vendor/laravel/framework/src/Illuminate/Queue/RedisQueue.php::pushRaw():153</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushRaw</span>(<span class="hljs-params"><span class="hljs-variable">$payload</span>, <span class="hljs-variable">$queue</span> = <span class="hljs-literal">null</span>, <span class="hljs-keyword">array</span> <span class="hljs-variable">$options</span> = []</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">getConnection</span>()-&gt;<span class="hljs-keyword">eval</span>(  <br>        <span class="hljs-title class_">LuaScripts</span>::<span class="hljs-title function_ invoke__">push</span>(), <span class="hljs-number">2</span>, <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">getQueue</span>(<span class="hljs-variable">$queue</span>),  <br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">getQueue</span>(<span class="hljs-variable">$queue</span>).<span class="hljs-string">&#x27;:notify&#x27;</span>, <span class="hljs-variable">$payload</span>  <br>    );  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">json_decode</span>(<span class="hljs-variable">$payload</span>, <span class="hljs-literal">true</span>)[<span class="hljs-string">&#x27;id&#x27;</span>] ?? <span class="hljs-literal">null</span>;  <br>&#125;<br><br><span class="hljs-comment">// vendor/laravel/horizon/src/RedisQueue.php::pushRaw():65</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushRaw</span>(<span class="hljs-params"><span class="hljs-variable">$payload</span>, <span class="hljs-variable">$queue</span> = <span class="hljs-literal">null</span>, <span class="hljs-keyword">array</span> <span class="hljs-variable">$options</span> = []</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-variable">$payload</span> = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">JobPayload</span>(<span class="hljs-variable">$payload</span>))-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-variable">$this</span>-&gt;lastPushed);  <br>  <br>    <span class="hljs-built_in">parent</span>::<span class="hljs-title function_ invoke__">pushRaw</span>(<span class="hljs-variable">$payload</span>-&gt;value, <span class="hljs-variable">$queue</span>, <span class="hljs-variable">$options</span>);  <br>  <br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">event</span>(<span class="hljs-variable">$this</span>-&gt;<span class="hljs-title function_ invoke__">getQueue</span>(<span class="hljs-variable">$queue</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">JobPushed</span>(<span class="hljs-variable">$payload</span>-&gt;value));  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$payload</span>-&gt;<span class="hljs-title function_ invoke__">id</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>很明显,就是装饰器模式，在方法前&#x2F;后加入了 事件机制</p></blockquote><blockquote><p>也就是说，核心的原理就是在 queue 数据存入 redis 前后，会触发定义的 laravel-horizon 事件, 从而去记录 队列的信息</p></blockquote><h3 id="php-artisan-horizon-做了什么？"><a href="#php-artisan-horizon-做了什么？" class="headerlink" title="php artisan horizon 做了什么？"></a><code>php artisan horizon</code> 做了什么？</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//vendor/laravel/horizon/src/Console/HorizonCommand.php::handle():56</span><br><span class="hljs-variable">$master</span>-&gt;<span class="hljs-title function_ invoke__">monitor</span>();<br><br><span class="hljs-comment">//vendor/laravel/horizon/src/MasterSupervisor.php::monitor():211</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">monitor</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">ensureNoOtherMasterSupervisors</span>();  <br>  <br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">listenForSignals</span>();  <br>  <br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">persist</span>();  <br>  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>        <span class="hljs-title function_ invoke__">sleep</span>(<span class="hljs-number">1</span>);  <br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">loop</span>();  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>很显然，核心在于 while 循环 中的 loop<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//vendor/laravel/horizon/src/MasterSupervisor.php::monitor():245</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 处理 等待中 的信号</span><br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">processPendingSignals</span>();  <br>        <span class="hljs-comment">// 处理 等待中 的命令</span><br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">processPendingCommands</span>();  <br><br><span class="hljs-comment">// 运行中</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;working) &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">monitorSupervisors</span>();  <br>        &#125;  <br>        <span class="hljs-comment">// 更新 监控信息</span><br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">persist</span>();  <br><br><span class="hljs-comment">// 触发 监控事件</span><br>        <span class="hljs-title function_ invoke__">event</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MasterSupervisorLooped</span>(<span class="hljs-variable">$this</span>));  <br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span>) &#123;  <br>        <span class="hljs-title function_ invoke__">app</span>(<span class="hljs-title class_">ExceptionHandler</span>::<span class="hljs-variable language_">class</span>)-&gt;<span class="hljs-title function_ invoke__">report</span>(<span class="hljs-variable">$e</span>);  <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// vendor/laravel/horizon/src/EventMap.php:50</span><br><span class="hljs-title class_">Events\MasterSupervisorLooped</span>::<span class="hljs-variable language_">class</span> =&gt; [  <br>    <span class="hljs-title class_">Listeners\TrimRecentJobs</span>::<span class="hljs-variable language_">class</span>,  <br>    <span class="hljs-title class_">Listeners\TrimFailedJobs</span>::<span class="hljs-variable language_">class</span>,  <br>    <span class="hljs-title class_">Listeners\TrimMonitoredJobs</span>::<span class="hljs-variable language_">class</span>,  <br>    <span class="hljs-title class_">Listeners\ExpireSupervisors</span>::<span class="hljs-variable language_">class</span>,  <br>    <span class="hljs-title class_">Listeners\MonitorMasterSupervisorMemory</span>::<span class="hljs-variable language_">class</span>,  <br>]<br></code></pre></td></tr></table></figure><blockquote><p>总结下就是一个一秒的定时器，去持续的监控 Supervisor 的状态</p></blockquote></li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="laravel-horizon-会影响-job-消费吗？"><a href="#laravel-horizon-会影响-job-消费吗？" class="headerlink" title="laravel-horizon 会影响 job 消费吗？"></a><code>laravel-horizon</code> 会影响 job 消费吗？</h3><blockquote><p>根据原理，我们知道 其核心原理为 替换了 队列操作 <code>redis</code> 的方法，其本身不会影响 job 的功能，  <code>php artisan horizon</code>  也不会 影响到  <code>php artisan queue:work</code> </p></blockquote><h3 id="auth-与-sanctum-如何结合起来？"><a href="#auth-与-sanctum-如何结合起来？" class="headerlink" title="auth 与 sanctum 如何结合起来？"></a>auth 与 sanctum 如何结合起来？</h3><blockquote><p>我们知道 sanctum 就是通过 header 中 传入 token 来实现的认证<br><code>app/Providers/HorizonServiceProvider.php</code> 中存在 gate 方法 内部的闭包函数返回 true 就代表响应成功，<br>又因为 api 与前端使用了同一个域名，那么久简单了，登录后将 token 信息存入 cookie, 在闭包内读取</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 获取 cookie 中的 token 信息  </span><br><span class="hljs-variable">$token</span> = <span class="hljs-title function_ invoke__">request</span>()?-&gt;<span class="hljs-title function_ invoke__">cookie</span>(<span class="hljs-string">&#x27;token&#x27;</span>) ?? <span class="hljs-string">&quot;&quot;</span>;  <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$token</span>) || !<span class="hljs-title function_ invoke__">str_contains</span>(<span class="hljs-variable">$token</span>, <span class="hljs-string">&#x27;Bearer&#x27;</span>)) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-variable">$token</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;Bearer &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$token</span>);  <br><span class="hljs-comment">// 通过 sanctum token 获取 user 信息</span><br><span class="hljs-variable">$userId</span> = <span class="hljs-title class_">PersonalAccessToken</span>::<span class="hljs-title function_ invoke__">findToken</span>(<span class="hljs-variable">$token</span>)-&gt;tokenable_id ?? <span class="hljs-number">0</span>;  <br><span class="hljs-variable">$user</span> = <span class="hljs-title class_">AdminUsers</span>::<span class="hljs-title function_ invoke__">query</span>()-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-variable">$userId</span>);<br></code></pre></td></tr></table></figure><blockquote><p>再指定用户可访问就好</p></blockquote><h3 id="缺点有哪些？"><a href="#缺点有哪些？" class="headerlink" title="缺点有哪些？"></a>缺点有哪些？</h3><blockquote><p>扩展性不够好，想要改 js 跟 blade 模版很困难，特别是 balde 内部链接默认走 http ，导致我只能在生成缓存文件后，再去替换，确实很难受。</p></blockquote><blockquote><p>通知机制一般，不支持自定义的 webhook </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>laravel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>laravel</tag>
      
      <tag>horizon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数计算对业务进行优化的思路</title>
    <link href="/posts/9e5e9a5e/"/>
    <url>/posts/9e5e9a5e/</url>
    
    <content type="html"><![CDATA[<h2 id="函数计算简介"><a href="#函数计算简介" class="headerlink" title="函数计算简介"></a>函数计算简介</h2><p>函数计算（Function as a Service，FaaS）是一种云计算服务模型，它将应用程序的开发和部署从基础设施管理中解放出来，开发者只需关注代码的编写，而无需担心服务器的运维。</p><p>以上为比较官方的理解，我的理解就是 一次性的容器（运维不用操心），代码传上去就行，一般来说就是单一功能的处理。实践了阿里云的 <code>fc</code> 之后，发现其实也是要操心一些基础的运维参数，比如超时时间，cpu跟磁盘用多少合适。但相对于传统运维，已经算是精简了不少。</p><h3 id="fc-的主要特点"><a href="#fc-的主要特点" class="headerlink" title="fc 的主要特点"></a>fc 的主要特点</h3><p>优点还挺多的</p><ul><li>付费规则基本就是，按量付费，特别适合突发，量少，但是特别耗费资源的一些任务，比如（大批量的图片打包压缩）… </li><li>运维省心，自动横向扩展，根据厂商开发实力，基本能做到快速启动</li><li>事件&#x2F;http 驱动、接入现有系统很方便</li></ul><p>缺点同样突出</p><ul><li>无法避免的<strong>冷启动延迟</strong>；</li><li>因为 <strong>执行时间的限制</strong> （阿里 <code>fc</code> 最高10分钟），长时间 job 与定时任务不适合使用。</li><li>函数计算是无状态的，无法共享本地资源。</li><li>开发环境不友好，语言以及版本依赖会有限制。</li><li>项目整体迁移上去，要考虑每一个请求对于资源的要求，比较麻烦。</li><li>监控跟调试就看云厂商的能力了，大批量使用成本不一定会低。</li></ul><h3 id="fc-的应用场景"><a href="#fc-的应用场景" class="headerlink" title="fc 的应用场景"></a>fc 的应用场景</h3><p>我认为主要应用场景，就是事件驱动的任务，各类耗资源的轻量级 job 都可以转为 fc 执行</p><h3 id="fc-在项目中的实践"><a href="#fc-在项目中的实践" class="headerlink" title="fc 在项目中的实践"></a>fc 在项目中的实践</h3><ul><li>需求：需要将客户当月的照片&#x2F;视频，根据各种属性，打包成特定目录 zip 并发送给客户邮箱<ul><li>第一版本的思路，开启 job ，将 下载，打包的工作交给 job,问题就出现了，<ol><li>服务器与oss 不在同一网络内，使用外网下载，速度慢，耗费网络资源</li><li>打包出来的文件高达几百M，磁盘读写压力大，多用户执行就更慢了</li><li>php 单进程的网络请求处理，加上 laravel job 的 超时时间控制，整个功能的体验就很差</li></ol></li></ul></li><li>后续的方案思考<ul><li>第一个就是做 任务拆分，多 job 执行，启动一个定时 job 去控制整体的进度，解决了中断与超时问题，但是资源耗费解决不了，执行起来写代码也麻烦。</li><li>第二个就是上 fc ，把网络下载打包，交由fc 执行，上传后响应 链接给 job,改动最小，fc 选用了golang 来写，并发下载，选择同一网络部署，减少网络消耗。</li></ul></li></ul><p>很显然，在这种场景下，fc 完美的解决了，时间慢与资源消耗的问题，最终的结果就是，任务执行时间缩短到原来的 1&#x2F;10 , cpu&amp;磁盘 资源消耗也没了。因为调用次数有限，所以费用也非常低。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>架构这个东西，还是要看业务，需要什么用什么。<br>软件开发没有银弹&#x2F;(ㄒoㄒ)&#x2F;~~</p>]]></content>
    
    
    <categories>
      
      <category>函数计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github-copilot-使用总结-2023</title>
    <link href="/posts/74d092af/"/>
    <url>/posts/74d092af/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GitHub Copilot 是一个ai辅助编程工具（ide 插件）， 底层由 OpenAI Codex(通过对 github 数十亿行公共代码进行训练而成) 驱动。</p><p>Copilot 通过读取注释跟代码中来形成上下文，通过上下文来生成单行或整个函数的代码。  </p><p>具体功能就是会根据你的输入提供代码补全，你可以选择接受或拒绝这些自动生成的代码。</p><h3 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h3><p>整体来看，Copilot 由 底层的 Codex 模型（用于生成代码）， 中间的服务层（用于将用户输入转换为 Codex 模型的输入，以及将 Codex 模型的输出转换为用户可用的代码）还有上层的 ide 插件也就是用户交互层组成。</p><pre><code class=" mermaid">graph LRA[用户] --&gt; B[ide 插件]B --&gt; C[服务层]C --&gt; D[Codex 模型]</code></pre><h2 id="使用场景与技巧演示"><a href="#使用场景与技巧演示" class="headerlink" title="使用场景与技巧演示"></a>使用场景与技巧演示</h2><p>Copilot 的主要功能只有一个，就是根据上下文推测接下来的文本，跟 chatgpt 一样，属于万能的模型，可以认为是专为编程微调的 GPT-3 模型。其他领域具体玩法各位应该可以各自探索。</p><p>在聊编程三件套，<strong>代码&amp;注释</strong>，<strong>测试</strong>，<strong>文档</strong> 这些之前，先来看代理配置与快捷键配置。</p><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>为什么要把这个放在最前面，因为代理的响应速度会极大的影响 coding 体验。<sup><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99:~:4.&text=GitHub%20Copilot%EF%BC%9A%E5%81%9A%E5%87%BA%E4%B8%80%E4%B8%AA%E5%88%92%E6%97%B6%E4%BB%A3%E7%9A%84%E4%BA%A7%E5%93%81%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%206%20%E4%B8%AA%E4%BA%BA" id="ref1">[^4]</a></sup>    </p><p>vscode 配置<br><img src="/img/github-copilot-proxy-01.png" alt="/img/github-copilot-proxy-01"></p><p>idea 配置<br><img src="/img/github-copilot-proxy-02.png" alt="/img/github-copilot-proxy-02"></p><h3 id="idea-中的快捷键"><a href="#idea-中的快捷键" class="headerlink" title="idea 中的快捷键"></a>idea 中的快捷键</h3><ul><li>触发行内 <code>Alt/Option + \</code> 手动触发 copilot 建议</li><li>下一条建议 <code>Alt/Option + ]</code></li><li>上一条建议 <code>Alt/Option + [</code></li><li>接受建议：<code>Tab </code></li><li>拒绝建议：<code>Esc</code></li></ul><p>好了你学会了，可以去试试了，下面是一些使用场景与技巧演示。</p><h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码&amp;注释"></a>代码&amp;注释</h3><h4 id="注释-变量命名"><a href="#注释-变量命名" class="headerlink" title="注释&amp;变量命名"></a>注释&amp;变量命名</h4><p>这个是最常见的，比如我有一个 status 有 5个 状态,我需要定义5个常量，这时候我可以这样写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// status 有 5个 状态 ，正常，异常，警告，错误，未知</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STATUS_NORMAL</span> = <span class="hljs-number">1</span>; <span class="hljs-comment"># 正常</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/github-copilot-01.png" alt="/img/github-copilot-01"><br>根据注释，Copilot 会自动帮你补全常量的定义。<br><img src="/img/github-copilot-02.png" alt="/img/github-copilot-02"><br>根据注释，Copilot 会自动帮你补全注释。</p><ul><li><strong>重点 copilot 会学习你的代码风格，会读取你光标所在位置跟 ide 打开页面的上下文，所以你要写的代码跟这些上下文关联越紧密，copilot 生成的代码就越准确。</strong> <sup><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99:~:text=2023%2D05%2D17%2Dhow%2Dgithub%2Dcopilot%2Dis%2Dgetting%2Dbetter%2Dat%2Dunderstanding%2Dyour%2Dcode" id="ref1">[^3]</a></sup></li></ul><h4 id="代码转换"><a href="#代码转换" class="headerlink" title="代码转换"></a>代码转换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// $str = strtoupper(&quot;hello world&quot;);</span><br><span class="hljs-comment">// ---- translate to javascript 以下 为 copilot 生成的代码 ----</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello world&quot;</span>.<span class="hljs-title function_">toUpperCase</span>();<br></code></pre></td></tr></table></figure><ul><li>技巧：<ul><li>当你需要使用其他语言，但你不知道api时，你可以先用自己熟悉的语言写出来，然后让 copilot 帮你转换成其他语言的代码，这样你就知道怎么使用了</li><li>其实用伪代码也可以，只要 copilot 能 get 你的意思就行</li></ul></li></ul><h4 id="短逻辑补全"><a href="#短逻辑补全" class="headerlink" title="短逻辑补全"></a>短逻辑补全</h4><p>比如我想要判断当前时间是否大于创建时间 1 小时，如果大于就抛出异常，那么我可以这样写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// current time must &gt; created time 1 hour  throw exception 中文提示</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">time</span>() &gt; <span class="hljs-variable">$createdTime</span> + <span class="hljs-number">3600</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;当前时间必须大于创建时间 1 小时&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/github-copilot-03.png" alt="/img/github-copilot-03"></p><p>需要定义异常中响应的格式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// current time must &gt; created time 1 hour else tips 系统处理中，请在 n 分钟 后操作。n = 60 - (当前时间 - 创建时间) / 60</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">time</span>() &gt; <span class="hljs-variable">$createdTime</span> + <span class="hljs-number">3600</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;系统处理中，请在 &#x27;</span> . (<span class="hljs-number">60</span> - (<span class="hljs-title function_ invoke__">time</span>() - <span class="hljs-variable">$createdTime</span>) / <span class="hljs-number">60</span>) . <span class="hljs-string">&#x27; 分钟 后操作&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/github-copilot-04.png" alt="/img/github-copilot-04"></p><ul><li>小技巧：<ul><li>copilot 能读取你的上下文，但是 对于提示文案是无能为力的，如果你强制格式，就请把文案写出来</li><li>prompt 用 伪代码跟结构化的数据，输入少 响应反而更加精确</li></ul></li></ul><h4 id="错误修复"><a href="#错误修复" class="headerlink" title="错误修复"></a>错误修复</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$header</span> = [<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;other&quot;</span>];  <br><span class="hljs-variable">$mapData</span> = [<br>    [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;其他&quot;</span>],<br>    [<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;其他&quot;</span>],<br>];<br><span class="hljs-comment">// 导出到本地</span><br><span class="hljs-variable">$fileName</span> = <span class="hljs-string">&quot;list&quot;</span> . <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&quot;YmdHis&quot;</span>) . <span class="hljs-string">&quot;.csv&quot;</span>;  <br><span class="hljs-variable">$filePath</span> = <span class="hljs-title function_ invoke__">storage_path</span>(<span class="hljs-string">&quot;app/&quot;</span> . <span class="hljs-variable">$fileName</span>);<br><br><span class="hljs-comment">// ----------- 以下为 copilot 生成的代码 ------------</span><br><span class="hljs-variable">$fp</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-variable">$filePath</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-title function_ invoke__">fputcsv</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$header</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$mapData</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$item</span>) &#123;<br>    <span class="hljs-title function_ invoke__">fputcsv</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$item</span>);<br>&#125;<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$fp</span>);<br></code></pre></td></tr></table></figure><p>生成的代码，看起来没有什么问题，但是实际上是有问题的，比如导致导出的文件是乱码的，这时候我们需要让 copilot 帮我们修复这个问题，我们可以这样写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// $fp = fopen($filePath, &quot;w&quot;);</span><br><span class="hljs-comment">// fputcsv($fp, $header);  </span><br><span class="hljs-comment">// foreach ($exportData as $item) &#123;  </span><br><span class="hljs-comment">// fputcsv($fp, $item);  </span><br><span class="hljs-comment">// &#125;  </span><br><span class="hljs-comment">// fclose($fp); </span><br><br><span class="hljs-comment">// 以上注释代码会导致 中文乱码，</span><br><span class="hljs-comment">// 请使用下面的代码进行修复</span><br><span class="hljs-variable">$fp</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-variable">$filePath</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-number">0xEF</span>) . <span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-number">0xBB</span>) . <span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-number">0xBF</span>));<br><span class="hljs-title function_ invoke__">fputcsv</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$header</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$exportData</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$item</span>) &#123;<br>    <span class="hljs-title function_ invoke__">fputcsv</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$item</span>);<br>&#125;<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$fp</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/github-copilot-05.png" alt="/img/github-copilot-05"></p><ul><li>技巧：<ul><li>copilot 生成的代码，有会出现一些问题，你要去检验它的正确性并通过反馈的方式进行提问，它才能更好的响应</li></ul></li></ul><h4 id="写好具体的上下文"><a href="#写好具体的上下文" class="headerlink" title="写好具体的上下文"></a>写好具体的上下文</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 写一个函数 UserSig </span><br><span class="hljs-comment">// 输入参数: sdkappid, userId, expire, userbuf, key </span><br><span class="hljs-comment">// 输出签名: token </span><br><span class="hljs-comment">// 处理过程: 输入参数包装成 map , 然后对 map 倒序排列，最后进行 md5 计算 </span><br><span class="hljs-comment">// 每行代码都写上中文注释</span><br><br><span class="hljs-comment">// ---- 以下为 copilot 生成的代码 ----</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UserSig</span><span class="hljs-params">(sdkappid, userId, expire, userbuf, key <span class="hljs-type">string</span>)</span></span> (token <span class="hljs-type">string</span>) &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;sdkappid&quot;</span>: sdkappid,<br>        <span class="hljs-string">&quot;userId&quot;</span>:   userId,<br>        <span class="hljs-string">&quot;expire&quot;</span>:   expire,<br>        <span class="hljs-string">&quot;userbuf&quot;</span>:  userbuf,<br>        <span class="hljs-string">&quot;key&quot;</span>:      key,<br>    &#125;<br>    <span class="hljs-keyword">var</span> keys []<span class="hljs-type">string</span><br>    <span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>        keys = <span class="hljs-built_in">append</span>(keys, k)<br>    &#125;<br>    sort.Strings(keys)<br>    <span class="hljs-keyword">var</span> str <span class="hljs-type">string</span><br>    <span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> keys &#123;<br>        str += k + <span class="hljs-string">&quot;=&quot;</span> + m[k] + <span class="hljs-string">&quot;&amp;&quot;</span><br>    &#125;<br>    str += <span class="hljs-string">&quot;appkey=&quot;</span> + key<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%x&quot;</span>, md5.Sum([]<span class="hljs-type">byte</span>(str)))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以上就是一个很典型的 prompt <code>[输入，处理过程，输出]</code> 的例子, 因为 copilot 受到 code 的影响最深，所以你把代码的思路写出来，它负责生成代码</li></ul><h4 id="Google-的平替"><a href="#Google-的平替" class="headerlink" title="Google 的平替"></a>Google 的平替</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 提出问题，如何在 markdown 中引入上标与下标，并与参考链接一起使用？<br># --- 以下为 copilot 生成的代码 ---<br>&lt;sup&gt;&lt;a href=&quot;#fn1&quot; id=&quot;ref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;<br><br># 并给出解释<br># --- 以下为 copilot 生成的代码 ---<br>&lt;sup&gt;&lt;a href=&quot;#fn1&quot; id=&quot;ref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 这是一个上标，用于引用参考链接，如 [^1]<br></code></pre></td></tr></table></figure><p>以上部分提问之后，copilot 会给出一个答案，这样就避免了你去查阅文档的过程，保证了开发过程中的专注力。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="golang-中实践"><a href="#golang-中实践" class="headerlink" title="golang 中实践"></a>golang 中实践</h4><ul><li>在 golang 中写测试其实是一个比较简单的事情 配合 goland 的快捷键，写起来也是非常的方便，<br><img src="/img/github-copilot-06.png" alt="/img/github-copilot-06"></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang">tests := []<span class="hljs-keyword">struct</span> &#123;<br>name     <span class="hljs-type">string</span><br>fields   fields<br>args     args<br>wantResp *types.UserLoginReply<br>wantErr  <span class="hljs-type">bool</span><br>&#125;&#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add test cases.</span><br>       <span class="hljs-comment">//------ 以下代码为 copilot 生成的代码 ------//</span><br>&#123;<br>name: <span class="hljs-string">&quot;fail&quot;</span>,<br>fields: fields&#123;<br>Logger: logx.WithContext(context.Background()),<br>ctx:    context.Background(),<br>svcCtx: &amp;svc.ServiceContext&#123;&#125;,<br>&#125;,<br>args: args&#123;<br>req: &amp;types.UserLoginReq&#123;<br>Email:    <span class="hljs-string">&quot;&quot;</span>,<br>Password: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>&#125;,<br>wantResp: <span class="hljs-literal">nil</span>,<br>wantErr:  <span class="hljs-literal">true</span>,<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="php-中实践"><a href="#php-中实践" class="headerlink" title="php 中实践"></a>php 中实践</h4><ul><li><p>同样的，php 中，配合 phpstorm 的快捷键，写起来也是非常的方便<br><img src="/img/github-copilot-07.png" alt="/img/github-copilot-07"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCreate</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-variable">$response</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">json</span>(<br>            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>            <span class="hljs-attr">uri</span>: <span class="hljs-string">&#x27;/api/v1/users&#x27;</span>,<br>            <span class="hljs-attr">data</span>: [<br>                <span class="hljs-string">&#x27;email&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>,<br>                <span class="hljs-string">&#x27;password&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>,<br>            ],<br>            <span class="hljs-attr">headers</span>: [<span class="hljs-string">&#x27;Authorization&#x27;</span> =&gt; <span class="hljs-string">&#x27;Bearer &#x27;</span> . <span class="hljs-variable">$this</span>-&gt;token,],<br>     );<br><br>    <span class="hljs-variable">$response</span>-&gt;<span class="hljs-title function_ invoke__">assertStatus</span>(<span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在两种语言中，copilot 都能帮我们生成一些用例，但是这些用例都是比较简单的，所以我们需要自己去补充一些复杂的用例，比如边界值，异常值等等</p></li></ul><h3 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h3><h4 id="非结构化文档"><a href="#非结构化文档" class="headerlink" title="非结构化文档"></a>非结构化文档</h4><p>写文档，写blog，这部分其实是 copilot 的弱项，因为 copilot 本身是一个模型，它在生成代码的部分确实还不错，<br>但是它不知道你想要什么，而且它生成的文档受到上下文的影响很深，需要有逻辑性. 所以这部分需要我们自己去补充。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 写一个详细的大纲 关于介绍 github copilot 的使用</span><br>--- 以下为 copilot 生成的文档 ---<br><span class="hljs-section">## 介绍</span><br>github copilot 是一个基于机器学习的代码提示工具，它可以帮助开发者更快的编写代码<br><span class="hljs-section">## 安装</span><br>github copilot 是一个插件，需要安装到编辑器中<br><span class="hljs-section">## 使用</span><br>github copilot 会根据上下文，生成代码提示，然后你可以选择是否使用<br><span class="hljs-section">## 优点</span><br>github copilot 可以帮助开发者更快的编写代码<br><span class="hljs-section">## 缺点</span><br>github copilot 生成的代码有时候不太准确，需要开发者自己去检查<br><span class="hljs-section">## 总结</span><br>github copilot 是一个非常有意思的工具，它可以帮助开发者更快的编写代码<br></code></pre></td></tr></table></figure><h4 id="结构化文档"><a href="#结构化文档" class="headerlink" title="结构化文档"></a>结构化文档</h4><ul><li>不过如果是结构化的文档，比如 openapi ,那么 copilot 就能很好的生成文档了<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 写一个swagger文档 api/v1/users</span><br><span class="hljs-comment">#--- 以下为 copilot 生成的文档 ---</span><br><span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;api/v1/users&quot;</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;api/v1/users&quot;</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><br><span class="hljs-attr">servers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://xxx.com&quot;</span><br><span class="hljs-attr">paths:</span><br>    <span class="hljs-string">/api/v1/users:</span><br>        <span class="hljs-attr">post:</span><br>        <span class="hljs-attr">tags:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;api/v1/users&quot;</span><br>        <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;创建用户&quot;</span><br>        <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;创建用户&quot;</span><br>        <span class="hljs-attr">operationId:</span> <span class="hljs-string">&quot;CreateUser&quot;</span><br>        <span class="hljs-attr">requestBody:</span><br>            <span class="hljs-attr">content:</span><br>            <span class="hljs-attr">application/json:</span><br>                <span class="hljs-attr">schema:</span><br>                <span class="hljs-string">$ref:</span> <span class="hljs-string">&quot;#/components/schemas/CreateUserReq&quot;</span><br>        <span class="hljs-attr">responses:</span><br>            <span class="hljs-attr">&quot;200&quot;:</span><br>            <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;OK&quot;</span><br>            <span class="hljs-attr">content:</span><br>                <span class="hljs-attr">application/json:</span><br>                <span class="hljs-attr">schema:</span><br>                    <span class="hljs-string">$ref:</span> <span class="hljs-string">&quot;#/components/schemas/CreateUserReply&quot;</span><br><span class="hljs-attr">components:</span><br>    <span class="hljs-attr">schemas:</span><br>        <span class="hljs-attr">CreateUserReq:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;object&quot;</span><br>        <span class="hljs-attr">properties:</span><br>            <span class="hljs-attr">email:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;string&quot;</span><br>            <span class="hljs-attr">password:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;string&quot;</span><br>        <span class="hljs-attr">CreateUserReply:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;object&quot;</span><br>        <span class="hljs-attr">properties:</span><br>            <span class="hljs-attr">id:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;string&quot;</span><br>            <span class="hljs-attr">email:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;string&quot;</span><br>            <span class="hljs-attr">password:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;string&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是我在使用 copilot 快一年的一些感受，copilot 在 写注释，函数，单元测试，生成文档，帮助优化代码，处理错误异常等等方面都有一定的帮助，除了价格有一点点偏贵，在偏向于业务开发的场景是非常好用。  </p><p>本篇 blog 的内容部分也是 copilot 生成，在未来，类似的专业工具会越来越多，我们需要做的就是学会如何使用它们，你要面对的竞争对手不仅仅是人类，还有机器，学会如何与机器协作，而不是与机器竞争。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://copilot.github.com/">github copilot</a></li><li><a href="https://github.blog/2023-06-20-how-to-write-better-prompts-for-github-copilot/">2023-06-20-how-to-write-better-prompts-for-github-copilot</a></li><li><a href="https://github.blog/2023-05-17-how-github-copilot-is-getting-better-at-understanding-your-code">2023-05-17-how-github-copilot-is-getting-better-at-understanding-your-code</a></li><li><a href="https://mp.weixin.qq.com/s/dxowVu3BIbNG70C8Yn-D_A#:~:text=Copilot%20%E5%9B%A2%E9%98%9F%E6%94%B6%E9%9B%86%E4%BA%86%E4%B8%80%E5%A4%A7%E5%A0%86%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E6%84%8F%E8%AF%86%E5%88%B0%E9%80%9F%E5%BA%A6%E5%9C%A8%E4%BB%BB%E4%BD%95%E7%BE%A4%E4%BD%93%E4%B8%AD%E9%83%BD%E6%98%AF%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E6%A0%87%E3%80%82%E2%80%9C%E6%88%91%E4%BB%AC%E5%8F%91%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%AF%8F%E5%A2%9E%E5%8A%A0%2010%20%E6%AF%AB%E7%A7%92%EF%BC%8C%E5%B0%B1%E4%BC%9A%E6%9C%89%201%25%20%E7%9A%84%E7%94%A8%E6%88%B7%E6%94%BE%E5%BC%83%E8%BF%99%E9%A1%B9%E5%8A%9F%E8%83%BD%E3%80%82%E5%8F%A6%E5%A4%96%E5%9C%A8%E6%96%B0%E5%8A%9F%E8%83%BD%E5%85%AC%E5%BC%80%E5%8F%91%E5%B8%83%E7%9A%84%E5%A4%B4%E5%87%A0%E4%B8%AA%E6%9C%88%EF%BC%8C%E5%8D%B0%E5%BA%A6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%88%90%E7%8E%87%E6%98%AF%E6%9C%80%E4%BD%8E%E7%9A%84%E2%80%94%E2%80%94%E4%B8%8D%E7%A1%AE%E5%AE%9A%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%86%E5%AE%8C%E6%88%90%E7%8E%87%E7%A1%AE%E5%AE%9E%E6%98%8E%E6%98%BE%E4%BD%8E%E4%BA%8E%E6%AC%A7%E6%B4%B2%E3%80%82%E2%80%9D">GitHub Copilot：做出一个划时代的产品，只需要 6 个人</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>github-copilot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go-zero单体化改造（一）gorm的接入</title>
    <link href="/posts/500f78a8/"/>
    <url>/posts/500f78a8/</url>
    
    <content type="html"><![CDATA[<h2 id="在-go-zero-中-接入与使用-gorm-只需要三步。"><a href="#在-go-zero-中-接入与使用-gorm-只需要三步。" class="headerlink" title="在 go-zero 中 接入与使用 gorm 只需要三步。"></a>在 go-zero 中 接入与使用 gorm 只需要三步。</h2><p>大多数时候，应用都是单体架构，go-zero 的好处就是，可以快速的搭建一个单体应用，但是随着业务的发展，单体应用的压力也会越来越大，这时候就需要对单体应用进行拆分，拆分的方式有很多，比如拆分成微服务，多个单体应用，多个模块…</p><p>而 go-zero 提供了方案，可以在业务小的时候单体，规模变大时候，很方便的拆分成微服务，这就是 go-zero 的独特魅力。</p><p>对于 go-zero 中，我最难受的点就在db 这部分，写过 laravel 的人，再去写 go-zero 的 db 部分，会觉得很难受，因为单体应用也很难达到，数据库承压的极限，所以我最终选择用 gorm 这种 orm 框架，一个是快速开发，第二个是我的开源项目会用到 pgsql , 用 gorm 可以抹平 mysql 与 pgsql 的语法差异。</p><p>之前已经在项目中用 MySQL 实现了 基础的业务逻辑，所以目前主要就是对 db 部分进行替换。</p><h3 id="第一步-service-demo-api-internal-svc-servicecontext-go-修改-服务上下文"><a href="#第一步-service-demo-api-internal-svc-servicecontext-go-修改-服务上下文" class="headerlink" title="第一步 service/demo/api/internal/svc/servicecontext.go 修改 服务上下文"></a>第一步 <code>service/demo/api/internal/svc/servicecontext.go</code> 修改 服务上下文</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> svc<br><br><span class="hljs-keyword">import</span><span class="hljs-string">&quot;gorm.io/driver/postgres&quot;</span><br><span class="hljs-keyword">import</span><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br><br><span class="hljs-keyword">type</span> ServiceContext <span class="hljs-keyword">struct</span> &#123;<br>Config    config.Config<br>DbEngin   *gorm.DB<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServiceContext</span><span class="hljs-params">(c config.Config)</span></span> *ServiceContext &#123;<br><span class="hljs-comment">//启动Gorm支持</span><br>db, err := gorm.Open(postgres.New(postgres.Config&#123;<br>DSN:                  c.PGSql.DataSource,<br>PreferSimpleProtocol: <span class="hljs-literal">true</span>, <span class="hljs-comment">// disables implicit prepared statement usage</span><br>&#125;), &amp;gorm.Config&#123;&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;ServiceContext&#123;<br>Config:    c,<br>DbEngin:   db,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以在服务上下文中，添加 gorm 的支持，然后在 <code>service/demo/api/internal/config/config.go</code> 中添加 pgsql 的配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br><br>...<br><br>PGSql <span class="hljs-keyword">struct</span> &#123;<br>DataSource <span class="hljs-type">string</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改造就完成了，是的就是这么简单，但是现在的易用性很差，各种方法也都需要自己去封装。用 gorm 肯定会定义 model, 我这个时候，发现了一个新的工具</p><h3 id="第二步-orm-的易用性工具"><a href="#第二步-orm-的易用性工具" class="headerlink" title="第二步 orm 的易用性工具"></a>第二步 orm 的易用性工具</h3><ul><li><code>gentool</code> 用于生成 gorm 的 model 与对应的实用方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go install gorm.io/gen/tools/gentool@latest<br></code></pre></td></tr></table></figure><p>比如 在项目根目录下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gentool -db &quot;postgres&quot; -dsn &quot;host=localhost user=root password=123456 dbname=demo port=18886 sslmode=disable TimeZone=Asia/Shanghai&quot; -outPath &quot;./service/demo/dao&quot;<br></code></pre></td></tr></table></figure><p><img src="/img/go-zero01.png" alt="/img/go-zero01.png"></p><p>可以看到连接数据库后，自动生成对应的结构体，基础的 curd 方法都实现了，很久没有用 gorm ，再次使用，给我的感受是，emmm 还挺不错的~ 易用性加强了很多</p><p>然后再次修改 <code>service/demo/api/internal/svc/servicecontext.go</code> 服务上下文</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> ServiceContext <span class="hljs-keyword">struct</span> &#123;<br>...<br>UserModel *dao.Query<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;ServiceContext&#123;<br>    Config:    c,<br>    UserModel: dao.Use(db),<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="业务使用"><a href="#业务使用" class="headerlink" title="业务使用"></a>业务使用</h3><p>最后就就可以在 <code>service/demo/api/internal/logic</code> 中使用了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 用户是否存在</span><br>table := l.svcCtx.UserModel.User<br><br>user, selectErr := table.WithContext(l.ctx).Where(table.ID.Eq(req.ID)).First()<br><br><span class="hljs-keyword">if</span> !errors.Is(selectErr, gorm.ErrRecordNotFound) &amp;&amp; err != <span class="hljs-literal">nil</span> &#123;<br>    err = errors.Wrapf(xerr.NewErrCodeMsg(xerr.DBError, <span class="hljs-string">&quot;查询用户失败&quot;</span>), <span class="hljs-string">&quot;查询用户失败 %v&quot;</span>, err)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>一个简单的逻辑，但是已经可以看到，使用 gorm 后，代码的可读性，易用性都提高了很多。</p><p>比较坑的是 <code>gorm.ErrRecordNotFound</code> 这个 error , 一开始我以为是 db 的错误，但是后来发现，这个错误是 gorm 的一个特性，如果查询不到数据，会返回这个错误，数据会给一个 null。</p><p>以上就是我在 go-zero 中接入 gorm 的过程，如果你也在用 go-zero ，可以参考一下，如果你有更好的方法，欢迎留言讨论。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>go-zero</tag>
      
      <tag>gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过ChatGPT构建微信ai助理(一)</title>
    <link href="/posts/30156e50/"/>
    <url>/posts/30156e50/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景和功能"><a href="#0x01-背景和功能" class="headerlink" title="0x01 背景和功能"></a>0x01 背景和功能</h2><p>ChatGPT 相信大家最近都玩的比较多了 , 但是其只提供网页端服务与国服锁区的限制，导致我不是特别专门去开一个tab，去挂这个服务，我就在想能否做一个微信机器人，让我在微信里面，就可以使用 ChatGPT ?  爆肝一整天，总算是搞定了，基于企业微信应用的 ChatGPT 聊天机器人~</p><p><img src="/img/chatgpt-wechat-01.png" alt="/img/chatgpt-wechat-01.png"></p><h3 id="ChatGPT-是什么？"><a href="#ChatGPT-是什么？" class="headerlink" title="ChatGPT  是什么？"></a>ChatGPT  是什么？</h3><p>ChatGPT 是一种由 OpenAI 训练的大型语言模型，可以让人们在多种语言下与设备进行交流，可以被用于回答人们提出的问题，分析文本，完成自然语言处理任务，如情绪分析、机器翻译等，还可以自动生成文本。</p><h3 id="企业微信如何与微信进行联动？"><a href="#企业微信如何与微信进行联动？" class="headerlink" title="企业微信如何与微信进行联动？"></a>企业微信如何与微信进行联动？</h3><ul><li>如何给微信发消息？<br>一般情况下，通过微信第三方客户端，或是网页扫码来绕过微信客户端的行为，很快就会收到，警告⚠ 或者被永久封禁，对于个人大号，来说风险太大了。<br>一般可以通过测试公众号模板消息来进行提示，但是要做一个双向对话的机器人还是不够。<br>这个时候我发现了企业微信的内部应用的消息是跟微信互通的，通过开发文档发现思路上是可行的，而且企业微信也是允许个人注册但不认证的~</li></ul><h2 id="0x02-方案与踩坑"><a href="#0x02-方案与踩坑" class="headerlink" title="0x02 方案与踩坑"></a>0x02 方案与踩坑</h2><p>使用GPT-3和企业微信来构建一个个人ai微信助理最终实现的方案是<br><img src="/img/chatgpt-wechat-02.png" alt="/img/chatgpt-wechat-02.png"></p><p>本来就是同步调用API的事情为什么架构到最后变得怎么复杂？</p><h3 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h3><p>企业微信要求回调请求地址必须为域名，但在国内备案实在是给自己找事，只能通过其他方式来中转。</p><h3 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h3><p>我一开始选择了一家香港的 serviceless 服务商 aircode，说句实话，做的很简洁也很舒适，很符合小而美的应用，但是我写了半天，发现它家的服务，给我把微信回调的xml 给吞了，我收不到用户消息，只能转战 阿里&#x2F;腾讯云这种 函数云服务来实现，所以就多了 阿里云fc中间层用来给企业微信消息做中转。</p><h3 id="坑三"><a href="#坑三" class="headerlink" title="坑三"></a>坑三</h3><p>阿里云的 fc node.js runtime 同步函数服务超时时间为 5 - 6 秒，我 await 等待openai服务给响应的过程中，整个服务还是会被杀掉，实在无奈只能同步转异步，在自己的服务器上起了一个 golang 的服务，接受微信消息，异步等待openai响应后，再调用 企业微信服务给微信推送消息。</p><h2 id="0x03-未来"><a href="#0x03-未来" class="headerlink" title="0x03 未来"></a>0x03 未来</h2><p>经过一些测试，我发现这个机器人在很多方面都有提高的空间，毕竟也才刚刚发布3个多月，在使用上 prompt 很重要，基于一些限制条件，同一机器人可以承担各种各样的功能。能够模拟各种角色，且差的不是很离谱，这大概就是这个机器人用途广泛的原因。</p><p>我之后会把详细的配置文档跟代码放到  <code>https://github.com/whyiyhw/chatgpt-wechat</code> 上，各位感兴趣的，我也可以拉进 企业微信，自己体验，代码开源的也可以自己搭建试试？</p><p>目前我使用的ai 辅助软件有 <code>openai ChatGPT</code> 、  <code>github copilot</code>、  <code>stable-diffusion-webui</code> ai也在渐进式的进入我们的生活，君子不器</p><p>（以上文章大纲与部分内容出自 ChatGPT ，你们觉得哪些是 它写的？）</p>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成式AI-图像类-stable-diffusion-webui（概述）</title>
    <link href="/posts/b93583de/"/>
    <url>/posts/b93583de/</url>
    
    <content type="html"><![CDATA[<p>最近发现B站上的这个话题很火，就去找了下对应的库<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">https://github.com/AUTOMATIC1111/stable-diffusion-webui</a> 发现好家伙，2022-8月 开源，两个月时间斩获了13000多颗⭐，让我们看看这个库到底做了什么。</p><h2 id="windows-下的安装"><a href="#windows-下的安装" class="headerlink" title="windows 下的安装"></a>windows 下的安装</h2><ol><li><p>安装 <code>Python &gt; 3.10.6</code> 安装  <code>git</code></p><ol><li>国内用户pip 没走代理的，在 <code>C:\Users\xxx\pip</code> 新建 pip 目录，新增php.ini 配置全局的代理<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[global]<br>timeout =6000<br>index-url = https://mirrors.aliyun.com/pypi/simple/<br>extra-index-url=https://pypi.tuna.tsinghua.edu.cn/simple/<br>https://pypi.mirrors.ustc.edu.cn/simple/<br>https://pypi.douban.com/simple<br>[install]<br>trusted-host = mirrors.aliyun.com<br>https://pypi.tuna.tsinghua.edu.cn/simple/<br>https://pypi.mirrors.ustc.edu.cn/simple/<br>https://pypi.douban.com/simple<br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</code></p></li><li><p>下载训练好的官方模型 <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Dependencies">https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Dependencies</a></p></li></ol><p>现在你有了 <code>sd-v1-x.ckpt</code> 这个 tensorflow 生成的模型 , 还有运行这个模型所需的软件，把模型改名为 <code>model.ckpt</code>  放入 <code>stable-diffusion-webui\models\Stable-diffusion</code><br>目录下，windows 打开 powershell 运行  <code>webui-user.bat</code><br>第一次加载会比较慢，因为要下载很多的依赖 , 看到下面这个的时候就说明安装完成了</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Running on local URL:  http://127.0.0.1:7860<br></code></pre></td></tr></table></figure><p>进入 <code>127.0.0.1:7860</code> 最主要的两个功能 <code>txt2img</code> <code>img2img</code> 我们上手测试下生成的效果</p><p><img src="/img/16.png" alt="16.png"></p><p>简单测试了几个词后，我的感觉就是这个算法对初学者不太友好，我评分在(30-70)左右，而且会出现奇怪的图像，那他怎么在B站爆火的呢？ </p><p>我注意到了另一个关键词 <code>NOVELAI</code> , 在维基百科中的解释为<code>NovelAI是Anlatan的深度学习人工智能服务，其下有辅助故事写作以及文字作图像生成，采取订阅制的云端运算服务</code><br>这家公司对于 日漫风格的 文字生成图片做的很不错。前几天一个 叫 novelaileak 的种子在疯传，泄露出来的这个模型，配合上这个web-ui, 实现了 普通用户用自己电脑就是生成 8分 动漫图的效果，配合上 img2img 对 网络热门人员的漫画化改造，热度不错。开源软件 + 模型 + 电脑，产生的生产力对中低端画师有了明显的压制，所以这个话题不断升温。<br>我找到了 这个<a href="%5Bmagnet:?xt=urn:btih:5bde442da86265b670a3e5ea3163afad2c6f8ecc%5D(magnet:?xt=urn:btih:5bde442da86265b670a3e5ea3163afad2c6f8ecc)">种子链接</a> ,以及对应的<a href="https://rentry.org/nai-speedrun">安装指导</a> 种子过于庞大 完整模型 50G，实际上我们只用 到 5G 左右的模型，各位自行下载，把模型改名后移入 到 <code>models\Stable-diffusion</code> 无需重启，直接在左上方刷新切换模型就OK</p><p>随便找个模板看看效果<br><code>&#123;photorealistic&#125;, 1 girl, gothic maid dress,&#123;blue Hair&#125;,&#123;pink Hair accessories&#125;,Sky, grassland,red eyes, depth of field,cinematic angle ,backlighting,young girl,</code></p><p><img src="/img/post/04.png" alt="/img/post/04.png"></p><p>可以看出来，对比原始模型 <code>animefull-final</code> 这个模型在生成动漫人物方面的效果 可以达到 70-80 的水准，不加入特定的作画风格，商用问题不大，这就触动了B站很多画师的利益, 自然就有了热度。</p><h3 id="在程序员职业角度来如何看待这个软件？"><a href="#在程序员职业角度来如何看待这个软件？" class="headerlink" title="在程序员职业角度来如何看待这个软件？"></a>在程序员职业角度来如何看待这个软件？</h3><p>我觉得是生成式AI比我想象中会更快商业化落地</p><ul><li>实现了 UI展示软件与模型的分离，分工协作是大规模工业化的第一步</li><li>模型对于机器与硬件的要求，下降到了民用机器也能很好去实现的地步，我这台 I5-8代-16G-1060 的机器虽然生成一张普通的图需要10秒左右，但也能用了</li><li>熟悉了软件的机制与对应的关键词之后，大部分场景都是可以做到自动生成<br>软件可以改进的点，加入软件版本机制，升级需要下载最新的版本然后覆盖很容易出问题，稳定后多一些用户使用文档</li></ul><p>img2img 先不做演示了，copy（学习）绘画大佬的风格，生成自己风格这部分，机器性能太差也不做说明了</p><p>这里只是做一个简单介绍，后续会把详细的使用说明，跟更好的安装方式完整的写出来</p><p>不管怎么说，我的封面以后不用愁了~</p>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>stable-diffusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang-web(一) 从http开始</title>
    <link href="/posts/6b5ac4cc/"/>
    <url>/posts/6b5ac4cc/</url>
    
    <content type="html"><![CDATA[<h2 id="从-http-包开始"><a href="#从-http-包开始" class="headerlink" title="从 http 包开始"></a>从 <code>http</code> 包开始</h2><p>我们都知道在 golang 中构建一个 http 服务很容易</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  <br>   _, _ = w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))  <br>&#125;)<br>_ = http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>有过现代 web api 开发的经验的人都能从中发现对应轻量级框架 的影子(如 express.js、 php slim)。<br>对应的概念有 <strong>路由</strong>、<strong>处理函数</strong>、<strong>请求对象&#x2F;结构体</strong>、<strong>响应对象&#x2F;结构体</strong></p><p>因为 <code>http1.1 - 2</code> 是通过 tcp 实现的，<br>上面这个的代码隐藏了一些细节，我们来通过源码闭环整个 注册路由，监听与请求过程</p><h3 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h3><ol><li><p>用了一个 DefaultServeMux 结构， 来处理路由与处理函数的绑定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/server.go:2488</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleFunc</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>, handler <span class="hljs-keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;  <br>   DefaultServeMux.HandleFunc(pattern, handler)  <br>&#125;<br><br><span class="hljs-comment">// net/http/server.go:2472</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="hljs-type">string</span>, handler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span>) &#123;  <br>   <span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;  <br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;http: nil handler&quot;</span>)  <br>   &#125;   <br>   mux.Handle(pattern, HandlerFunc(handler))  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>里面的实现的比较简陋, 就是一个路由与 handler 函数 对应的 大 map 。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/server.go:2429</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span></span> Handle(pattern <span class="hljs-type">string</span>, handler Handler) &#123;  <br>   mux.mu.Lock()  <br>   <span class="hljs-keyword">defer</span> mux.mu.Unlock()  <br>  <br>   <span class="hljs-keyword">if</span> pattern == <span class="hljs-string">&quot;&quot;</span> &#123;  <br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;http: invalid pattern&quot;</span>)  <br>   &#125;   <br>   <span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;  <br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;http: nil handler&quot;</span>)  <br>   &#125;   <br>   <span class="hljs-keyword">if</span> _, exist := mux.m[pattern]; exist &#123;  <br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;http: multiple registrations for &quot;</span> + pattern)  <br>   &#125;  <br>   <span class="hljs-keyword">if</span> mux.m == <span class="hljs-literal">nil</span> &#123;  <br>      mux.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]muxEntry)  <br>   &#125;   <br>   e := muxEntry&#123;h: handler, pattern: pattern&#125;  <br>   mux.m[pattern] = e  <br>   <span class="hljs-keyword">if</span> pattern[<span class="hljs-built_in">len</span>(pattern)<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;/&#x27;</span> &#123;  <br>      mux.es = appendSorted(mux.es, e)  <br>   &#125;  <br>   <span class="hljs-keyword">if</span> pattern[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span> &#123;  <br>      mux.hosts = <span class="hljs-literal">true</span>  <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>注册完之后，就看看 监听与处理部分</p><h3 id="事件监听与任务分派"><a href="#事件监听与任务分派" class="headerlink" title="事件监听与任务分派"></a>事件监听与任务分派</h3><ol><li>先是打开了一个 tcp socket 并调用了 Serve 方法去监听</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/server.go:3182</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-type">string</span>, handler Handler)</span></span> <span class="hljs-type">error</span> &#123;  <br>   server := &amp;Server&#123;Addr: addr, Handler: handler&#125;  <br>   <span class="hljs-keyword">return</span> server.ListenAndServe()  <br>&#125;<br><br><span class="hljs-comment">// net/http/server.go:2918</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> ListenAndServe() <span class="hljs-type">error</span> &#123;  <br>   <span class="hljs-keyword">if</span> srv.shuttingDown() &#123;  <br>      <span class="hljs-keyword">return</span> ErrServerClosed  <br>   &#125;  <br>   addr := srv.Addr  <br>   <span class="hljs-keyword">if</span> addr == <span class="hljs-string">&quot;&quot;</span> &#123;  <br>      addr = <span class="hljs-string">&quot;:http&quot;</span>  <br>   &#125;  <br>   ln, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, addr)  <br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>      <span class="hljs-keyword">return</span> err  <br>   &#125;<br>   <span class="hljs-keyword">return</span> srv.Serve(ln)  <br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>开启监听 ，并用协程去处理真正的逻辑<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/server.go:2971</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;  <br><span class="hljs-comment">// ......</span><br>   ctx := context.WithValue(baseCtx, ServerContextKey, srv)<br>   <span class="hljs-keyword">for</span> &#123;  <br>   <span class="hljs-comment">// 等待请求 </span><br>      rw, err := l.Accept()  <br>   <span class="hljs-comment">// ...省略</span><br>      connCtx := ctx  <br>   <span class="hljs-comment">// ...省略 </span><br>      <span class="hljs-keyword">go</span> c.serve(connCtx)  <br>   &#125;&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="路由匹配与逻辑处理"><a href="#路由匹配与逻辑处理" class="headerlink" title="路由匹配与逻辑处理"></a>路由匹配与逻辑处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> serve(ctx context.Context) &#123;  <br>   <span class="hljs-comment">// ... net/http/server.go:1929   </span><br>   serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)  <br>   <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最重点</strong>就是这一句，<code>serverHandler&#123;c.server&#125;</code> 调用 <code>ServeHTTP</code> 方法 ，<code>serverHandler&#123;c.server&#125;</code> 的类型在这里实际上是我们注入 <code>DefaultServeMux ServeMux</code> 调用了自己的 <code>ServeHTTP()</code>  其它框架无法就是对于这个 <code>Handler</code> 的实现与替换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/server:2415</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;  <br>   <span class="hljs-keyword">if</span> r.RequestURI == <span class="hljs-string">&quot;*&quot;</span> &#123;  <br>      <span class="hljs-keyword">if</span> r.ProtoAtLeast(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &#123;  <br>         w.Header().Set(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;close&quot;</span>)  <br>      &#125;      w.WriteHeader(StatusBadRequest)  <br>      <span class="hljs-keyword">return</span>  <br>   &#125;  <br>   h, _ := mux.Handler(r)  <br>   <span class="hljs-comment">// h 就是 Handler 的一个实例</span><br>   h.ServeHTTP(w, r)  <br>&#125;<br><br> <br><span class="hljs-comment">// net/http/server:2396</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span></span> handler(host, path <span class="hljs-type">string</span>) (h Handler, pattern <span class="hljs-type">string</span>) &#123;  <br>   mux.mu.RLock()  <br>   <span class="hljs-keyword">defer</span> mux.mu.RUnlock()  <br>  <br>   <span class="hljs-comment">// Host-specific pattern takes precedence over generic ones  </span><br>   <span class="hljs-keyword">if</span> mux.hosts &#123;  <br>      h, pattern = mux.match(host + path)  <br>   &#125;   <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;  <br>      h, pattern = mux.match(path)  <br>   &#125;   <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;  <br>      h, pattern = NotFoundHandler(), <span class="hljs-string">&quot;&quot;</span>  <br>   &#125;  <br>   <span class="hljs-keyword">return</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>去 map 里面匹配到了 注入的 HandlerFunc 最终调用了 HandlerFunc 的 ServeHttp ,执行了我们最开始的逻辑函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//server:2046</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;  <br>   f(w, r)  <br>&#125;<br></code></pre></td></tr></table></figure><p>整体的流程下来就是<br><strong>路由注册，开启监听 ，监听到请求，开协程去匹配路由，并根据注册的处理函数来处理请求</strong><br>官方包已经给了一整套完整的实现，有改进空间的点在于 路由注册&#x2F;匹配这一块，再补上 log config 等一些基础包，每个人都可以实现自己的框架</p><h3 id="自定义-Handler"><a href="#自定义-Handler" class="headerlink" title="自定义 Handler"></a>自定义 Handler</h3><p>上面的例子中，我们使用了默认的 <code>http.DefaultServeMux </code>  来实现 <code>handle</code><br><code>Handler Handler // handler to invoke, http.DefaultServeMux if nil</code>  </p><p> <code>handle</code> 最主要就做了两件事<br>第一是定义了 map 来存储路由与处理逻辑函数<br>第二个就是实现了 <code>Handler interface </code> 定义了一个 <code>ServeHTTP(ResponseWriter, *Request)</code> 来处理 传入的 http  请求。</p><p>这两件事，不依赖官方，我们自己去做可行？很显然可行，到这里我们已经往自定义框架的路上走了一大步。</p><h4 id="Pong-http-服务"><a href="#Pong-http-服务" class="headerlink" title="Pong http 服务"></a>Pong http 服务</h4><p>一起来实现一个 pong http 服务，不管你请求什么 我都会响应 pong </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-keyword">type</span> pongHandler <span class="hljs-keyword">struct</span> &#123;  <br>   content <span class="hljs-type">string</span>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pH *pongHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;  <br>   _, _ = w.Write([]<span class="hljs-type">byte</span>(pH.content))  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   _ = http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, &amp;pongHandler&#123;<span class="hljs-string">&quot;pong&quot;</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就得到了一个不管你怎么访问我都是响应 pong 的 http 服务， 而没有使用  <code>ServeMux</code>  ，接下来 我们来实现简易路由的存储与匹配</p><h4 id="路由的存储与匹配"><a href="#路由的存储与匹配" class="headerlink" title="路由的存储与匹配"></a>路由的存储与匹配</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br>   <span class="hljs-string">&quot;net/http&quot;</span>  <br>)  <br>  <br><span class="hljs-keyword">type</span> pingHandler <span class="hljs-keyword">struct</span> &#123;  <br>   content <span class="hljs-type">string</span>  <br>   trees   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node  <br>&#125;  <br>  <br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;  <br>   method  <span class="hljs-type">string</span>  <br>   handler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pH *pingHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;  <br>  <br>   <span class="hljs-keyword">if</span> n, ok := pH.trees[r.Method+r.RequestURI]; !ok &#123;  <br>      _, _ = w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;404 Not Found&quot;</span>))  <br>      <span class="hljs-keyword">return</span>  <br>   &#125; <span class="hljs-keyword">else</span> &#123;  <br>      <span class="hljs-keyword">if</span> n.method != r.Method &#123;  <br>         _, _ = w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Method Not Match&quot;</span>))  <br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>         n.handler(w, r)  <br>      &#125;   <br>   &#125;<br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pH *pingHandler)</span></span> Get(route <span class="hljs-type">string</span>, logic <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span>) &#123;  <br>   n := node&#123;http.MethodGet, logic&#125;  <br>   pH.trees[http.MethodGet+route] = &amp;n  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pH *pingHandler)</span></span> Post(route <span class="hljs-type">string</span>, logic <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span>) &#123;  <br>   n := node&#123;http.MethodPost, logic&#125;  <br>   pH.trees[http.MethodPost+route] = &amp;n  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>  <br>   r := pingHandler&#123;<span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node)&#125;  <br>  <br>   r.Get(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  <br>      _, _ = w.Write([]<span class="hljs-type">byte</span>(r.RequestURI + <span class="hljs-string">&quot;:&quot;</span> + r.Method))  <br>   &#125;)  <br>   r.Post(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  <br>      _, _ = w.Write([]<span class="hljs-type">byte</span>(r.RequestURI + <span class="hljs-string">&quot;:&quot;</span> + r.Method))  <br>   &#125;)  <br>   _ = http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, &amp;r)<br>&#125;<br></code></pre></td></tr></table></figure><p>几行代码就生成了一个简易的路由存储与匹配机制，对路由存储与匹配感兴趣的小伙伴可以参考<br><a href="https://github.com/gorilla/mux">github.com&#x2F;gorilla&#x2F;mux</a>  功能更丰富、 <a href="https://github.com/julienschmidt/httprouter">github.com&#x2F;julienschmidt&#x2F;httprouter</a>  性能更好，对应的知识点 有 [[前缀树trie算法]]  ，基于 hash 的路由匹配…  此处就不再深入了，接下来的一章，我们去看看官方推荐的 gin 框架相关功能是如何实现的？</p><h3 id="其它细节点待补充"><a href="#其它细节点待补充" class="headerlink" title="其它细节点待补充"></a>其它细节点待补充</h3><ul><li>TODO <ul><li>socket 细节</li><li>路由匹配算法</li><li>服务抽象思维与接口实现重写</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang-web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang-web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>laravel-sanctum优化</title>
    <link href="/posts/ea31ae71/"/>
    <url>/posts/ea31ae71/</url>
    
    <content type="html"><![CDATA[<h2 id="sanctum是官方新推出的认证组件"><a href="#sanctum是官方新推出的认证组件" class="headerlink" title="sanctum是官方新推出的认证组件"></a>sanctum是官方新推出的认证组件</h2><h3 id="laravel-sanctum"><a href="#laravel-sanctum" class="headerlink" title="laravel&#x2F;sanctum"></a>laravel&#x2F;sanctum</h3><p>文档上表示，这个轻量化的 token 面向两类认证场景而生，思路起源为 Github 的 personal token 。</p><p>一是 为 api 令牌，发放长期 token ，认证时 在 header 头部传入。二为 基于 laravel api 的 spa 单页，将信息存入 cookie 。</p><p><strong>对比下 jwt 与 sanctum 或者叫自定义 token 的 方式</strong></p><table><thead><tr><th>认证方式</th><th>不需要数据库支持</th><th>多租户支持</th><th>便于管理</th><th>高性能</th></tr></thead><tbody><tr><td>jwt</td><td>✔️</td><td>✔️</td><td>❌</td><td>✔️</td></tr><tr><td>sanctum</td><td>❌</td><td>✔️</td><td>✔️</td><td>❌</td></tr></tbody></table><p>总之对于体量不大的应用内部使用 sanctum 没什么问题，要是做对外开放相关的业务还是建议 jwt </p><h4 id="token-加解密实现"><a href="#token-加解密实现" class="headerlink" title="token 加解密实现"></a>token 加解密实现</h4><p>很想吐槽的就是这个 token 的生成方式，如<br><code>Bearer 195|JswKUO3O9Jsmh9ks5fNQoS1Qlk6Ub6KvJ137g00q</code><br>为什么这么设计，其实看头部就知道，用主键ID开头来加速 查询，但是 缺点也很明显，一个是对外暴露了内部信息的主键，第二点是 默认使用 bigint为主键导致的 token 长度不固定。</p><p>看下内部的加解密实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 加密 vendor/laravel/sanctum/src/HasApiTokens.php </span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createToken</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$name</span>, <span class="hljs-keyword">array</span> <span class="hljs-variable">$abilities</span> = [<span class="hljs-string">&#x27;*&#x27;</span>]</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-variable">$token</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">tokens</span>()-&gt;<span class="hljs-title function_ invoke__">create</span>([  <br>        <span class="hljs-string">&#x27;name&#x27;</span> =&gt; <span class="hljs-variable">$name</span>,  <br>        <span class="hljs-string">&#x27;token&#x27;</span> =&gt; <span class="hljs-title function_ invoke__">hash</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>, <span class="hljs-variable">$plainTextToken</span> = <span class="hljs-title class_">Str</span>::<span class="hljs-title function_ invoke__">random</span>(<span class="hljs-number">40</span>)),  <br>        <span class="hljs-string">&#x27;abilities&#x27;</span> =&gt; <span class="hljs-variable">$abilities</span>,  <br>    ]);  <br>    <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewAccessToken</span>(<span class="hljs-variable">$token</span>, <span class="hljs-variable">$token</span>-&gt;<span class="hljs-title function_ invoke__">getKey</span>().<span class="hljs-string">&#x27;|&#x27;</span>.<span class="hljs-variable">$plainTextToken</span>);  <br>&#125;<br><br><span class="hljs-comment"># 解密 vendor/laravel/sanctum/src/PersonalAccessToken.php</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findToken</span>(<span class="hljs-params"><span class="hljs-variable">$token</span></span>)  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$token</span>, <span class="hljs-string">&#x27;|&#x27;</span>) === <span class="hljs-literal">false</span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static</span>::<span class="hljs-title function_ invoke__">where</span>(<span class="hljs-string">&#x27;token&#x27;</span>, <span class="hljs-title function_ invoke__">hash</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>, <span class="hljs-variable">$token</span>))-&gt;<span class="hljs-title function_ invoke__">first</span>();  <br>    &#125;  <br>    [<span class="hljs-variable">$id</span>, <span class="hljs-variable">$token</span>] = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-variable">$token</span>, <span class="hljs-number">2</span>);  <br>  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$instance</span> = <span class="hljs-built_in">static</span>::<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-variable">$id</span>)) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">hash_equals</span>(<span class="hljs-variable">$instance</span>-&gt;token, <span class="hljs-title function_ invoke__">hash</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>, <span class="hljs-variable">$token</span>)) ? <span class="hljs-variable">$instance</span> : <span class="hljs-literal">null</span>;  <br>    &#125;&#125;<br><br></code></pre></td></tr></table></figure><p>其核心 代码 也就是<br><code>hash(&#39;sha256&#39;, $plainTextToken = Str::random(40))</code> 与  <code>hash_equals</code></p><p>数据库存的 token 是 随机字符串后 hash 出来的 64位字符串，对外暴露的为 <code>主键ID + | + 40位随机字符串</code></p><h4 id="可选优化思路"><a href="#可选优化思路" class="headerlink" title="可选优化思路"></a>可选优化思路</h4><h5 id="token-多端通用"><a href="#token-多端通用" class="headerlink" title="token 多端通用"></a>token 多端通用</h5><p>根据其生成方法 <code>createToken(string $name, array $abilities = [&#39;*&#39;])</code> 可知，数据库字段 <code>name</code> 与 <code>abilities</code> 都可以实现类似于多租户&#x2F;多端 的功能，特别是 <code>abilities</code> 这个字段，可以做到更加精细的权限控制<br>比如 生成的时候</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 生成 一个能控制 order 与 goods 模块的 admin.token</span><br><span class="hljs-variable">$user</span>-&gt;<span class="hljs-title function_ invoke__">createToken</span>(<span class="hljs-string">&#x27;admin&#x27;</span>,[<span class="hljs-string">&quot;order&quot;</span>,<span class="hljs-string">&quot;goods&quot;</span>]);<br><br><span class="hljs-comment"># 验证 这个属性</span><br><span class="hljs-title function_ invoke__">auth</span>(<span class="hljs-string">&#x27;admin&#x27;</span>)-&gt;<span class="hljs-title function_ invoke__">user</span>()-&gt;<span class="hljs-title function_ invoke__">currentAccessToken</span>()-&gt;abilities;<br><br></code></pre></td></tr></table></figure><p>简单一点的直接用 <code>$name</code>  控制 多端也ok, 因为使用了数据库，所以扩展性也还 OK</p><h5 id="发放-token-有效期控制"><a href="#发放-token-有效期控制" class="headerlink" title="发放 token 有效期控制"></a>发放 token 有效期控制</h5><p>因为 官方 给出的过期时间很死板，没法做到 不同类型的 token 有不同的有效期，但还好也提供了一个回调函数来弥补</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#vendor/laravel/sanctum/src/Guard.php</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidAccessToken</span>(<span class="hljs-params"><span class="hljs-variable">$accessToken</span></span>): <span class="hljs-title">bool</span>  </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-comment">// ...... 重点在这</span><br>  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_callable</span>(<span class="hljs-title class_">Sanctum</span>::<span class="hljs-variable">$accessTokenAuthenticationCallback</span>)) &#123;  <br>        <span class="hljs-variable">$isValid</span> = (<span class="hljs-keyword">bool</span>) (<span class="hljs-title class_">Sanctum</span>::<span class="hljs-variable">$accessTokenAuthenticationCallback</span>)(<span class="hljs-variable">$accessToken</span>, <span class="hljs-variable">$isValid</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$isValid</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>重点就在 <code>Sanctum::$accessTokenAuthenticationCallback</code> 这个回调的属性上，<br>我们可以自定义这个回调函数 ，比如在 <code>AuthServiceProvider&gt;boot()</code> 内，通过<br><code>Sanctum::authenticateAccessTokensUsing</code> 来注入我们自定义的有效期检查逻辑</p><h5 id="hook-每次请求的更新操作-来减少数据库消耗"><a href="#hook-每次请求的更新操作-来减少数据库消耗" class="headerlink" title="hook 每次请求的更新操作 , 来减少数据库消耗"></a>hook 每次请求的更新操作 , 来减少数据库消耗</h5><p>我们可以通过 sql 监听发现，每次使用 sanctum , 都会产生两条 sql 记录，一条 通过id查询的sql,另一条为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> `personal_access_tokens` <span class="hljs-keyword">set</span> `last_used_at` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2022-07-01 19:03:02&#x27;</span>, `personal_access_tokens`.`updated_at` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2022-07-01 19:03:02&#x27;</span> <span class="hljs-keyword">where</span> `id` <span class="hljs-operator">=</span> <span class="hljs-number">195</span> &#123;&quot;time&quot;:<span class="hljs-number">29.06</span>&#125;<br></code></pre></td></tr></table></figure><p>看到这个执行时间就知道，这个 sql 肯定会成为整个系统的性能消耗点，现在让我们看看，这是在哪里触发的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#vendor/laravel/sanctum/src/Guard.php</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params">Request <span class="hljs-variable">$request</span></span>)  </span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//................... 调用触发点</span><br>  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">method_exists</span>(<span class="hljs-variable">$accessToken</span>-&gt;<span class="hljs-title function_ invoke__">getConnection</span>(), <span class="hljs-string">&#x27;hasModifiedRecords&#x27;</span>) &amp;&amp;  <br>            <span class="hljs-title function_ invoke__">method_exists</span>(<span class="hljs-variable">$accessToken</span>-&gt;<span class="hljs-title function_ invoke__">getConnection</span>(), <span class="hljs-string">&#x27;setRecordModificationState&#x27;</span>)) &#123;  <br>            <span class="hljs-title function_ invoke__">tap</span>(<span class="hljs-variable">$accessToken</span>-&gt;<span class="hljs-title function_ invoke__">getConnection</span>()-&gt;<span class="hljs-title function_ invoke__">hasModifiedRecords</span>(), function (<span class="hljs-variable">$hasModifiedRecords</span>) <span class="hljs-keyword">use</span> ($<span class="hljs-title">accessToken</span>) &#123;  <br>                $<span class="hljs-title">accessToken</span>-&gt;<span class="hljs-title">forceFill</span>([&#x27;<span class="hljs-title">last_used_at</span>&#x27; =&gt; <span class="hljs-title">now</span>()])-&gt;<span class="hljs-title">save</span>();  <br>  <br>                <span class="hljs-variable">$accessToken</span>-&gt;<span class="hljs-title function_ invoke__">getConnection</span>()-&gt;<span class="hljs-title function_ invoke__">setRecordModificationState</span>(<span class="hljs-variable">$hasModifiedRecords</span>);  <br>            &#125;);        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-variable">$accessToken</span>-&gt;<span class="hljs-title function_ invoke__">forceFill</span>([<span class="hljs-string">&#x27;last_used_at&#x27;</span> =&gt; <span class="hljs-title function_ invoke__">now</span>()])-&gt;<span class="hljs-title function_ invoke__">save</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$tokenable</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>问题就转换成了 对于<br><code>$accessToken-&gt;forceFill([&#39;last_used_at&#39; =&gt; now()])-&gt;save()</code><br>这个代码的优化，很显然，好多时候我们并不需要 通过这种方式去，更新 <code>last_used_at</code> 字段，甚至不客气的说，这有点过度设计，因为这个字段基本用不到，提供一个可选的回调属性，来替换这一个操作更加合理。</p><p>个人提供的思路为 ，替换原来 model</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># app/Providers/AppServiceProvider.php &gt; boot() 中 替换原来 model</span><br><br><span class="hljs-title class_">Sanctum</span>::<span class="hljs-title function_ invoke__">usePersonalAccessTokenModel</span>(<span class="hljs-title class_">\App\Models\PersonalAccessToken</span>::<span class="hljs-variable language_">class</span>);<br><br><span class="hljs-comment">#然后在 新建的 model 中 继承重写 forceFill()</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forceFill</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$attributes</span></span>)  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-comment">//hook $accessToken-&gt;forceFill([&#x27;last_used_at&#x27; =&gt; now()])-&gt;save(); 这个操作  </span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">count</span>(<span class="hljs-variable">$attributes</span>) === <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$attributes</span>[<span class="hljs-string">&#x27;last_used_at&#x27;</span>]))&#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>;  <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static</span>::<span class="hljs-title function_ invoke__">unguarded</span>(function () <span class="hljs-keyword">use</span> ($<span class="hljs-title">attributes</span>) &#123;  <br>        <span class="hljs-title">return</span> $<span class="hljs-title">this</span>-&gt;<span class="hljs-title">fill</span>($<span class="hljs-title">attributes</span>);  <br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，去掉了对于 <code>last_used_at</code> 的更新操作，每次请求就只有一次 sql 操作了，至于需要属性的，可以自行调整更新频率</p><ul><li>最后可能要去优化的点，对于每次的通过ID查整条token的操作，很明显是一个读多写少的场景，可以考虑上缓存去替换这个查询 sql ，但是不是极限场景（秒杀之类的），我不建议这么去做，收益太少了~</li></ul>]]></content>
    
    
    <categories>
      
      <category>laravel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>laravel</tag>
      
      <tag>sanctum</tag>
      
      <tag>auth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓自动化软件 tasker 的实践</title>
    <link href="/posts/292e141b/"/>
    <url>/posts/292e141b/</url>
    
    <content type="html"><![CDATA[<h2 id="安卓自动化-tasker-的实践"><a href="#安卓自动化-tasker-的实践" class="headerlink" title="安卓自动化 tasker 的实践"></a>安卓自动化 tasker 的实践</h2><p>事情是这个样子的，出于不合理工时以及废旧安卓的再利用，我需要在不<code>root</code>的情况下进行<code>xxapp</code>的自动打卡</p><h2 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h2><p>经过<code>Google</code>与<code>V站</code>查询，大致的有这4种思路去做</p><ul><li>自动化相关应用<ul><li><code>tasker</code>、<code>autojs</code>、<code>hamibot</code></li></ul></li><li>远程工具<ul><li><code>TeamViewer</code></li></ul></li><li>虚拟定位软件</li><li>修改 <code>WiFi mac</code> 地址</li></ul><h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><p><code>xxapp</code> 极速打卡可能会存在的一些检测机制</p><ul><li><code>xxapp</code>会定期检测实时位置</li><li><code>xxapp</code>会读取相关运行应用</li><li>另外需要注意的一点是避免打卡的时间过于固定与一致</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>最终我使用 <a href="https://tasker.joaoapps.com/download.html">tasker</a> 来做这件事</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ul><li>因为是旧华为手机，给 <code>tasker</code> 把权限全部打开</li><li>电池优化相关，设置 <code>tasker</code> 不进入优化名单</li><li>7次点击版本号，进入开发者模式，关闭锁屏选项,开启运行 <code>adb</code> 调试</li><li><a href="https://www.xda-developers.com/install-adb-windows-macos-linux/#adbsetupwindows">windows电脑端 adb 下载</a> ， 设置安全权限 <code>adb shell pm grant net.dinglisch.android.taskerm android.permission.WRITE_SECURE_SETTINGS</code></li></ul><h3 id="tasker-应用基础概念"><a href="#tasker-应用基础概念" class="headerlink" title="tasker 应用基础概念"></a>tasker 应用基础概念</h3><p>在完成上述的设置之后，进入这个软件，我们目前要用的核心板块有三块，配置文件、任务与变量。</p><p>配置文件可以对任务进行编排，设置触发条件，任务指的是一系列操作的集合，而变量则可以在多个任务之间进行传递。</p><p>我们很轻松可以实现一个打开app的任务,然后app内设置极速打卡，这样我们的设想就成立了，剩下的就是完善。</p><h3 id="定期检测实时位置"><a href="#定期检测实时位置" class="headerlink" title="定期检测实时位置"></a>定期检测实时位置</h3><p>目前处理方式为 将手机放在公司，连接上公司的WiFi，避免虚拟定位导致人一秒钟，移动几公里的漂移问题。</p><h3 id="读取相关运行应用"><a href="#读取相关运行应用" class="headerlink" title="读取相关运行应用"></a>读取相关运行应用</h3><p>这也是不采用虚拟定位app 来进行打卡的原因之一，xx会扫描正在运行时的包，部分应用可能处在黑名单之中。需要在打卡之前，根据随机值，去开启一系列的应用，来模拟日常有人使用的假象。</p><h3 id="不固定打卡时间"><a href="#不固定打卡时间" class="headerlink" title="不固定打卡时间"></a>不固定打卡时间</h3><p>核心功能中的变量正好能处理这个事情，设置一个全局变量<code>%Random</code> 在任务中去进行随机变量的操作，再设置一个等待随机分钟的任务，记得设置的大一点，来避免总时长过于一致的尴尬，这样就算完成打卡的核心功能</p><h3 id="避免节假日自动打卡"><a href="#避免节假日自动打卡" class="headerlink" title="避免节假日自动打卡"></a>避免节假日自动打卡</h3><p>这个可以自己写shell但是没必要，手机设置，自动开关机，智能跳过节假日就好~</p><h3 id="打卡后的通知"><a href="#打卡后的通知" class="headerlink" title="打卡后的通知"></a>打卡后的通知</h3><p>既然手机放在公司，能连上WiFi就可以通过网络来通知，注册一个企业微信，再跟个人微信绑定，创建一个专门用于通知的应用，简单的编写一个通知程序，跑在自己的服务器上，在任务的最后通过 http来调用这个程序，将消息下发到关联微信就好~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不root的情况下，安卓自动化应用确实是比较弱，这个应用能干的事情也远不止打打卡，后续如果遇到了合适的场景，再去试试它的其他功能，886~</p>]]></content>
    
    
    <categories>
      
      <category>tasker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx常用功能详解</title>
    <link href="/posts/144ead03/"/>
    <url>/posts/144ead03/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx-常用功能详解"><a href="#nginx-常用功能详解" class="headerlink" title="nginx 常用功能详解"></a>nginx 常用功能详解</h1><h2 id="nginx与php-fpm的两种通信方式详解"><a href="#nginx与php-fpm的两种通信方式详解" class="headerlink" title="nginx与php-fpm的两种通信方式详解"></a>nginx与php-fpm的两种通信方式详解</h2><p>一般来说，我们配置 <code>nginx</code> 与 <code>php-fpm</code> 的通信会有两种设置，以 <code>unix socket</code> 与 <code>tcp/ip socket</code> 的方式 通过 fast-cgi 协议进行通信</p><p>比如</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># tcp socket 的方式</span><br><span class="hljs-attribute">fastcgi_pass</span>  <span class="hljs-number">127.0.0.1:9000</span><br><span class="hljs-comment"># unix socket 的方式</span><br>fastcgi_pass  /usr/run/php-fpm.sock <br></code></pre></td></tr></table></figure><h2 id="对比-UNIX-Domain-Socket-与-TCP-IP-Socket"><a href="#对比-UNIX-Domain-Socket-与-TCP-IP-Socket" class="headerlink" title="对比 UNIX Domain Socket 与 TCP&#x2F;IP Socket"></a>对比 UNIX Domain Socket 与 TCP&#x2F;IP Socket</h2><p><code>socket api</code> 原本是为 网络通讯设计的，后来在socket 上发展出一种 <code>IPC(Inter-Process Communication 进程间通信)</code> 机制， 就是<code>unix socket</code> ，当然 <code>socket</code> 也可以进行 本机通信（通过 <code>loopback</code> 地址<code>127.0.0.1</code>），<code>unix socket</code>对比 <code>tcp socket</code> 效率更高，不需要经过网络协议栈，不需要打包 拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。<code>IPC</code> 机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。</p><ul><li><p><code>UNIX Socket</code> （同一服务器上不同进程间的通信机制）</p><ul><li>不需要网络协议栈、打包拆包,减少了 tcp 开销，理论效率比 tcp socket 更高</li><li>缺点也是因为缺少tcp的检查与重试机制，在高并发时稳定性欠佳（需要优化内核与应用相关参数）<ul><li>listen.backlog   等待连接数，当其被用完时直接 502</li><li>pm.max_children 进程都在执行等待时处理过慢 504</li><li><a href="https://shipengliang.com/software-exp/nginx%E5%92%8Cphp-fpm%E4%BD%BF%E7%94%A8tcp-socket%E8%BF%98%E6%98%AFunix-socket.html">https://shipengliang.com/software-exp/nginx%E5%92%8Cphp-fpm%E4%BD%BF%E7%94%A8tcp-socket%E8%BF%98%E6%98%AFunix-socket.html</a></li><li><a href="https://blog.csdn.net/weixin_42123737/article/details/81367074">https://blog.csdn.net/weixin_42123737/article/details/81367074</a></li></ul></li></ul></li><li><p><code>TCP/IP Socket</code> （多台服务器上不同进程间的通信机制）</p><ul><li>扩展方便 , 适合 nginx 与 php-fpm 在不同服务器的情况</li><li>相关优化方案比较多  <a href="https://blog.51cto.com/u_15322220/3286743">https://blog.51cto.com/u_15322220/3286743</a></li></ul></li><li><p>相关衍生问题</p><ul><li><p>协议 CGI 与 FAST-CGI</p><ul><li>cgi 与 fast-cgi 协议 对比？</li><li>fast-cgi 协议相关？<ul><li><a href="https://www.cnblogs.com/itbsl/p/9828776.html#%E6%B7%B1%E5%85%A5cgi%E5%8D%8F%E8%AE%AE">https://www.cnblogs.com/itbsl/p/9828776.html#%E6%B7%B1%E5%85%A5cgi%E5%8D%8F%E8%AE%AE</a></li><li>协议头 <code>version type request_id content_length</code></li><li>协议体 <code>data</code></li></ul></li></ul></li><li><p>fpm backlog 配置优化</p><ul><li><a href="https://www.cnxct.com/something-about-phpfpm-s-backlog/">https://www.cnxct.com/something-about-phpfpm-s-backlog/</a></li></ul></li><li><p>进程间通信 IPC 的7种方式？</p><ul><li>匿名管道 pipe</li><li>有名管道 fifo</li><li>信号 Signal</li><li>消息队列 Message</li><li>共享内存 share memory</li><li>信号量 semaphore</li><li>嵌套字 socket</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>php-fpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes(一)</title>
    <link href="/posts/e2edcca7/"/>
    <url>/posts/e2edcca7/</url>
    
    <content type="html"><![CDATA[<h1 id="kubernetes-概念"><a href="#kubernetes-概念" class="headerlink" title="kubernetes 概念"></a>kubernetes 概念</h1><ul><li><p>相关参考文档</p><ul><li><a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/nd7yOvdY">https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/nd7yOvdY</a></li><li><a href="https://kubernetes.io/zh/docs/tasks/">https://kubernetes.io/zh/docs/tasks/</a></li></ul></li><li><p>什么是 kubernetes ?</p><ul><li>为 容器化  应用提供集群部署和管理的开源工具，特点是 声明式，自动化</li><li>运维部署的发展，<ul><li>物理机部署；</li><li>虚拟化部署（对物理机进行抽象&#x3D;&gt;多个虚拟机（模拟完整的计算机））</li><li>容器化部署（以应用为基础进行抽象&#x3D;&gt;给每一个应用模拟一个完整的计算机环境，实际上是共享资源，屏蔽了底层的OS，可移植性更强，资源利用率更高，更适合微服务开发运维）</li></ul></li><li>特性 （可弹性运行分布式系统的框架）<ul><li>服务发现和负载均衡</li><li>存储编排</li><li>自动部署和回滚</li><li>自我修复</li><li>密钥与配置管理</li></ul></li></ul></li><li><p>什么时候需要 kubernetes ？</p><ul><li>前提条件 - 应用容器化</li><li>单机， docker + docker-compose  就足够了</li><li>3，4 台机器，shell 脚本 +负载均衡 也够用了</li><li>需要部署 更多台机器时，运维工作会很痛苦</li><li>kubernetes 最多支持 5000  node(类似于 5000 台机器)<ul><li>每个 node  最默认最大支持 Pod (类似于 application ) 110</li><li>pod  总数 不超过 15W</li><li>容器总数不超过 30W</li></ul></li></ul></li></ul><h2 id="kubernetes-的组成"><a href="#kubernetes-的组成" class="headerlink" title="kubernetes 的组成"></a>kubernetes 的组成</h2><h3 id="Node-节点-部署了-kubernetes-的机器"><a href="#Node-节点-部署了-kubernetes-的机器" class="headerlink" title="Node 节点(部署了 kubernetes 的机器)"></a>Node 节点(部署了 kubernetes 的机器)</h3><ul><li>主节点 Master （控制与调度）</li><li>工作节点 Worker<ul><li>Pod （k8s 调度的最小单元，可以包含一个或多个容器）<ul><li>虚拟 IP</li></ul></li></ul></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="控制平面组件-（Control-Plane-Components）"><a href="#控制平面组件-（Control-Plane-Components）" class="headerlink" title="控制平面组件 （Control Plane Components）"></a>控制平面组件 （Control Plane Components）</h4><p>   对集群进行调度&amp;检测</p><ul><li>kube-apiserver  (kubernetes api 服务器 是控制面的前端)</li><li>etcd (存储集群信息的后端键值对数据库)</li><li>kube-scheduler (监视新创建、未执行运行节点的 Pods, 选择节点 让 Pod 在上面运行)</li><li>kube-controller-manager (运行控制器的组件)<ul><li>节点控制器</li><li>任务控制器</li><li>端点控制器</li><li>账户服务和令牌控制器</li></ul></li><li>cloud-controller-manager (云控制器，可以将集群连接到云服务商的API上)</li></ul><h4 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h4><p>  在每个节点上运行，维护运行的Pod 提供 kubernetes 运行环境</p><ul><li>kubelet (运行在node 上的代理，保证 容器都运行在 Pod 中, 只控制 由 kubernetes 创建的容器)</li><li>kebe-proxy  (负责节点的网络代理)</li><li>容器运行时 （Container Runtime, 符合CRI 的环境 如 docker）</li></ul><h4 id="插件-Addons-提供集群级别功能"><a href="#插件-Addons-提供集群级别功能" class="headerlink" title="插件 Addons ( 提供集群级别功能)"></a>插件 Addons ( 提供集群级别功能)</h4><ul><li>DNS</li><li>Web 界面（仪表盘）</li><li>容器资源监控</li><li>集群层面日志</li></ul><h2 id="installer"><a href="#installer" class="headerlink" title="installer"></a>installer</h2><ul><li>minikube</li><li>云平台kebernetes</li><li>裸机安装</li></ul><h3 id="docker-的安装"><a href="#docker-的安装" class="headerlink" title="docker 的安装"></a>docker 的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将防火墙 配置全部置空</span><br><br>systemctl stop firewalld &amp;&amp; systemctl disable firewalld<br><br>iptables -F<br>iptables -X<br>iptables -P INPUT ACCEPT<br>iptables -P OUTPUT ACCEPT<br>iptables -P FORWARD ACCEPT<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭内存交换</span><br>swapoff -a<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭 selinux</span> <br>vim /etc/selinux/config<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改后重启</span><br>SELINUX=disabled<br><br>yum remove docker  docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine<br><br>yum install -y yum-utils<br><br>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br><br>yum install docker-ce docker-ce-cli containerd.io -y<br><br>systemctl start docker<br><br>systemctl enable docker<br></code></pre></td></tr></table></figure><h3 id="minikube-的安装"><a href="#minikube-的安装" class="headerlink" title="minikube 的安装"></a>minikube 的安装</h3><h4 id="安装-kubectl"><a href="#安装-kubectl" class="headerlink" title="安装 kubectl"></a>安装 kubectl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64<br>enabled=1<br>gpgcheck=0<br>repo_gpgcheck=0<br>gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg<br>       https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<br>EOF<br><br>yum install -y kubectl<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者直接拉二进制文件</span><br>curl -Lo kubectl https://kubernetes.oss-cn-hangzhou.aliyuncs.com/kubernetes-release/release/v1.20.2/bin/linux/amd64/kubectl &amp;&amp; chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/<br></code></pre></td></tr></table></figure><h4 id="安装-单机-minikube"><a href="#安装-单机-minikube" class="headerlink" title="安装 单机 minikube"></a>安装 单机 minikube</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/release/v1.20.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/<br><br>yum install epel-release -y <br>yum install conntrack-tools -y<br><br>minikube version<br><br>sudo /usr/local/bin/minikube start --registry-mirror=https://registry.docker-cn.com --vm-driver=none --alsologtostderr -v=4<br></code></pre></td></tr></table></figure><p>安装 k8s 面板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install xdg-utils <br><br>minikube dashboard<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">出现下列信息 就已经开启</span><br>* 正在验证 dashboard 运行情况 ...<br>* Launching proxy ...<br>* 正在验证 proxy 运行状况 ...<br>http://127.0.0.1:46491/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/<br></code></pre></td></tr></table></figure><h5 id="可能会碰到的问题"><a href="#可能会碰到的问题" class="headerlink" title="可能会碰到的问题"></a>可能会碰到的问题</h5><ul><li>minikube 卡在 正在验证 proxy 运行状况 …</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop kubectl<br>systemctl stop docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将防火墙 配置全部置空</span><br>iptables -F<br>iptables -X<br>iptables -P INPUT ACCEPT<br>iptables -P OUTPUT ACCEPT<br>iptables -P FORWARD ACCEPT<br><br>systemctl start kubectl<br>systemctl start docker<br></code></pre></td></tr></table></figure><ul><li>本地策略限制本机访问</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">思路一 ，本机开 nginx 代理转发流量</span><br>upstream api_k8s_service &#123;<br>  server localhost:46491;<br>&#125;<br><br>server &#123;<br>    listen       8099;<br>    server_name  localhost;<br><br>    #access_log  /var/log/nginx/host.access.log  main;<br><br>    location / &#123;<br>proxy_set_header Host 127.0.0.1;<br>        proxy_pass http://api_k8s_service/;<br>    &#125;<br><br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">思路二</span> <br>kubectl proxy --address=&#x27;0.0.0.0&#x27; --accept-hosts=&#x27;^*$&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这样就可以直接访问 不需要 minikuba dashboard</span><br>http://xx.xx.x.xx:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/overview?namespace=default<br></code></pre></td></tr></table></figure><ul><li>访问 dashboard 异常</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">访问</span><br>http://xx.xx.x.xx:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/overview?namespace=default<br><br></code></pre></td></tr></table></figure><ul><li>排查思路 先确认是 哪一个 pod 有问题<ul><li>kubectl get pods –namespace kube-system</li></ul></li><li>查看 READY 状态不正常 的pod log<ul><li>kubectl describe pod  kube-proxy-h57wx –namespace kube-system</li></ul></li></ul><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
      <tag>minikube</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机概论（一）</title>
    <link href="/posts/a8d55f39/"/>
    <url>/posts/a8d55f39/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机硬件组成"><a href="#计算机硬件组成" class="headerlink" title="计算机硬件组成"></a>计算机硬件组成</h2><ul><li><p>中央处理器CPU(运算器&amp;控制器&amp;寄存器组&amp;内部总线)</p><ul><li>寄存器 <ul><li>cpu内部用来暂时存放参与运算的数据跟结果的小单元</li><li>本质为常见的时序逻辑电路，只包含存储电路</li></ul></li><li>运算器<ul><li>算数逻辑单元(Arithmetic and Logic Unit, ALU)<ul><li>负责数据处理，对数据的算数与逻辑运算</li></ul></li><li>累加寄存器(Accumulator, AC)<ul><li>通用寄存器，为ALU执行算数或逻辑运算时，提供工作区</li></ul></li><li>数据缓冲寄存器(Data Register, DR)<ul><li>在内存进行读&#x2F;写操作时，暂时存放指令或数据，分离不同时间读&#x2F;写的数据</li></ul></li><li>状态条件寄存器 (Program Status Word, PSW)<ul><li>保存算数和逻辑指令的结果所产生的条件码，包括状态标志和控制标志</li></ul></li></ul></li><li>控制器<ul><li>程序计数器(Program Counter Register,  PC)<ul><li>寄存信息跟计数，保存指令地址并自动保存下一条指令地址</li></ul></li><li>地址寄存器 (Address Register, AR)<ul><li>保存当前CPU访问的内存单元的地址</li></ul></li><li>指令寄存器 (Instruction Register, IR)<ul><li>暂存指令</li></ul></li><li>指令译码器(Instruction Decoder, ID)<ul><li>分析解释指令中的操作码字段，识别该指令的操作，向控制器发出控制信号，控制各部件完成工作</li></ul></li></ul></li><li>寄存器组<ul><li>通用寄存器 ：作用可变</li><li>专用寄存器： 运算器和控制器中的寄存器是专用寄存器，作用固定</li></ul></li><li>内部总线是一种内部结构，是 cpu 内存 输入 输出设备传递信息的公用通道</li></ul><p><img src="/img/15.png" alt="一条指令的执行过程简易图示"></p></li><li><p>存储器(内部存储&amp;外部存储)</p><ul><li>cpu 内部的通用寄存器组，cpu内的Cache(高速缓存)，</li><li>cpu外部的Cache、主板上的主存储器，主板外的联机磁盘存储器（在线），U盘存储（离线）</li><li>** Cache 和主存之间的交互功能全部由硬件实现 **  主存与辅存之间的交互可由软硬件结合实现</li><li>分类方式<ul><li>位置 ： 内存与外存</li><li>工作方式: 读&#x2F;写存储器（Random Access Memory RAM），只读存储器(Read Only Memory ROM)</li><li>访问方式：按地址访问、按内存访问</li><li>寻址方式：随机存储器、顺序存储器、直接存储器</li></ul></li><li>Cache 高速缓存<ul><li>从内存中去取数据映射到Cache 中，cpu 会先从 Cache 中寻址，取不到才会去主存中获取，然后替换掉，Cache 中的一块，<strong>Cache 与主存中的地址映射是由硬件自动完成的</strong></li><li>映射关系分类<ul><li>直接映像：固定的</li><li>全相联映像：主存与Cache存储器均分成大小相同的块，相互映射</li><li>组相联映像：将组内的块再分组</li></ul></li><li>替换的算法<ul><li>随机替换</li><li>先进先出</li><li>LRU 近期最少使用算法</li><li>优化替换算法，先统计Cache的替换情况，下次根据替换情况来替换</li></ul></li></ul></li><li>虚拟存储器（用磁盘来 扩大 内存 swap）</li></ul></li><li><p>输入与输出</p><ul><li>内存与接口地址的编址 方式</li><li>外设<ul><li>直接程序控制<ul><li>无条件传送</li><li>程序查询 需要先查询外设状态，再去执行</li></ul></li><li>中断处理<ul><li>在接受中断请求信号后，会保存程序现场，先去执行中断，再去执行目前的程序</li><li>中断优先级控制 多个中断源服务，CPU 会优先响应级最高的中断源</li></ul></li><li><strong>直接内存存取 （Direct Memory Access, DMA）</strong><ul><li>内存在I&#x2F;O 设备间的传送一个数据块的过程中，<strong>不需要CPU的任何干涉</strong> 实际操作是由DMA硬件直接执行完成的。<strong>但此时总线是被占用的</strong></li></ul></li><li>输入输出处理机 （Input&#x2F;Output Processor, IOP ) 分担了CPU的一部分功能，实现对外围设备的统一管理，完成外围设备与主存之间的数据传送</li></ul></li></ul></li><li><p>总线结构</p><ul><li>总线（bus ）数据总线、地址总线、控制总线3类。<ul><li>数据总线 (Data bus, DB) 信息传输，双向的，宽度决定一次性交换数据的位数</li><li>地址总线 (Address bus, AB)传送CPU发出的地址信息， 单向的，最大寻址能力</li><li>控制总线(Controller bus, CB)，双向的。</li></ul></li></ul></li></ul><h3 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h3><ul><li>三大分类 <strong>技术安全，管理安全，政策法律安全</strong></li><li>数据安全（内部安全，外部安全）</li><li>可靠性 （不稳定期，正常工作期，老化期）<ul><li>串联系统的可靠性 &#x3D; 各个子系统可靠性相乘 </li><li>并联系统的可靠性 &#x3D; <code>1- (1-r1)* (1-r2)* (1-r3)</code> 1 减去 不可靠性</li><li>N模冗余系统  <code>N=2n+1</code> 只要 n+1 或 n+1以上的系统正常工作就是正常工作</li></ul></li></ul><h3 id="计算机性能"><a href="#计算机性能" class="headerlink" title="计算机性能"></a>计算机性能</h3><h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h3><ul><li>处理系统<ul><li>单处理系统</li><li>并行处理与多处理系统</li><li>分布式处理系统</li></ul></li><li>指令系统 (Instruction Set Architecture ISA )<ul><li><p>1.操作数在cpu上的存储方式 2. 显示操作数的数量 3. 操作数的位置，能放入主存，如何定位 4.指令支持那些操作 5. 操作数的类型与大小</p></li><li><p>暂存机制</p><ul><li>堆栈（stack）, 累加器 (Accumulator), 寄存器组 (a set of register)</li></ul></li><li><p>CISC (Complex Instruction Set Computer) 复杂指令集计算机</p></li><li><p>RISC (Reduced Instruction Set Computer) 精简指令集计算机</p><ul><li>关键技术</li><li>重叠寄存器窗口</li><li>优化编译技术</li><li>超流水及超标量技术</li><li>硬布线逻辑与微程序的结合</li></ul></li><li><p>指令的流水</p><ul><li>顺序方式   先分析再执行</li><li>重叠方式 （分析与执行指令 同时执行）</li><li>流水方式  把重复的顺序处理过程分解为若干子过程，每个子过程可以<ul><li>解决局部相关性，解决</li><li>超流水线</li><li>超标量</li><li>超长指令字</li><li>吞吐量 为最长子过程耗费时间的导数</li></ul></li></ul></li></ul></li></ul><h3 id="软件（程序-数据-文档）"><a href="#软件（程序-数据-文档）" class="headerlink" title="软件（程序&amp;数据&amp;文档）"></a>软件（程序&amp;数据&amp;文档）</h3><ul><li>系统软件</li><li>应用软件</li></ul><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><ul><li>机器数 二进制数</li><li>无符号数</li><li>带符号数（机器数的最高位代表正负符号，其他标识数值）</li></ul><h4 id="码制-（原码，反码，补码，移码）"><a href="#码制-（原码，反码，补码，移码）" class="headerlink" title="码制 （原码，反码，补码，移码）"></a>码制 （原码，反码，补码，移码）</h4><ul><li>原码 由符号位和真值的绝对值组成（<strong>原码不能直接拿来计算</strong>）</li><li>反码：正数不变，负数的反码是其<strong>原码</strong>的基础上，符号位不变，其他的 按位取反</li><li>补码：正数不变，负数的补码是其<strong>反码</strong>加一 <strong>（计算时一般使用补码）</strong></li><li><strong>正数的 原码，反码，补码 一致</strong></li><li>-0 与 +0 是不一致的，其符号位不同</li><li>反码与补码 为了减法的计算问题<ul><li>将减法变成 加法去计算，<code>减法电路比 加法电路 复杂</code></li></ul></li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">字长 就是一次性读取二进制位的个数<br>定点整数-根据字长求范围，<br>原码 =`-(2^(n<span class="hljs-string">-1</span>) - 1) ~ +(2^(n<span class="hljs-string">-1</span>) - 1)`  = 反码<br>补码 中 人为 规定 `<span class="hljs-string">-0</span> = <span class="hljs-string">-2</span>^n` 所以补码范围为 `<span class="hljs-string">-2</span>^(n<span class="hljs-string">-1</span>) ~ +(2^(n<span class="hljs-string">-1</span>) - 1)`  = 移码<br></code></pre></td></tr></table></figure><h4 id="小数的表示"><a href="#小数的表示" class="headerlink" title="小数的表示"></a>小数的表示</h4><ul><li><p>定点小数（纯小数，如0.8）</p><ul><li><code>正负号|1|0|0|0|</code></li></ul></li><li><p>定点小数 (规定所有数值数据的小数点后隐含在某一个固定位置上)，小数点本身不占用位置</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">定点小数-根据字长求范围，<br>原码 =`-(1- 2^-(n<span class="hljs-string">-1</span>)) ~ +(1- 2^-(n<span class="hljs-string">-1</span>))`  = 反码<br>补码 中 人为 规定 `<span class="hljs-string">-0</span> = <span class="hljs-string">-2</span>^n` 所以补码范围为 `<span class="hljs-string">-1</span>~ +(1<span class="hljs-string">-2</span>^-(n<span class="hljs-string">-1</span>))`  = 移码<br></code></pre></td></tr></table></figure></li></ul><h4 id="浮点数表示-（小数点位置不固定）"><a href="#浮点数表示-（小数点位置不固定）" class="headerlink" title="浮点数表示 （小数点位置不固定）"></a>浮点数表示 （小数点位置不固定）</h4><ul><li><code>N = 尾数*基数^指数|阶码</code></li><li>尾数 &#x3D; 定点小数 （补码）， 阶码&#x3D;定点整数（移码）</li><li><code>N = M * 2^E</code> (E 阶码  M 尾数) </li><li>符号位，指数，尾数</li><li><strong>阶符（阶码的符号位）|阶码|数符（尾数的符号位）|尾数</strong> 构成了浮点数<ul><li>基数在计算机中默认为2</li><li>阶码影响数值的范围</li><li>尾数可以表示有效精度，尾数越多</li><li>结果格式化</li></ul></li><li>计算过程<ul><li>阶码对齐，小数向大数对齐，小数的尾数右移实现的，高位补零</li><li>对尾数进行计算</li><li>结果格式化</li></ul></li><li>IEEE754 为浮点数事实标准</li></ul><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><ul><li>与 两者都为真才真</li><li>或 两者有一个为真就真</li><li>非 取反</li><li>异或 两者相同为真 不相同为假</li></ul><h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><ul><li>奇偶校验码 <strong>1位</strong><ul><li>只能检测错误，不能纠错</li></ul></li><li>海明码 把第N位的校验码放在 2n 位上<ul><li>在数据位之间 加入 <strong>K</strong> 个校验位，能检错跟纠错</li><li>设数据有n位，校验码为x位，校验码一共有2^x 种取值方式<ul><li>2^x - 1 &gt; x+n （能表示的出错的总数，要大于任一位出错的数值）</li></ul></li></ul></li><li>CRC<ul><li>采用 mod 2 的方式去计算</li></ul></li></ul><h2 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h2><h3 id="程序设计语言基本概念"><a href="#程序设计语言基本概念" class="headerlink" title="程序设计语言基本概念"></a>程序设计语言基本概念</h3><ul><li>机器指令是最基本的计算机语言（可读性差，难以修改和维护）</li><li>汇编语言（特定计算机）&amp;机器语言为低级语言</li><li>源程序 通过 <strong>汇编、解释和编译</strong> 进行翻译</li><li>解释程序（解释器）<ul><li>执行源程序  翻译成中间代码加以执行</li></ul></li><li>编译程序（编译器）<ul><li>编译器将源代码翻译成目标程序</li></ul></li><li>语法，语义，语用，语境</li><li>语言<ul><li>Fortran(Formula translation) 第一个广泛应用的高级语言</li><li>c 直接访问操作系统和底层硬件</li><li>c++ 面向对象，封装继承多态</li><li>c# </li><li>java 删除了c++指针相关特征</li><li>Python 面向对象，解释性（解释器&#x3D;&gt;中间码）语言（脚本语言）</li><li>JavaScript 脚本语言，解释性</li></ul></li><li>语言分类<ul><li>命令式&amp;结构化 Fortran c</li><li>面向对象 c++ java </li><li>函数式（LISP）1958年为人工智能应用而设计的语言</li><li>逻辑型程序设计语言 ProLog</li></ul></li><li></li></ul><h3 id="程序设计语言基本成分"><a href="#程序设计语言基本成分" class="headerlink" title="程序设计语言基本成分"></a>程序设计语言基本成分</h3><ul><li>基本成分包括 <strong>数据，运算，控制和传输</strong></li><li>数据<ul><li>有存储类别 ，类型，名称，作用域，生存周期… 属性</li><li>常量&amp;变量<ul><li>数据对象可以拥有左值（存储单元|地址|容器）和右值（内容）</li></ul></li><li>全局量和局部量</li><li>数据类型<ul><li>基本类型</li><li>特殊类型</li></ul></li></ul></li><li>控制<ul><li>顺序，选择，循环（初始化，循环体，循环条件）</li></ul></li><li>传输（赋值处理，数据的输入和输出）<ul><li>包括函数（定义，声明，调用）</li></ul></li></ul><h3 id="汇编程序基本原理"><a href="#汇编程序基本原理" class="headerlink" title="汇编程序基本原理"></a>汇编程序基本原理</h3><ul><li>面向特定计算机设计的符号化的程序设计语言，编写的源程序需要汇编翻译程序进行翻译。</li><li>语句<ul><li>指令语句-汇编后能被CPU直接识别与执行的操作 如 ADD,SUB和AND <ul><li><strong>传送指令，算术运算指令，逻辑运算指令，移位指令，转移指令和处理机控制指令</strong></li></ul></li><li>伪指令语句，在汇编源程序时完成一些工作 <strong>汇编后不产生机器代码</strong><ul><li><strong>所指示的操作是在源程序被汇编时完成的，指令语句的操作必须在运行时完成</strong></li></ul></li><li>宏指令语句 <strong>多次重复使用的程序段定义为宏</strong></li></ul></li><li>工作原理 （将源程序翻译成对饮固定机器指令）<ul><li>经过<strong>两次扫描</strong> ，第一次扫描创建一个<strong>符号表</strong>（初始化），第二次产生目标程序</li></ul></li></ul><h3 id="编译程序基本原理"><a href="#编译程序基本原理" class="headerlink" title="编译程序基本原理"></a>编译程序基本原理</h3><ul><li><strong>编译的过程6个部分</strong> </li><li>源程序 <ul><li><ol><li>词法分析</li></ol></li><li><ol start="2"><li>语法分析</li></ol></li><li><ol start="3"><li>语义分析</li></ol></li><li><ol start="4"><li>中间码生成</li></ol></li><li><ol start="5"><li>代码优化</li></ol></li><li><ol start="6"><li>目标代码生成</li></ol></li></ul></li><li>生成目标代码</li></ul><h3 id="解释程序基本原理"><a href="#解释程序基本原理" class="headerlink" title="解释程序基本原理"></a>解释程序基本原理</h3><ul><li>解释程序的处理主要分为两个部分<ul><li>分析<ul><li>词法，语法，语义 生成中间代码<strong>（语法树，后缀式[逆波兰式]，三地址代码）</strong></li></ul></li><li>解释<ul><li>对分析生成的中间代码进行解释执行</li></ul></li></ul></li></ul><p>解释与编译程序的比较</p><ul><li>效率低，灵活性强，可移植性强</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>数据结构是存储，组织数据的方式</li><li>算法是操作数据结构的行为</li></ul><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><ul><li>数组<ul><li>一维数组</li><li>多维数组</li></ul></li><li>链表<ul><li>线性表</li><li>顺序表（数组）</li><li>双向链表</li><li>循环链表</li><li>双向循环链表</li></ul></li><li>栈（堆栈）后进先出（Last In First Out, LIFO）(受限表)<ul><li>顺序存储（空间优先）</li><li>链式存储</li></ul></li><li>队列 先进先出（First In First Out , FIFO）(受限表)<ul><li>顺序队列 链表（无限空间）</li><li>循环队列 （有限空间）</li></ul></li></ul><h3 id="矩阵和广义表"><a href="#矩阵和广义表" class="headerlink" title="矩阵和广义表"></a>矩阵和广义表</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li>科学与工程计算领域研究的数学对象，（应用点 二维数组）</li><li>特殊矩阵，会对相同元素进行压缩</li><li>稀疏矩阵，不进行压缩的矩阵</li></ul><h4 id="广义表（线性表的推广）"><a href="#广义表（线性表的推广）" class="headerlink" title="广义表（线性表的推广）"></a>广义表（线性表的推广）</h4><ul><li>线性表的元素是结构上不可分的单元素，广义表的元素既可以是单元素，也可以是有结构的表</li><li>重要运算<ul><li>取表头</li><li>取表尾 <strong>非空广义表的表尾必定是一个表</strong></li></ul></li><li>特点<ul><li>多层次结构</li><li>元素可以是其他广义表</li><li>可以为递归表</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>软考中级软件设计师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年度小目标</title>
    <link href="/posts/cc443507/"/>
    <url>/posts/cc443507/</url>
    
    <content type="html"><![CDATA[<h1 id="2022新年小目标"><a href="#2022新年小目标" class="headerlink" title="2022新年小目标"></a>2022新年小目标</h1><p>事事关注，则事事无成。</p><h2 id="去年的总结"><a href="#去年的总结" class="headerlink" title="去年的总结"></a>去年的总结</h2><p>2021也算是完成了年初的部分计划，用 <code>golang</code> 做了项目，随着对计算机基础的学习，对一些技术上的概念有了自己的理解，跳槽成功，年度涨薪大约40%，达到了区域-职业-年限-行业的中游水平，在一家公司待久了就是会被倒挂，其实这也无可厚非。<br>软件开发职业的生命周期肯定很长，但是自己还能干这行多久，我也不确定，不希望自己用干一天和尚撞一天钟的心态来面对。新公司的理念我比较认可，结果导向，数据说话，效率优先。我希望这些东西也能在我个人的规划跟生活中体现。</p><h2 id="新年的规划"><a href="#新年的规划" class="headerlink" title="新年的规划"></a>新年的规划</h2><ul><li><p>证书&amp;学历</p><ul><li><strong>3月上半年主要是拿到本科学位证(已完成)</strong></li><li><del>暂无</del></li></ul></li><li><p>工作方向（工作中用的到的技术从原理到实践）</p><ul><li>lnrmp（base）  </li><li>进一步 go&amp;gin&amp;容器&amp;微服务理论；</li><li>可能性方向 做做页面||app 感受客户端的魅力。</li><li>探索方向 区块链&amp;以太坊&amp;ntf</li></ul></li><li><p>健康与生活方向</p><p>一个是锻炼，一年减重20斤，体脂下降5%左右，第二个能进一步学习拍照与摄影，多出去转转</p></li><li><p>写作</p><p>平台以我的 blog 跟公众号为主，不追求篇数了，希望能多写一些（50篇），毕竟这也是记忆的一部分</p></li></ul><p>这些事情如果不列出来，来年没法去统计完成度，虎年的心愿就是扎扎实实的进步，少关注世界上的大事，多关心身边小事。</p><h2 id="计划变更相关情况说明"><a href="#计划变更相关情况说明" class="headerlink" title="计划变更相关情况说明"></a>计划变更相关情况说明</h2><ul><li><p>取消考证相关事项，在潦草准备中发现，这些考证相关的课实用价值太低了，刷题实在是没兴趣。我还是以为，除了生存外，兴趣应当为学习的主导者，如果后续有需要在进行尝试。</p></li><li><p>最近 V 站话题有感，如果有一天你不做这个了，你会去干嘛？</p><ul><li>重新做机械&amp;硬件，智能家居，游戏，视频文字分享？ 最近也在考虑回老家的可能性。</li></ul></li></ul><h2 id="年度节点"><a href="#年度节点" class="headerlink" title="年度节点"></a>年度节点</h2><p>虽然很不喜欢kpi 类似的制度，但是其确实可以推进事情的发展，我也是个怠惰的性子，长时间通勤真的会磨掉人的锐气。</p><ul><li>1月 oauth 项目，lnmp</li><li>2月 年假</li><li>3月 推荐，新项目筹备开发</li><li>4月 新项目负责人与项目推进</li></ul>]]></content>
    
    
    <categories>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php-fpm模式下的优化思路与实践</title>
    <link href="/posts/baf65967/"/>
    <url>/posts/baf65967/</url>
    
    <content type="html"><![CDATA[<h1 id="php-fpm模式下的优化思路与实践"><a href="#php-fpm模式下的优化思路与实践" class="headerlink" title="php-fpm模式下的优化思路与实践"></a>php-fpm模式下的优化思路与实践</h1><p>一般来说，计算机体系中所谓的优化，无非三类，串行改并行，同步转异步，以及加缓存，减少执行。</p><h2 id="串行改并行"><a href="#串行改并行" class="headerlink" title="串行改并行"></a>串行改并行</h2><p>程序执行总时间&#x3D; (不可并行子模块…) 相加</p><p>在 <code>php-fpm</code> 模式下 每个请求都是单进程单线程去处理，而 <code>pcntl</code>（<code>php</code> 进程处理扩展）在 <code>fpm</code> 模式下无法使用。所以就有了各种勉强的处理方案。</p><h3 id="基于redis-各种mq-队列的并行操作"><a href="#基于redis-各种mq-队列的并行操作" class="headerlink" title="基于redis || 各种mq 队列的并行操作"></a>基于<code>redis || 各种mq</code> 队列的并行操作</h3><p>具体来说 就是利用 中间件 来对外发布任务，由消费者（比如用 <code>golang</code> 监听 <code>redis</code> ，开协程去处理多个 <code>task</code>）来进行并行的消费 , 然后把结果传回来。</p><p>那么你肯定也会有疑问，我直接<code>http</code>调用<code>go</code>的服务然后响应不行吗？当然可以，但是 <code>curl</code> 在 <code>php-fpm</code> 中是阻塞操作，用队列的方式更加灵活且不会堵塞。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$randKey</span> = <span class="hljs-title class_">Str</span>::<span class="hljs-title function_ invoke__">random</span>();<br><span class="hljs-variable">$redis</span>-&gt;<span class="hljs-title function_ invoke__">lpush</span>(<span class="hljs-variable">$key</span>,<span class="hljs-variable">$task1</span>.<span class="hljs-string">&#x27;-&#x27;</span>.<span class="hljs-variable">$task2</span>.<span class="hljs-string">&#x27;:&#x27;</span>.<span class="hljs-variable">$rankKey</span>);<br><span class="hljs-comment">// 堵塞等待消费者将 task 完成 然后把结果 塞入  $key.$rankKey </span><br><span class="hljs-variable">$data</span> = <span class="hljs-variable">$redis</span>-&gt;<span class="hljs-title function_ invoke__">brPop</span>(<span class="hljs-variable">$key</span>.<span class="hljs-variable">$randKey</span>, <span class="hljs-number">10</span>);<br>......<span class="hljs-comment">//其他逻辑</span><br></code></pre></td></tr></table></figure><h3 id="基于-popen-proc-open-exec-的并行操作"><a href="#基于-popen-proc-open-exec-的并行操作" class="headerlink" title="基于 popen || proc_open || exec  的并行操作"></a>基于 <code>popen || proc_open || exec </code> 的并行操作</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-variable">$pipe</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-string">&#x27;php ./exec.php &#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-title function_ invoke__">pclose</span>(<span class="hljs-variable">$pipe</span>[<span class="hljs-variable">$i</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种用 <code>shell</code> 的方式虽然看起来确实是简单了，但是存在两个问题，一个是函数的平台限制，第二是安全性较低，但不得不说 shell 有些特殊场景下确实很有用。</p><h2 id="同步转异步"><a href="#同步转异步" class="headerlink" title="同步转异步"></a>同步转异步</h2><p>在这类操作里面 除了串行改并行的的两种方式可以实现（需要额外的进程去处理），将执行操作异步，日常用的最多的是 <code>fastcgi_finish_request()</code> ，简单实在看下在 <code>laravel</code> 中的使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># public/index.php</span><br><br><span class="hljs-variable">$response</span> = <span class="hljs-variable">$kernel</span>-&gt;<span class="hljs-title function_ invoke__">handle</span>(<br>    <span class="hljs-variable">$request</span> = <span class="hljs-title class_">Request</span>::<span class="hljs-title function_ invoke__">capture</span>()<br>)-&gt;<span class="hljs-title function_ invoke__">send</span>();<br><br><span class="hljs-variable">$kernel</span>-&gt;<span class="hljs-title function_ invoke__">terminate</span>(<span class="hljs-variable">$request</span>, <span class="hljs-variable">$response</span>);<br><br><span class="hljs-comment"># vendor/symfony/http-foundation/Response.php:391</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">sendHeaders</span>();<br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">sendContent</span>();<br><br>    <span class="hljs-keyword">if</span> (\<span class="hljs-title function_ invoke__">function_exists</span>(<span class="hljs-string">&#x27;fastcgi_finish_request&#x27;</span>)) &#123;<br>    <span class="hljs-title function_ invoke__">fastcgi_finish_request</span>();<br>    &#125; <span class="hljs-keyword">elseif</span> (\<span class="hljs-title function_ invoke__">function_exists</span>(<span class="hljs-string">&#x27;litespeed_finish_request&#x27;</span>)) &#123;<br>    <span class="hljs-title function_ invoke__">litespeed_finish_request</span>();<br>    &#125; <span class="hljs-keyword">elseif</span> (!\<span class="hljs-title function_ invoke__">in_array</span>(\PHP_SAPI, [<span class="hljs-string">&#x27;cli&#x27;</span>, <span class="hljs-string">&#x27;phpdbg&#x27;</span>], <span class="hljs-literal">true</span>)) &#123;<br>    <span class="hljs-built_in">static</span>::<span class="hljs-title function_ invoke__">closeOutputBuffers</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <code>tp</code> 里面也一样使用了这个函数来进行收尾，优点很明显，代码还是在同一个进程内，无需额外的配置，开箱即用。缺点的话，就是在响应之后的逻辑比较重的情况下，fpm 的进程数会随着请求量的增加而增加。也会受到脚本最大执行时间的限制，只适合一些比较轻量级的异步操作，重要的业务逻辑，建议还是以 <code>MQ</code> 为主。</p><h2 id="fpm-中的性能优化实践"><a href="#fpm-中的性能优化实践" class="headerlink" title="fpm 中的性能优化实践"></a>fpm 中的性能优化实践</h2><p>缓存的重要性就不说了，在 <code>php-fpm</code> 的生命周期中，最重要的缓存就是 <code>OPcache</code> ，特别是 <code>laravel</code> 这种文件特别多，逻辑很重的框架 开不开 <code>OPcache</code> ，是两种体验，相关的配置 可以看我之前写过的<a href="https://blogxy.cn/2022/01/20/php8-1%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8E%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#php8-%E7%9A%84-opcache-%E4%B8%8E-jit-Just-In-Time"> 博文 </a> </p><ul><li><p>现在有用 <code>laravel</code> 框架写了一个登录后的用户 获取信息的 <code>API</code>, 使用 <code>JMeter</code> 进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">本地 fpm 的配置</span><br>pm = dynamic<br>pm.max_children = 5<br>pm.start_servers = 2<br>pm.min_spare_servers = 1<br>pm.max_spare_servers = 3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">jmeter 配置</span><br>线程数 : 7<br>Ramp-Up时间（秒）: 1<br>循环次数: 50<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接口执行的 sql</span><br>select * from `personal_access_tokens` where `personal_access_tokens`.`id` = &#x27;16&#x27; limit 1;<br><br>select * from `users` where `users`.`id` = &#x27;1&#x27; and `users`.`deleted_at` is null limit 1;<br><br>update `personal_access_tokens` set `last_used_at` = &#x27;2022-01-21 17:38:06&#x27;, `personal_access_tokens`.`updated_at` = &#x27;2022-01-21 17:38:06&#x27; where `id` = &#x27;16&#x27;;<br><br></code></pre></td></tr></table></figure></li></ul><ol><li>不开启 <code>OPcache</code> 的情况下相关统计</li></ol><table><thead><tr><th>Label</th><th># 样本</th><th>平均值</th><th>最小值</th><th>最大值</th><th>标准偏差</th><th>异常 %</th><th>吞吐量</th><th>接收 KB&#x2F;sec</th><th>发送 KB&#x2F;sec</th><th>平均字节数</th></tr></thead><tbody><tr><td>HTTP请求</td><td>350</td><td>537</td><td>73</td><td>961</td><td>151.25</td><td>0.00%</td><td>12.5255</td><td>6.4</td><td>2.52</td><td>523</td></tr><tr><td>总体</td><td>350</td><td>537</td><td>73</td><td>961</td><td>151.25</td><td>0.00%</td><td>12.5255</td><td>6.4</td><td>2.52</td><td>523</td></tr></tbody></table><ol start="2"><li>开启 <code>OPcache</code> 不开 <code>JIT</code> 的情况</li></ol><table><thead><tr><th>Label</th><th># 样本</th><th>平均值</th><th>最小值</th><th>最大值</th><th>标准偏差</th><th>异常 %</th><th>吞吐量</th><th>接收 KB&#x2F;sec</th><th>发送 KB&#x2F;sec</th><th>平均字节数</th></tr></thead><tbody><tr><td>HTTP请求</td><td>350</td><td>55</td><td>9</td><td>173</td><td>26.02</td><td>0.00%</td><td>92.86283</td><td>47.43</td><td>18.68</td><td>523</td></tr><tr><td>总体</td><td>350</td><td>55</td><td>9</td><td>173</td><td>26.02</td><td>0.00%</td><td>92.86283</td><td>47.43</td><td>18.68</td><td>523</td></tr></tbody></table><ol start="3"><li>开启 <code>OPcache</code> 开启 <code>JIT</code> 的情况</li></ol><table><thead><tr><th>Label</th><th># 样本</th><th>平均值</th><th>最小值</th><th>最大值</th><th>标准偏差</th><th>异常 %</th><th>吞吐量</th><th>接收 KB&#x2F;sec</th><th>发送 KB&#x2F;sec</th><th>平均字节数</th></tr></thead><tbody><tr><td>HTTP请求</td><td>350</td><td>53</td><td>9</td><td>180</td><td>22.5</td><td>0.00%</td><td>100.51694</td><td>51.34</td><td>20.22</td><td>523</td></tr><tr><td>总体</td><td>350</td><td>53</td><td>9</td><td>180</td><td>22.5</td><td>0.00%</td><td>100.51694</td><td>51.34</td><td>20.22</td><td>523</td></tr></tbody></table><ol start="4"><li>在开启 <code>OPcache</code> 开启 <code>JIT</code> 的情况下，根据 对 <code>sql</code> 执行顺序的分析，我发现更新的操作是最耗时且无用的，如果将这一步，移入到<code>fastcgi_finish_request()</code> 之后去执行,开启异步操作,效果如何呢？</li></ol><table><thead><tr><th>Label</th><th># 样本</th><th>平均值</th><th>最小值</th><th>最大值</th><th>标准偏差</th><th>异常 %</th><th>吞吐量</th><th>接收 KB&#x2F;sec</th><th>发送 KB&#x2F;sec</th><th>平均字节数</th></tr></thead><tbody><tr><td>HTTP请求</td><td>350</td><td>127</td><td>10</td><td>165</td><td>33.53</td><td>0.00%</td><td>47.76853</td><td>24.4</td><td>9.61</td><td>523</td></tr><tr><td>总体</td><td>350</td><td>127</td><td>10</td><td>165</td><td>33.53</td><td>0.00%</td><td>47.76853</td><td>24.4</td><td>9.61</td><td>523</td></tr></tbody></table><p>很明显，异步操作并没有减轻系统的压力（毕竟在同一个进程内）反而，使得系统的吞吐量大减，原因为 响应提前给了 <code>JMeter</code>  但是 实际上 <code>fpm</code> 进程还在被占用，从而使得 大量的请求被堵塞。数据才是最真实的。所以对于高并发与负载的系统，异步操作应该尽可能的移出主逻辑程序。</p><p>相关对比图如下所示</p><p><img src="/img/06.jpg" alt="06"></p><p><code>laravel</code> 写接口，开不开 <code>OPcache</code> 吞吐性能差距在<strong>10倍</strong>左右，而开 <code>JIT</code> 比不开 提升大概有 <code>5%-10%</code> ，当然这是测试环境，正式服的话，一个是 <code>fpm</code> 的进程数要根据监控还有服务器配置进行动态的调整，<code>OPcahe</code> 的配置项也要根据监控数据进行动态的修改，<code>laravel</code> 本身的路由与配置缓存,根据实际情况再考虑加不加，单机 <code>fpm</code> + <code>4H16G</code> <code>linux</code> 基本上能满足市面上绝大多数中小型企业的日常业务需求。</p><p>如果再进一步优化，就考虑 长连接与连接池，常驻内存的框架，其它包括<strong>GC，内存，JIT，调度</strong>，这些就要看语言特性了，没法强求。在一般业务场景中，<code>opcache+jit</code> 已经足够使用了。目前的困境在于两点，一是 <code>fpm</code> 的简易性[语言下限跟上限都比较低]与 专攻<code>web</code>的局限性，二是缺少大公司背书与就业市场&amp;舆论环境的双重恶化。</p><p>梳理完 <code>fpm</code> 的基础优化后，发现 408的4门基础课还是永远的神，应用层的东西，抽象的再厉害，一旦需要性能，底层知识你永远也避不开。</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php-fpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php8.1新特性与部分使用实践</title>
    <link href="/posts/10bdb4de/"/>
    <url>/posts/10bdb4de/</url>
    
    <content type="html"><![CDATA[<h1 id="php8-x-的实用特性与使用"><a href="#php8-x-的实用特性与使用" class="headerlink" title="php8.x 的实用特性与使用"></a>php8.x 的实用特性与使用</h1><h2 id="php8-中的实用特性"><a href="#php8-中的实用特性" class="headerlink" title="php8 中的实用特性"></a>php8 中的实用特性</h2><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><ul><li><p>1 可以指定参数传入，跳过可选参数 ； 2 指定参数是无需遵循传入顺序。</p></li><li><p>看例子把 解释起来 比较 费劲</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">response</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$data</span> = [],<span class="hljs-keyword">int</span> <span class="hljs-variable">$code</span> = <span class="hljs-number">200</span>,<span class="hljs-keyword">string</span> <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;&quot;</span></span>) : <span class="hljs-title">array</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;data&#x27;</span>=&gt; <span class="hljs-variable">$data</span>, <span class="hljs-string">&#x27;code&#x27;</span>=&gt; <span class="hljs-variable">$code</span>,<span class="hljs-string">&#x27;msg&#x27;</span> =&gt; <span class="hljs-variable">$msg</span>];<br>&#125;<br><br><span class="hljs-comment">// php7</span><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">response</span>([],<span class="hljs-number">200</span>,<span class="hljs-string">&quot;其他的提示信息&quot;</span>);<span class="hljs-comment">//非必须参数只能按顺序写</span><br><br><span class="hljs-comment">// php8以后</span><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">response</span>(<span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;其他的提示信息&quot;</span>)<span class="hljs-comment">//指定参数传入与响应</span><br></code></pre></td></tr></table></figure><h3 id="Nullsafe-运算符"><a href="#Nullsafe-运算符" class="headerlink" title="Nullsafe  运算符"></a><code>Nullsafe</code>  运算符</h3><ul><li>这个感觉是对 <code>??</code> 操作符的一个补充</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$user</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// php7</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$user</span>)&#123;<br><span class="hljs-variable">$order</span> = <span class="hljs-variable">$user</span>-&gt;<span class="hljs-title function_ invoke__">lastOrder</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$order</span>)&#123;<br>        <span class="hljs-variable">$discountAmount</span> = <span class="hljs-variable">$order</span>-&gt;<span class="hljs-title function_ invoke__">getDiscountAmount</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//对于参数对象可能为 null 并且会执行方法的情况 ?? 就没法去处理了</span><br><br><span class="hljs-comment">// php8 以后 </span><br><span class="hljs-variable">$discountAmount</span> = <span class="hljs-variable">$user</span>?-&gt;<span class="hljs-title function_ invoke__">lastOrder</span>()?-&gt;<span class="hljs-title function_ invoke__">getDiscountAmount</span>();<br></code></pre></td></tr></table></figure><h3 id="枚举类型-match-表达式"><a href="#枚举类型-match-表达式" class="headerlink" title="枚举类型 &amp; match 表达式"></a>枚举类型 &amp; <code>match</code> 表达式</h3><ul><li>枚举类型 可以替换原来 常量定义码的作用，并且更加灵活，以下是一种使用的方式</li><li><code>match</code> 替换 <code>switch</code> 可以减少 因为弱类型比较转换，带来的 <code>bug</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ResponseCode</span>: <span class="hljs-title">int</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">case</span> SUCCESS = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">case</span> SYS_ERROR = <span class="hljs-number">500</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessageByCode</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-variable">$code</span></span>): <span class="hljs-title">string</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$responseCode</span> = <span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">tryFrom</span>(<span class="hljs-variable">$code</span>);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$responseCode</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;未定义错误码&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">getMessage</span>(<span class="hljs-variable">$responseCode</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"><span class="hljs-built_in">self</span> <span class="hljs-variable">$value</span></span>): <span class="hljs-title">string</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">match</span> (<span class="hljs-variable">$value</span>) &#123;<br>            <span class="hljs-built_in">self</span>::<span class="hljs-variable constant_">SUCCESS</span> =&gt; <span class="hljs-string">&quot;成功&quot;</span>,<br>            <span class="hljs-built_in">self</span>::<span class="hljs-variable constant_">SYS_ERROR</span> =&gt; <span class="hljs-string">&quot;系统错误&quot;</span>,<br>        &#125;;<br>     &#125;<br>&#125;<br><span class="hljs-comment">// 响应值构造使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">success</span>(<span class="hljs-params"><span class="hljs-keyword">array</span>|<span class="hljs-keyword">object</span> <span class="hljs-variable">$data</span> = [], <span class="hljs-keyword">string</span> <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">int</span>|<span class="hljs-keyword">object</span> <span class="hljs-variable">$code</span> = <span class="hljs-title class_">ResponseCode</span>::<span class="hljs-variable constant_">SUCCESS</span></span>): <span class="hljs-title">JsonResponse</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$res</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">stdClass</span>();<br>    <span class="hljs-variable">$res</span>-&gt;data = <span class="hljs-variable">$data</span> ?: (<span class="hljs-keyword">object</span>)[];<br>    <span class="hljs-variable">$res</span>-&gt;code = <span class="hljs-title function_ invoke__">is_object</span>(<span class="hljs-variable">$code</span>) ? <span class="hljs-variable">$code</span>-&gt;value : <span class="hljs-variable">$code</span>;<br>    <span class="hljs-variable">$res</span>-&gt;msg = <span class="hljs-variable">$msg</span> ?: <span class="hljs-title class_">ResponseCode</span>::<span class="hljs-title function_ invoke__">getMessageByCode</span>(<span class="hljs-variable">$res</span>-&gt;code);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">response</span>()-&gt;<span class="hljs-title function_ invoke__">json</span>(<span class="hljs-variable">$res</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="php8-的-opcache-与-jit-Just-In-Time"><a href="#php8-的-opcache-与-jit-Just-In-Time" class="headerlink" title="php8  的  opcache  与 jit(Just In Time)"></a><code>php8</code>  的  <code>opcache</code>  与 <code>jit(Just In Time)</code></h2><ul><li><p><code>php </code> 的 <code>opcache</code> 对运行效率的提示是极其巨大，建议 <code>php7</code> 以上的版本 都开起来。</p></li><li><p><code>php8</code> 之后 加入了 <code>jit</code>  机制，</p><ul><li>在 <code>opcache</code> 的基础上，对运行时的 <code>opcodes</code> 进行分析，对热点 <code>opcodes</code> 直接转换成指令码，来减少 <code>VM</code> 的翻译执行工作，所以代码会越跑越快</li><li>但是这个提升，效果没有 <code>opcache</code> 开启时起飞的感觉，实测下来 大概有 5% - 10% 左右的不稳定提升</li><li>毕竟 <code>php</code> 的项目的性能瓶颈，更多的在网络跟 <code>IO</code></li></ul></li><li><p>原理简易缩略图如下</p></li></ul><p><img src="/img/05.png" alt="05"></p><ul><li><p>就不多加说明了，附一份相关配置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs php">[opcache]<br><span class="hljs-comment"># 加载扩展</span><br>zend_extension=opcache.so<br><span class="hljs-comment"># 开启扩展</span><br>opcache.enable=<span class="hljs-number">1</span><br><span class="hljs-comment"># 开启 cli 模式使用 opcahce</span><br>opcache.enable_cli=<span class="hljs-number">1</span><br><span class="hljs-comment"># opcache 共享内存大小，以兆字节为单位。 </span><br>opcache.memory_consumption=<span class="hljs-number">256</span><br><span class="hljs-comment"># 用来存储预留字符串的内存大小，以兆字节为单位</span><br>opcache.interned_strings_buffer=<span class="hljs-number">8</span><br><span class="hljs-comment"># opcache 哈希表中可存储的脚本文件数量上限。 真实的取值是在质数集合 &#123; 223, 463, 983, 1979, 3907, 7963, 16229, 32531, 65407, 130987 &#125; 中找到的第一个大于等于设置值的质数。 设置值取值范围最小值是 200，最大值在 PHP 5.5.6 之前是 100000，PHP 5.5.6 及之后是 1000000。</span><br><span class="hljs-comment"># laravel 日常  32531 就够用 项目很大的情况下用 65407或者130987</span><br>opcache.max_accelerated_files=<span class="hljs-number">100000</span><br><span class="hljs-comment"># 浪费内存的上限，以百分比计。 如果达到此上限，那么 OPcache 将产生重新启动续发事件。</span><br>opcache.max_wasted_percentage=<span class="hljs-number">5</span><br><span class="hljs-comment">#如果启用，OPcache 将在哈希表的脚本键之后附加改脚本的工作目录，以避免同名脚本冲突的问题。 禁用此选项可以提高性能，但是可能会导致应用崩溃。</span><br>opcache.use_cwd=<span class="hljs-number">1</span><br><span class="hljs-comment"># boolean 是否开启脚本文件变更验证</span><br>opcache.validate_timestamps=<span class="hljs-number">0</span><br><span class="hljs-comment"># 检查脚本时间戳是否有更新的周期，以秒为单位。 设置为 0 会导致针对每个请求， OPcache 都会检查脚本更新</span><br>opcache.revalidate_freq=<span class="hljs-number">60</span><br><span class="hljs-comment"># 不需要注解功能的 就关闭 需要注解才开启</span><br>opcache.save_comments=<span class="hljs-number">0</span><br><span class="hljs-comment">#开启jit的debug</span><br>opcache.jit_debug=<span class="hljs-number">1</span><br><span class="hljs-comment"># jit的模式 默认为 tracing</span><br>opcache.jit=<span class="hljs-number">1255</span><br><span class="hljs-comment"># jit缓存的尺寸; 默认值为 0, 也就是禁用 JIT</span><br>opcache.jit_buffer_size=<span class="hljs-number">256</span>M<br></code></pre></td></tr></table></figure></li><li><p>以上的配置在实际应用中，需要通过实际 <code>opcache</code> 的运行情况进行监控与调整。怎么监控与调整，等以后有时间再聊。</p></li><li><pre><code class="hljs">`opcode.jit`的配置值有点复杂。</code></pre><ul><li>它接受 <code>disable，on，off，trace，function</code>，和按顺序排列的 4 个不同标志的 4 位值。<ul><li>disable：在启动时完全禁用JIT功能，并且在运行时无法启用。</li><li>off：禁用，但是可以在运行时启用JIT。</li><li>on：启用tracing模式。</li><li>tracing：细化配置 的别名 1254。</li><li>function：细化配置 的别名 1205。</li></ul></li></ul></li><li><p><code>jit</code> 的四位配置顺序是：<code>CPU</code>特定的优化标志、寄存器分配、<code>JIT</code> 触发器、优化级别，官方给的推荐值为1255</p><ul><li><p><code>CPU</code>特定的优化标志：</p><ul><li><p>0 没有</p></li><li><p>1个 启用AVX指令生成</p></li></ul></li><li><p><code>R</code>-寄存器分配：</p><ul><li><p>0 不执行寄存器分配</p></li><li><p>1 使用本地线性扫描寄存器分配器</p></li><li><p>2 使用全局线性扫描寄存器分配器</p></li></ul></li><li><p><code>JIT</code>触发器：</p><ul><li>0 JIT在第一次脚本加载时的所有功能</li><li>1 首次执行时的JIT函数</li><li>2 在第一个请求时进行概要分析，并在第二个请求时编译热功能</li><li>3 动态分析并编译热功能</li><li>4 在文档注释中使用@jit标记编译函数</li><li>5 跟踪JIT</li></ul></li><li><p><code>O</code>-优化级别：</p><ul><li>0 不要准时</li><li>1 最小JIT（调用标准VM处理程序）</li><li>2 选择性VM处理程序内联</li><li>3 基于单个函数的静态类型推断的优化JIT</li><li>4 静态类型推断和调用树的优化JIT</li><li>5 基于静态类型推断和内部过程分析的优化JIT</li></ul></li></ul></li><li><p>所以 1255 指的是, 启用AVX指令生成，使用本地线性扫描寄存器分配器，跟踪JIT，基于静态类型推断和内部过程分析的优化JIT</p><ul><li>function 是C &#x3D; 1，R &#x3D; 2，T &#x3D; 0，O &#x3D; 5的别名。 1205</li><li>tracing 是C &#x3D; 1，R &#x3D; 2，T &#x3D; 5，O &#x3D; 4的别名。 1254</li></ul></li><li><p>相关参考</p><ul><li><p>jit <a href="https://php.watch/versions/8.0/JIT">https://php.watch/versions/8.0/JIT</a></p></li><li><p>opcache <a href="https://php.p2hp.com/manual/zh/opcache.configuration.php">https://php.p2hp.com/manual/zh/opcache.configuration.php</a></p></li><li><p>php8特性 </p><ul><li><a href="https://www.php.net/releases/8.1/zh.php">https://www.php.net/releases/8.1/zh.php</a></li><li><a href="https://www.php.net/releases/8.0/zh.php">https://www.php.net/releases/8.0/zh.php</a></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jit</tag>
      
      <tag>php8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go design (五) channel</title>
    <link href="/posts/964d4a55/"/>
    <url>/posts/964d4a55/</url>
    
    <content type="html"><![CDATA[<h1 id="go-channel-的设计与实现"><a href="#go-channel-的设计与实现" class="headerlink" title="go channel 的设计与实现"></a>go channel 的设计与实现</h1><p><code>golang</code> 中推崇的金句就是 <strong>不要通过共享内存来通信，要通过通信的方式来共享内存</strong>,其通信的载体就是 <code>channel</code> , <code>golang</code> 特有的关键字（数据结构），在 <code>golang</code> 中要实现并发编程成本很低， 一个 <code>go</code> 关键词 就可以启动一个 <code>goroutine</code> ，那么多个 <code>goroutine</code> 之间的数据传输该怎么处理呢？就有了 <code>channel</code> 通道，这种数据类型 来帮助在 多个 <code>goroutine</code> 进行信息传输。</p><h2 id="从实例开始-channel-介绍之旅"><a href="#从实例开始-channel-介绍之旅" class="headerlink" title="从实例开始 channel 介绍之旅"></a>从实例开始 channel 介绍之旅</h2><h3 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h3><h4 id="缓存与不带缓存的-channel"><a href="#缓存与不带缓存的-channel" class="headerlink" title="缓存与不带缓存的 channel"></a>缓存与不带缓存的 channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 带缓存的 channel</span><br><span class="hljs-keyword">var</span> s <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 特殊 channel nil</span><br><br>fmt.Println(c, s) <span class="hljs-comment">// 0xc000086060 &lt;nil&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>make</code> 出来的 <code>chan</code> 为 实际结构地址的引用， 而 声明的 <code>channel 为 nil 则永久性的读写堵塞, 且不能被 close 不然会 panic</code></li><li>不带缓存的 <code>channel</code><ul><li>进行读操作的时候，如果无数据 会进入堵塞状态，直到协程内有数据被写入</li><li>进行写操作的时候，如果无协程在读取数据，也会进入堵塞状态，直到数据被读取</li></ul></li><li>带缓存 的 <code>channel</code><ul><li>进行写操作的时候，如果缓存还有空间则不会被堵塞，否则也会堵塞</li><li>进行读操作的时候，如果无数据会进入堵塞状态，直到协程内有数据被写入</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//堵塞 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>ok := &lt;-c<br>fmt.Println(ok)<br>&#125;()<br><br>c &lt;- <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//带缓冲 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// 带缓存的 channel</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span>&#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>ok := &lt;-c<br>fmt.Println(ok)<br>&#125;<br>&#125;()<br><br>c &lt;- <span class="hljs-number">1</span><br>c &lt;- <span class="hljs-number">2</span><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="channel-的两个属性"><a href="#channel-的两个属性" class="headerlink" title="channel 的两个属性"></a>channel 的两个属性</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 带缓存的 channel</span><br>fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<span class="hljs-comment">// 0  2 </span><br></code></pre></td></tr></table></figure><ul><li><code>len()</code> 为当前 <code>channel</code> 已经使用的缓存量</li><li><code>cap()</code> 为 当前 <code>channel</code> 最大的缓存量</li></ul><h4 id="select-为多-channel-处理而生"><a href="#select-为多-channel-处理而生" class="headerlink" title="select 为多 channel 处理而生"></a>select 为多 <code>channel</code> 处理而生</h4><p>在上述的使用中 如果在 一个协程中 使用多个 channel<code>，如果一个 </code>channel<code>堵塞 ，那么代码就没法 执行到 下一个</code>channel&#96; ，从而导致运行时 死锁</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br>d := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        ok := &lt;-c<br>        ok2 := &lt;-d<br>        fmt.Println(ok,ok2)<br>    &#125;<br>&#125;()<br>d &lt;- <span class="hljs-number">1</span><br>c &lt;- <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br><span class="hljs-comment">//fatal error: all goroutines are asleep - deadlock!</span><br></code></pre></td></tr></table></figure><p>这种情况下如果不知道 <code>c,d</code> 谁会先发送数据的情况 就会 直接报错，相互死锁，程序中断。</p><ul><li><p>通过 select 来对多个channel 进行收发控制 应运而生</p></li><li><p>select 的特性</p><ul><li><code>select</code> 无 <code>case</code> 属性时，会直接堵塞代码执行，切记勿在主协程中使用，不然直接死锁</li><li><code>select</code> 只有一个 <code>case channel</code> 时，会一直堵塞，直到有数据进入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> ok := &lt;-c :<br>        fmt.Println(ok)<br>    &#125;<br>&#125;()<br>c &lt;- <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br></code></pre></td></tr></table></figure><ul><li><code>select</code> 能在 <code>channel</code> 上进行非阻塞的收发操作；如果 存在 <code>case default</code> 无数据直接进入 <code>default case</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ok := &lt;-c:<br>fmt.Println(ok)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;未接受到数据&quot;</span>)<br>&#125;<br>&#125;()<br><br>c &lt;- <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br></code></pre></td></tr></table></figure><ul><li>select 在遇到多个 channel 同时响应时，会随机执行一种情况； 这里用 同一个 <code>channel</code> 不同 <code>channel</code> 的同一时刻，效果也是类似，只会有一个分支被读取与执行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ok := &lt;-c:<br>fmt.Println(<span class="hljs-string">&quot;case 1&quot;</span>, ok)<br><span class="hljs-keyword">case</span> ok := &lt;-c:<br>fmt.Println(<span class="hljs-string">&quot;case 2&quot;</span>, ok)<br><span class="hljs-keyword">case</span> ok := &lt;-c:<br>fmt.Println(<span class="hljs-string">&quot;case 3&quot;</span>, ok)<br>&#125;<br>&#125;()<br><br>c &lt;- <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-comment">// 多次响应 的结果不一致</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="for-range-与-channel-的配合使用"><a href="#for-range-与-channel-的配合使用" class="headerlink" title="for range 与 channel 的配合使用"></a><code>for range</code> 与 <code>channel</code> 的配合使用</h4><pre><code class="hljs"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 带缓存的 channel</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> val := <span class="hljs-keyword">range</span> c &#123;<br>            fmt.Println(val)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        c &lt;- i<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span> &#123;<br>            <span class="hljs-built_in">close</span>(c)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br><br>    time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><ul><li>对于 <code>for range</code> 进行迭代 的 <code>channel</code> 除非 <code>channel</code> 被关闭，不然会一直堵塞下去</li><li>对于 关闭后 <code>channel</code> 内还存在未处理完的数据情况，也会被读取出来</li></ul><h4 id="close-函数与-channel-的关闭"><a href="#close-函数与-channel-的关闭" class="headerlink" title="close() 函数与 channel 的关闭"></a><code>close()</code> 函数与 <code>channel</code> 的关闭</h4><ul><li><p><code>close()</code> 只是相对于 发送方的概念，<code>close</code> 之后的 <code>channel</code> 不能进行发送操作，但是从 <code>channel </code>中读取数据的行为是允许的，存在数据时，拿到的是数据，不存在时 ，拿到的是 零值，且不会堵塞</p></li><li><p>但是 <code>close</code> 函数不能针对与一个 <code>channel</code> 执行多次,  不然 就会 出现 <code>panic: close of closed channel</code> 的运行时错误</p></li><li><p><code>close</code> 之后的 <code>channel</code> ，再进行发送会出现 <code>panic: send on closed channel</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 带缓存的 channel</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> val := <span class="hljs-keyword">range</span> c &#123;<br>            fmt.Println(val)<br>        &#125;<br><br>        value, ok := &lt;-c<br>        fmt.Println(value, ok) <span class="hljs-comment">// 0 false</span><br>    &#125;()<br><br>    c &lt;- <span class="hljs-number">0</span><br>    c &lt;- <span class="hljs-number">1</span><br>    <span class="hljs-built_in">close</span>(c)<br>    time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="用法-超时控制"><a href="#用法-超时控制" class="headerlink" title="用法-超时控制"></a>用法-超时控制</h4><ul><li><p>使用 <code>time.After()</code> 来实现 延时的 <code>channel</code> 信息发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 不带缓存的 channel</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> ok := &lt;-c:<br>            fmt.Println(ok)<br>        <span class="hljs-keyword">case</span> &lt;-time.After(time.Second * <span class="hljs-number">1</span>):<br>            fmt.Println(<span class="hljs-string">&quot;一秒后超时&quot;</span>)<br>        &#125;<br>    &#125;()<br>    time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="用法-控制并发执行协程数量（协程池）"><a href="#用法-控制并发执行协程数量（协程池）" class="headerlink" title="用法-控制并发执行协程数量（协程池）"></a>用法-控制并发执行协程数量（协程池）</h4><ul><li><p>使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    limit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 控制同时执行的 goroutine 个数</span><br><br>    work := [<span class="hljs-number">100</span>]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> work &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(k <span class="hljs-type">int</span>)</span></span> &#123;<br>            limit &lt;- <span class="hljs-number">1</span><br>             w(k)<br>            &lt;-limit<br>        &#125;(k)<br>    &#125;<br><br>    time.Sleep(time.Second * <span class="hljs-number">20</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">w</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>    fmt.Println(<span class="hljs-string">&quot;deal task&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="用法-生产消费模型"><a href="#用法-生产消费模型" class="headerlink" title="用法-生产消费模型"></a>用法-生产消费模型</h4><ul><li><p>用于解耦合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 消费</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> s &#123;<br>            <span class="hljs-keyword">go</span> work(v)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 生产</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        s &lt;- i<br>    &#125;<br><br>    time.Sleep(time.Second * <span class="hljs-number">20</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(taskId <span class="hljs-type">int</span>)</span></span> &#123;<br>    time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>    fmt.Println(<span class="hljs-string">&quot;deal task &quot;</span>, taskId)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="golang-中的-设计与实现"><a href="#golang-中的-设计与实现" class="headerlink" title="golang 中的 设计与实现"></a>golang 中的 设计与实现</h2><p>到目前为止，我们把 <code>channel</code> 的基础功能 过了一遍, 感觉上确实是挺复杂与强大的，接下来会去看看 <code>channel</code> 的数据结构，跟写入，读取的流程，通过这些流程，更好的理解为什么，<code>channel</code> 会有这样的特性.</p><h3 id="channel-实现的数据结构"><a href="#channel-实现的数据结构" class="headerlink" title="channel 实现的数据结构"></a>channel 实现的数据结构</h3><ul><li>源码中的定义</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime/chan.go</span><br><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-type">uint</span>           <span class="hljs-comment">// total data in the queue</span><br>dataqsiz <span class="hljs-type">uint</span>           <span class="hljs-comment">// size of the circular queue</span><br>buf      unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span><br>elemsize <span class="hljs-type">uint16</span><br>closed   <span class="hljs-type">uint32</span><br>elemtype *_type <span class="hljs-comment">// element type</span><br>sendx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// send index</span><br>recvx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// receive index</span><br>recvq    waitq  <span class="hljs-comment">// list of recv waiters</span><br>sendq    waitq  <span class="hljs-comment">// list of send waiters</span><br><br><span class="hljs-comment">// lock protects all fields in hchan, as well as several</span><br><span class="hljs-comment">// fields in sudogs blocked on this channel.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Do not change another G&#x27;s status while holding this lock</span><br><span class="hljs-comment">// (in particular, do not ready a G), as this can deadlock</span><br><span class="hljs-comment">// with stack shrinking.</span><br>lock mutex<br>&#125;<br><br><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>first *sudog<br>last  *sudog<br>&#125;<br><br><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// The following fields are protected by the hchan.lock of the</span><br><span class="hljs-comment">// channel this sudog is blocking on. shrinkstack depends on</span><br><span class="hljs-comment">// this for sudogs involved in channel ops.</span><br><br>g *g<br><br>next *sudog<br>prev *sudog<br>elem unsafe.Pointer <span class="hljs-comment">// data element (may point to stack)</span><br><br><span class="hljs-comment">// The following fields are never accessed concurrently.</span><br><span class="hljs-comment">// For channels, waitlink is only accessed by g.</span><br><span class="hljs-comment">// For semaphores, all fields (including the ones above)</span><br><span class="hljs-comment">// are only accessed when holding a semaRoot lock.</span><br><br>acquiretime <span class="hljs-type">int64</span><br>releasetime <span class="hljs-type">int64</span><br>ticket      <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// isSelect indicates g is participating in a select, so</span><br><span class="hljs-comment">// g.selectDone must be CAS&#x27;d to win the wake-up race.</span><br>isSelect <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// success indicates whether communication over channel c</span><br><span class="hljs-comment">// succeeded. It is true if the goroutine was awoken because a</span><br><span class="hljs-comment">// value was delivered over channel c, and false if awoken</span><br><span class="hljs-comment">// because c was closed.</span><br>success <span class="hljs-type">bool</span><br><br>parent   *sudog <span class="hljs-comment">// semaRoot binary tree</span><br>waitlink *sudog <span class="hljs-comment">// g.waiting list or semaRoot</span><br>waittail *sudog <span class="hljs-comment">// semaRoot</span><br>c        *hchan <span class="hljs-comment">// channel</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>可以看出来底层的循环队列主要由 <code>qcount</code> <code>dataqsiz</code>、<code>buf</code>、<code>sendx</code>、<code>recvx</code> 构建</p><ul><li><code>qcount</code>    <code>channel</code> 的总长度</li><li><code>dataqsiz</code> 循环队列的长度</li><li><code>buf</code>         缓冲区数据指针</li><li><code>sendx</code>      发送操作处理到的位置</li><li><code>recvx</code>      接收操作处理到的位置</li></ul></li><li><p><code>recvq</code> <code>sendq</code> 代表 等待中的 <code>goroutine</code> 链表</p></li><li><p><code>runtime.makechan()</code> 为创建 <code>channel</code> 的函数，缓存与非缓存 一个是底层分配空间大小的区别，二是对应的 <code>elemsize qcount dataqsiz</code> 属性值不同</p></li></ul><h3 id="channel-的发送"><a href="#channel-的发送" class="headerlink" title="channel 的发送"></a>channel 的发送</h3><ul><li>发送的三种情况<ul><li>如果当前 <code>channel</code> 的 <code>recvq</code> 上存在已经被阻塞的 <code>goroutine</code>，那么会直接将数据发送给当前 <code>goroutine</code> 并将其设置成 可运行状态；</li><li>如果 <code>channel</code> 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 <code>sendx</code> 所在的位置上；</li><li>如果不满足上面的两种情况，会创建一个 <code>runtime.sudog</code> 结构并将其加入 <code>channel</code> 的 <code>sendq</code> list中，当前 <code>goroutine</code> 也会<strong>陷入阻塞</strong>等待其他的协程从 <code>channel</code> 接收数据；</li></ul></li><li>发送数据时两个会触发 <code>goroutine</code> 调度的时机：<ul><li><code>recvq</code> 上存在已经被阻塞的 <code>goroutine</code>,立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度；</li><li>找到接收方并且缓冲区已经满了，这时会将自己加入 <code>channel</code> 的 <code>sendq</code> 队列并调用 <code>runtime.goparkunlock</code> 触发 <code>goroutine</code> 的调度让出处理器的使用权；</li></ul></li></ul><h3 id="channel-的接受"><a href="#channel-的接受" class="headerlink" title="channel 的接受"></a>channel 的接受</h3><ul><li><p>接受主要就是 调用  <code>runtime.chanrecv</code> </p></li><li><p>接受的几种情况</p><ul><li><p>从一个 <code>空（nil) channel</code> 接收数据时会直接调用 <code>runtime.gopark</code> 让出处理器的使用权</p></li><li><p><code>channel</code> 被关闭, 且缓冲区中不存在任何数据，那么会清除数据并立刻返回。</p></li><li><p>channel 正常时</p><ul><li><p><code>sendq</code> 队列中存在挂起的 <code>goroutine</code>，会将 <code>recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上，并将 <code>sendq</code> 队列中 <code>goroutine</code> 的数据拷贝到缓冲区；</p></li><li><p>缓冲区中存在数据，直接读取 <code>recvx</code> 索引对应的数据；</p></li><li><p>默认情况下会挂起当前的 <code>goroutine</code>，将 <code>runtime.sudog</code> 结构加入<code>recvq</code> 队列并陷入休眠等待调度器的唤醒；</p></li></ul></li></ul></li><li><p>调度时机</p><ul><li>当 channel 为空(nil) 时；</li><li>当缓冲区中不存在数据并且也不存在数据的发送者时；</li></ul></li></ul><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><ul><li><code>close</code> 函数先上一把大锁，接着把所有挂在这个 channel 上的 <code>recvq</code> 和 <code>sendq</code> 全都连成一个 <code>sudog</code> 链表，再解锁。最后，再将所有的 <code>sudog</code> 全都唤醒</li><li>所以 当 存在有 <code>sendq</code> 被唤醒而 <code>chan</code> 本身被关闭时候，会直接被 <code>panic</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>《go语言设计与实现》</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go design (四) string</title>
    <link href="/posts/fa0b243f/"/>
    <url>/posts/fa0b243f/</url>
    
    <content type="html"><![CDATA[<h1 id="golang-中-字符串-的设计"><a href="#golang-中-字符串-的设计" class="headerlink" title="golang 中 字符串 的设计"></a>golang 中 字符串 的设计</h1><p>字符串是由字符组成的数组，C 语言中的字符串使用字符数组 <code>char[]</code> 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，<code>Go</code> 语言中的字符串为一个只读的字节数组。</p><h2 id="golang-中对于-字符串-的设计"><a href="#golang-中对于-字符串-的设计" class="headerlink" title="golang 中对于 字符串 的设计"></a><code>golang</code> 中对于 字符串 的设计</h2><h3 id="string-数据结构"><a href="#string-数据结构" class="headerlink" title="string 数据结构"></a>string 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// reflect/value.go </span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// slice 的定义</span><br><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>Cap  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据源码来看 其实 <code>string</code> 跟 <code>slice</code> 除了 少了 一个 <code>cap</code> 属性，其他的都一致,所以我们经常会说字符串是一个只读的切片类型</li><li>字符串作为只读的类型，我们无法直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上的写入操作都是通过拷贝实现的。</li></ul><h3 id="修改，拼接与类型转换"><a href="#修改，拼接与类型转换" class="headerlink" title="修改，拼接与类型转换"></a>修改，拼接与类型转换</h3><h4 id="string-的修改"><a href="#string-的修改" class="headerlink" title="string 的修改"></a>string 的修改</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;string&quot;</span><br>fmt.Println(reflect.TypeOf(str[<span class="hljs-number">0</span>]).Name())<span class="hljs-comment">// uint8 </span><br><span class="hljs-comment">//也就是说 通过 slice 方式去读取的是每一字节的数据</span><br><span class="hljs-comment">// 对于 中文获取 长字节 的字符，不能直接通过这种方式去获取</span><br><br><span class="hljs-comment">// 会触发编译错误 string 是只读不变的</span><br><span class="hljs-comment">// str[0] = &#x27;0&#x27;  cannot assign to str[0] (strings are immutable) </span><br><br>s1 := []<span class="hljs-type">byte</span>(str)<br>s1[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;o&#x27;</span><br>fmt.Println(str,<span class="hljs-type">string</span>(s1))<span class="hljs-comment">// string soring</span><br></code></pre></td></tr></table></figure><ul><li>修改只能通过 <code>[]byte</code> 进行类型转换后，才能对 <code>slice</code> 进行修改，从 结果来看 ，类型转换是直接 <code>copy</code> 来处理的，这也会对性能造成影响</li></ul><h4 id="string-的拼接"><a href="#string-的拼接" class="headerlink" title="string 的拼接"></a>string 的拼接</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;string&quot;</span><br><span class="hljs-comment">// 方式一</span><br>str = str + <span class="hljs-string">&quot;233&quot;</span><br><span class="hljs-comment">// 方式二</span><br>str = strings.Join([]<span class="hljs-type">string</span>&#123;str, <span class="hljs-string">&quot;233&quot;</span>&#125;, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 方式三</span><br>str = fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, str, <span class="hljs-string">&quot;233&quot;</span>)<br><span class="hljs-comment">// 方式四</span><br><span class="hljs-keyword">var</span> build strings.Builder<br>build.WriteString(str)<br>build.WriteString(<span class="hljs-string">&quot;233&quot;</span>)<br>str = build.String()<br><span class="hljs-comment">// 方式五</span><br><span class="hljs-keyword">var</span> bt bytes.Buffer<br>bt.WriteString(str)<br>bt.WriteString(<span class="hljs-string">&quot;233&quot;</span>)<br>str = bt.String()<br></code></pre></td></tr></table></figure><ul><li><code>+</code> 连接适用于短小的、常量字符串（明确的，非变量），编译器会进行优化，综合最为推荐的为 <code>strings.builder </code></li></ul><h4 id="string-的类型转换"><a href="#string-的类型转换" class="headerlink" title="string 的类型转换"></a>string 的类型转换</h4><ul><li><code>string</code> 主要 转换为 <code>[]byte</code> 则会调用底层的 <code>stringtoslicebyte()</code> 方法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//runtime/string.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicebytetostring</span><span class="hljs-params">(buf *tmpBuf, ptr *<span class="hljs-type">byte</span>, n <span class="hljs-type">int</span>)</span></span> (str <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Turns out to be a relatively common case.</span><br><span class="hljs-comment">// Consider that you want to parse out data between parens in &quot;foo()bar&quot;,</span><br><span class="hljs-comment">// you find the indices and convert the subslice to string.</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racereadrangepc(unsafe.Pointer(ptr),<br><span class="hljs-type">uintptr</span>(n),<br>getcallerpc(),<br>funcPC(slicebytetostring))<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &#123;<br>msanread(unsafe.Pointer(ptr), <span class="hljs-type">uintptr</span>(n))<br>&#125;<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>p := unsafe.Pointer(&amp;staticuint64s[*ptr])<br><span class="hljs-keyword">if</span> sys.BigEndian &#123;<br>p = add(p, <span class="hljs-number">7</span>)<br>&#125;<br>stringStructOf(&amp;str).str = p<br>stringStructOf(&amp;str).<span class="hljs-built_in">len</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> p unsafe.Pointer<br><span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; n &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>p = unsafe.Pointer(buf)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p = mallocgc(<span class="hljs-type">uintptr</span>(n), <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)<br>&#125;<br>stringStructOf(&amp;str).str = p<br>stringStructOf(&amp;str).<span class="hljs-built_in">len</span> = n<br>memmove(p, unsafe.Pointer(ptr), <span class="hljs-type">uintptr</span>(n))<br><span class="hljs-keyword">return</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringtoslicebyte</span><span class="hljs-params">(buf *tmpBuf, s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br><span class="hljs-keyword">var</span> b []<span class="hljs-type">byte</span><br><span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>*buf = tmpBuf&#123;&#125;<br>b = buf[:<span class="hljs-built_in">len</span>(s)]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>b = rawbyteslice(<span class="hljs-built_in">len</span>(s))<br>&#125;<br><span class="hljs-built_in">copy</span>(b, s)<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>拼接和类型转换等操作时会存在性能的损耗，遇到需要极致性能的场景要减少类型转换的次数</li></ul><h3 id="相关的小问题"><a href="#相关的小问题" class="headerlink" title="相关的小问题"></a>相关的小问题</h3><h4 id="rune-和-byte-有什么区别？"><a href="#rune-和-byte-有什么区别？" class="headerlink" title="rune 和 byte 有什么区别？"></a><code>rune</code> 和 <code>byte</code> 有什么区别？</h4><ul><li><code>rune</code>  是 <code>int32</code> 的别名  4字节， <code>byte</code> 是 <code>int8</code> 的别名  1字节</li><li>所以 <code>byte</code>  只能 表示 <code>ascii</code> 的字符 <code>rune</code>  可以 表示 <code>Unicode</code> 字符</li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>《go语言设计与实现》</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go design (三) map</title>
    <link href="/posts/42a01fe6/"/>
    <url>/posts/42a01fe6/</url>
    
    <content type="html"><![CDATA[<h1 id="golang-中-哈希表-map-的实现"><a href="#golang-中-哈希表-map-的实现" class="headerlink" title="golang 中 哈希表 map 的实现"></a>golang 中 哈希表 map 的实现</h1><p>哈希表 在 各种语言中有字典，映射 的称呼 ，本质上解决的是 <code>key =&gt; value</code> 键值对之间映射关系，因为其读写 <code>O(1)</code> 的复杂度，性能非常优秀，而被广泛使用。</p><h2 id="哈希表-的设计原理"><a href="#哈希表-的设计原理" class="headerlink" title="哈希表 的设计原理"></a>哈希表 的设计原理</h2><p>如何实现一个优秀的哈希表 ，关键点在于 哈希函数与冲突解决方案。理想的哈希函数 输出范围要大于输入范围，但实际上我们做不到，工程上优秀的 hash 函数，要保证输出均匀分布,复杂度接近 <code>O(1)</code>, 而糟糕的 hash 函数 会导致输出不均匀分布，产生大量的冲突则复杂度可能会退化至 <code>O(n)</code></p><h3 id="解决冲突的两种方法"><a href="#解决冲突的两种方法" class="headerlink" title="解决冲突的两种方法"></a>解决冲突的两种方法</h3><p><img src="/img/13.png" alt="开放寻址法set示意图"></p><ul><li>开放寻址法（依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中）<ul><li>要求底层实现为数组<ul><li>写入数据<ul><li>向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置。</li></ul></li><li>读取数据<ul><li>当需要查找某个键对应的值时，会从索引的位置开始线性探测数组，找到目标键值对或者空内存就意味着这一次查询操作的结束。</li></ul></li></ul></li><li>开放寻址法中对性能影响最大的是装载因子，<ul><li><strong>装载因子 &#x3D; 数组中元素的数量&#x2F;数组大小</strong></li><li>随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 O(n) 的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。</li></ul></li></ul></li></ul><p><img src="/img/14.png" alt="拉链法set示意图"></p><ul><li><strong>拉链法</strong> (一般会使用数组加上链表，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，我们可以将它看成可以扩展的二维数组)<ul><li>拉链法会使用链表,数组作为哈希底层的数据结构<ul><li>写入数据<ul><li>先对key 进行hash 后取模，根据取模获取的值 去访问对应的桶</li><li>遍历当前桶中的链表<ul><li>找到键相同的键值对 — 更新键对应的值；</li><li>没有找到键相同的键值对 — 在链表的末尾追加新的键值对；</li></ul></li></ul></li></ul></li><li><strong>计算哈希</strong>、<strong>定位桶</strong>和<strong>遍历链表</strong>三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：<ul><li><code>装载因子 = 元素数量/桶数量</code></li><li>拉链法的装载因子越大，哈希的读写性能就越差。理想情况下装载因子都不会超过 1。</li><li><strong>当哈希表的装载因子较大时会触发哈希的扩容</strong>，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。</li></ul></li></ul></li><li>对比两种方式，我们发现，拉链法通过引入中间层 bucket 来减少索引值不同情况下对于值存储的影响，而开放寻址法结构简单,不同 索引间会相互影响。所以市面上大多数的编程语言会使用拉链法来实现 map，包括 php golang …</li></ul><h2 id="golang-中-的-map-的实现"><a href="#golang-中-的-map-的实现" class="headerlink" title="golang 中 的 map 的实现"></a><code>golang</code> 中 的 <code>map</code> 的实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><code>golang</code> 使用了拉链法来实现哈希表， 以及多种数据结构来构成 <code>map</code> [<code>hmap</code> 主结构 , <code>bmap</code> 存储单元桶]</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime.map  </span><br><span class="hljs-comment">// A header for a Go map. 核心结构</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span><br><span class="hljs-comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span><br>count     <span class="hljs-type">int</span> <span class="hljs-comment">// # 当前哈希表中的元素数量</span><br>flags     <span class="hljs-type">uint8</span><br>B         <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 表示当前哈希表持有的 buckets 数量，都是2的倍数，所以 len(buckets) == 2^B</span><br>noverflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// 溢出桶的大概数目</span><br>hash0     <span class="hljs-type">uint32</span> <span class="hljs-comment">// 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入</span><br>    <br>buckets    unsafe.Pointer <span class="hljs-comment">// 当前桶的位置 可能为 nil</span><br>oldbuckets unsafe.Pointer <span class="hljs-comment">// 哈希在扩容时用于保存之前 buckets 地址的字段，它的大小是当前 buckets 的一半</span><br>nevacuate  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span><br><br>extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br><br><span class="hljs-comment">// mapextra holds fields that are not present on all maps.</span><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// If both key and elem do not contain pointers and are inline, then we mark bucket</span><br><span class="hljs-comment">// type as containing no pointers. This avoids scanning such maps.</span><br><span class="hljs-comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets</span><br><span class="hljs-comment">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.</span><br><span class="hljs-comment">// overflow and oldoverflow are only used if key and elem do not contain pointers.</span><br><span class="hljs-comment">// overflow contains overflow buckets for hmap.buckets.</span><br><span class="hljs-comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.</span><br><span class="hljs-comment">// The indirection allows to store a pointer to the slice in hiter.</span><br>overflow    *[]*bmap<br>oldoverflow *[]*bmap<br><br><span class="hljs-comment">// nextOverflow holds a pointer to a free overflow bucket.</span><br>nextOverflow *bmap<br>&#125;<br><br><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// tophash generally contains the top byte of the hash value</span><br><span class="hljs-comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="hljs-comment">// tophash[0] is a bucket evacuation state instead.</span><br>tophash [bucketCnt]<span class="hljs-type">uint8</span><br><span class="hljs-comment">// Followed by bucketCnt keys and then bucketCnt elems.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span><br><span class="hljs-comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="hljs-comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="hljs-comment">// Followed by an overflow pointer.</span><br>&#125;<br><br><span class="hljs-comment">// 编译期间才会动态 生成 真正的结构</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span>&#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-type">uintptr</span><br>    overflow <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据源码的定义 ，我们得出下面的相关结构的关联关系<ul><li><code>hmap-&gt;buckets-&gt;bmap-&gt;overflow-&gt;bmap</code></li></ul></li><li><code>bmap</code> 详情<ul><li><code>tophash</code> 存储了键的哈希的高 8 位<ul><li>高 8 位会决定 key 到底落入桶内的哪个位置</li></ul></li><li><code>keys values</code> 结构表明 <code>map</code> 的<code>key value</code> 是 分开存储的，节省 <code>padding</code></li><li>每一个 <code>bmap</code> 最多装 8 个 key，（一个桶内最多有8个位置）<ul><li>随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，</li><li>不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</li></ul></li><li>哈希计算后，哈希结果是“一类”的  key 会落入同一个桶</li></ul></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li><p>字面量的方式创建 map</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>底层默认还是使用 <code>make</code> 去创建 然后初始化 <code>hmap</code> 的一些属性</li></ul></li><li><p><code>make</code> 创建 <code>map</code></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="读、写、删、扩容操作"><a href="#读、写、删、扩容操作" class="headerlink" title="读、写、删、扩容操作"></a>读、写、删、扩容操作</h3><h4 id="读，写"><a href="#读，写" class="headerlink" title="读，写"></a>读，写</h4><ul><li><code>hash</code> 计算<ul><li>会检测 <code>cpu</code> 是否支持 <code>aes</code>，如果支持，则使用 <code>aes hash</code>，否则使用 <code>memhash</code></li><li><code>key</code> 经过哈希计算后得到哈希值，共 <code>64</code> 个 <code>bit</code> 位</li></ul></li><li><strong>定位</strong>过程<ul><li>计算它到底要落在哪个桶时，只会用到最后 <strong><code>B</code></strong> 个 <strong><code>bit</code></strong> 位。</li><li>还记得前面提到过的 <strong>B</strong> 吗？如果 **<code>B = 5</code>**，那么桶的数量，也就是 <strong>buckets 数组的长度是 2^5 &#x3D; 32</strong></li><li><code>10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</code></li><li><strong>前 8 位</strong> 用于计算(<code>bmap.topbits</code>) 在哪存放，<strong>后 B 位</strong> 用于 计算 <code>map</code> 会被分在 哪一个 <strong>bucket</strong> 内</li><li>比如 <code>01010</code> 就去找 第 10  号的 <strong>bucket</strong> ,然后会 去 <strong>bucket</strong> 内 找到 <code>bmap.topbits</code> 这个数组 有没有 <code>10010111</code> 也就是 <code>151</code> 这个值<ul><li>如果 找到了 151 这个值 就用 <code>bmap.topbits</code> 值的 <strong>key</strong>  去读取  <code>bmap.values[key] </code> 来获取正在的值，进行响应 </li><li>如果没有找到 151 而  <code>mapextra.overflow </code> 是存在的 ，那么就去去读取 额外的  <code>bmap </code> 去找</li></ul></li></ul></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li>删除使用 <code>delete</code> 函数 ，此函数的唯一目的就是为了删除 <code>map</code> 中的数据</li><li><code>func delete(m map[Type]Type1, key Type)</code></li><li>删除操作同样是<strong>hash &#x3D;&gt;定位 &#x3D;&gt;找到 <code>bmap.topbits.key</code></strong> 。找到后，对 <code>bmap.keys</code> 与 <code>bmap.values</code> 进行“清零”操作。</li></ul><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul><li><p>最理想的方式为 一个 <strong>bucket</strong> 装一个 <code>key =&gt; value</code> , 复杂度<code>O（1</code>）但是对于空间的消耗太大了</p></li><li><p><code>golang</code> 中 一个 <strong>bucket</strong> 装 8个 <strong>key</strong>, 也是时间换空间的做法</p></li><li><p>为了避免 <strong>key</strong> 都落在了同一个 <strong>bucket</strong> 里，导致 <strong>hash</strong> 表退化成链表效率降为 O(n)</p><ul><li>我们用一个指标来衡量效率的情况，这就是 <strong>装载因子</strong> </li><li><strong><code>loadFactor := count / (2^B)</code></strong><ul><li><code>count</code> 为 <code>map</code> 的元素个数</li><li><code>2^B</code> 为 <code>buckets</code> 的数量</li></ul></li></ul></li><li><p>扩容的条件</p><ul><li><p>装载因子超过阈值，源码里定义的阈值是 <strong>6.5</strong>。</p><ul><li>因为 一个 <strong>buckets</strong> 只有 8 个键位，装满则为 8，当然 装满了，也能往 overflow.bmap 里面继续放，也就是说负载因子可以大于8</li><li>当 <code>loadFactor</code> 大于 <strong>6.5</strong> 的时候，就说明 <code>map</code> 的键位快要被用完了</li></ul></li><li><p><strong>tooManyOverflowBuckets</strong>  使用了太多溢出桶 而装载因子很小</p><ul><li><strong>overflow bucket</strong> 数特别多，说明很多 <strong>bucket</strong>  都没装满。</li><li>解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。</li><li>这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。</li><li>结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升</li></ul></li></ul></li><li><p>扩容的执行</p><ul><li>对于 装载因子大于 6.5 的情况，<ul><li>将 B 的值 +1 实际值扩大两倍 <ul><li>比如 B 从 5 变成了 6，因此需要分流 原来通过 低5位来判定走哪一个bucket 的，现在看低 6 位决定 key 落在哪个 bucket。</li><li>这称为 <code>rehash</code></li></ul></li></ul></li><li>而对于过多 <code>overflow</code> <ul><li>是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密</li><li>缺点为极端情况<ul><li>插入 map 的 key 哈希都一样，就会落到同一个 bucket 里，</li><li>超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。</li><li>移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code></li></ul></li></ul></li><li><code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 <strong>buckets</strong>，并将老的 <strong>buckets</strong> 挂到了 <strong>oldbuckets</strong> 字段上。</li><li>真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 <code>mapassign()</code> 和 <code>mapdelete()</code> 函数中。</li><li>也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。</li><li>先检查 <code>oldbuckets</code> 是否搬迁完毕，【具体来说就是检查 <code>oldbuckets</code> 是否为 <strong>nil</strong>】</li></ul></li></ul><h3 id="遍历与-map-的无序性"><a href="#遍历与-map-的无序性" class="headerlink" title="遍历与 map 的无序性"></a>遍历与 map 的无序性</h3><ul><li>遍历的的主要操作在 源码 <code>runtime/map.go mapiterinit</code> 函数实现</li><li>无序性主要体现在下面这段源码</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// decide where to start 生成随机数</span><br>r := <span class="hljs-type">uintptr</span>(fastrand())<br><span class="hljs-keyword">if</span> h.B &gt; <span class="hljs-number">31</span>-bucketCntBits &#123;<br>r += <span class="hljs-type">uintptr</span>(fastrand()) &lt;&lt; <span class="hljs-number">31</span><br>&#125;<br><span class="hljs-comment">// 从哪个 bucket 开始遍历</span><br>it.startBucket = r &amp; bucketMask(h.B)<br><span class="hljs-comment">// 从 bucket 的哪个 cell 开始遍历</span><br>it.offset = <span class="hljs-type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><ul><li>也就说 在引入 渐进式 <code>rehash</code> 之后，你没法 直接对 <code>buckets.[]bmap</code> 进行遍历，必然要先去看看 <code>oldbuckets</code> 有没有迁移完，再去遍历新的 <code>buckets.[]bmap</code></li><li>为了防止有人用 <code>map</code> 的遍历顺序这个特性，开发人员 煞费苦心，直接引入了 随机数来引入无序性</li><li>那我们能不能 用 <code>map</code> 的无序特点进行一些逻辑处理，我觉得不可行，从源码可以看出，无序仅限于入口的无序性，样本较少的情况下，这个随机性很弱。部分元素会出现一致性</li></ul><h3 id="关于-map-的几个小问题"><a href="#关于-map-的几个小问题" class="headerlink" title="关于 map 的几个小问题"></a>关于 map 的几个小问题</h3><h4 id="map-可以-用-float-做-key-吗？"><a href="#map-可以-用-float-做-key-吗？" class="headerlink" title="map 可以 用 float 做 key 吗？"></a>map 可以 用 float 做 key 吗？</h4><ul><li>大前提是 <code>map</code> 可以用什么类型当 <code>key</code>  <ul><li>只要是 可以进行 <code>==</code> 作为判定的 类型都能当作 <code>key</code></li><li><code>slice，map，functions</code> 这几个类型不能当作 <code>key</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">float64</span>]<span class="hljs-type">int</span>)<br>m[<span class="hljs-number">2.4</span>] = <span class="hljs-number">2</span><br><br>f1 := <span class="hljs-number">2.4</span><br>f2 := <span class="hljs-number">2.4000000000000000000000001</span><br>fmt.Println(f1 == f2)                       <span class="hljs-comment">// true</span><br>fmt.Println(m[<span class="hljs-number">2.4000000000000000000000001</span>]) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ul></li><li>所以 用 <code>float</code> 会存在隐患，不建议使用</li></ul><h4 id="map-可以边遍历-边删除-边写入-吗？"><a href="#map-可以边遍历-边删除-边写入-吗？" class="headerlink" title="map 可以边遍历 边删除&#x2F;边写入 吗？"></a>map 可以边遍历 边删除&#x2F;边写入 吗？</h4><ul><li><p>可以，但是<code>map</code>不是线程安全结构，同时读写会导致 panic , 如果在遍历，赋值，查找，删除的过程中，检测写标准存在就会 panic</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//runtime/map_fast64.go</span><br><span class="hljs-comment">// 检测是否在读写</span><br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;<br>        throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 设置 写入位</span><br>h.flags &amp;^= hashWriting<br></code></pre></td></tr></table></figure></li><li><p>遍历并不是顺序的中途写入值与删除值 ，可能会被遍历出来，导致未知的结果</p></li><li><p>可以 使用 <code>sync.Map</code> 或者 读写锁 <code>sync.RWMutex</code> 来处理 不过不建议 对于 时刻变化的 map 进行遍历，遍历的结果是不准确的</p></li></ul><h4 id="如何比较-两个-map-是否相等"><a href="#如何比较-两个-map-是否相等" class="headerlink" title="如何比较 两个 map 是否相等"></a>如何比较 两个 map 是否相等</h4><ul><li><p>两个 <code>map</code> 不能进行比较 <code>invalid operation: m1 == m2 (map can only be compared to nil)</code></p></li><li><p><code>map</code> 只能 判断是否为 <code>nil</code> 也就是 <code>map == nil</code></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">var</span> m2 <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>s1, _ := json.Marshal(m1)<br>s2, _ := json.Marshal(m2)<br>fmt.Println(<span class="hljs-type">string</span>(s1)) <span class="hljs-comment">// &#123;&#125;</span><br>fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">// null</span><br>fmt.Println(m1 == <span class="hljs-literal">nil</span>)  <span class="hljs-comment">// false</span><br>fmt.Println(m2 == <span class="hljs-literal">nil</span>)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>如果要判断两个 <code>map</code> 是否真的相等,只能 遍历去判断 或者 <code>json</code> 转换后的结果进行判定</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>slice</tag>
      
      <tag>《go语言设计与实现》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sso-技术选型的思考</title>
    <link href="/posts/11f98a72/"/>
    <url>/posts/11f98a72/</url>
    
    <content type="html"><![CDATA[<h1 id="关于-SSO-选型的思考"><a href="#关于-SSO-选型的思考" class="headerlink" title="关于 SSO 选型的思考"></a>关于 SSO 选型的思考</h1><p><strong>你在什么时候会去考虑实施SSO？</strong></p><p>公司具备开发能力，且内部应用系统林立，烟囱式的系统建设导致内部数据流转困难，业务人员需要登录与记忆几个系统的密码，管理人员需要多次登录来设置各类的权限时，就可以考虑建立SSO来统一人员信息，进一步可以统一权限信息。<br>这不但是公司基础设施的基础也可以作为自身晋升功绩的一部分，等打通 基础的人员，权限信息后，后续可以进行 <strong>中台&#x2F;平台</strong> 化改造，内部功能的改造，(如日志，告警，消息服务…) 来提升效率, 趁机也可以开启整体系统的微服务改造。</p><h2 id="什么是-SSO-Single-sign-on-单点登录-？"><a href="#什么是-SSO-Single-sign-on-单点登录-？" class="headerlink" title="什么是 SSO (Single sign-on , 单点登录)？"></a>什么是 SSO (Single sign-on , 单点登录)？</h2><p>单点登录是一种身份验证方法 是在多个应用系统中，用户只需要登录(认证)一次就可以访问多个相互信任的应用系统。</p><p>一般 <code>sso</code> 体系主要角色有三种： <code>user</code>（多个） <code>web</code> 应用（多个）, <code>sso</code> 认证中心（ <strong>1 个</strong>）</p><p>一般的步骤为</p><ol><li><p>前提-A应用在认证中心注册</p></li><li><p>用户点击A应用的统一登录按钮跳转进入认证中心</p></li><li><p>用户在认证中心认证成功后，携带认证信息跳转回应用</p></li><li><p>应用获取授权信息，关联自身的用户模块，记录用户登录信息，登录成功</p></li></ol><p><img src="/img/07.png" alt="07"></p><h2 id="目前的实现方案"><a href="#目前的实现方案" class="headerlink" title="目前的实现方案"></a>目前的实现方案</h2><p>基于以上的思路，业界出现了几套通用的方案</p><h3 id="CAS-Central-Authentication-Service-中央认证服务"><a href="#CAS-Central-Authentication-Service-中央认证服务" class="headerlink" title="CAS(Central Authentication Service) 中央认证服务"></a>CAS(Central Authentication Service) 中央认证服务</h3><p>国内的话，有各种供应商会给学校，医院，政府，企业提供此类的系统。在<code>github</code>上也有成熟的开源产品可以使用。</p><p><img src="/img/08.jpg" alt="08"></p><p>各位有对接需求的可以看下 <code>github.com/apereo/phpCAS</code> 这个包</p><p>优点：成熟，<code>java</code> 线容易找到大量的系统<br>缺点：部分产品基于session cookie 机制，技术栈较老 ，系统侵入性强，代码内需要引入其对应的客户端，定制化处理比较麻烦</p><h3 id="OAuth2-0-rfc"><a href="#OAuth2-0-rfc" class="headerlink" title="OAuth2.0 rfc"></a>OAuth2.0 <a href="http://www.rfcreader.com/#rfc6749">rfc</a></h3><p>这类的方案是目前的主流，比如微信，钉钉，QQ 等各类的大厂都有此协议的实现 , 授权码模式的具体实现如下图</p><p><img src="/img/09.jpg" alt="09"></p><p>()</p><p>我们也可以在 <code>GitHub</code> 上找到 大量的 <code>OAuth2.0</code> 的代码，但是 <code>OAuth</code>只规定了授权方式，而并没有涉及到具体用户</p><p>大部分的开源项目要不就直接写死了用户表与对应的字段，还提供默认的登录与认证页面，定制化修改较为困难。</p><p>要不就是只实现了<code>OAuth</code> 协议，拿过来还要理解整个流程，没法直接使用。</p><p>在协议细节上比如微信公众号通过对于 获取 <code>access_token</code> 时会响应 <code>open_id</code> 来让应用可以通过缓存，减少一次请求.</p><h3 id="中小型公司的实际需求"><a href="#中小型公司的实际需求" class="headerlink" title="中小型公司的实际需求"></a>中小型公司的实际需求</h3><p>在 OAuth2.0 授权码的模式下进一步简化，去除无效字段，减少逻辑</p><p><img src="/img/10.jpg" alt="10"></p><ul><li><p>A : 用户在业务端 主动发起三方认证登录，拼接 <code>app_id</code> 与 <code>redirect_uri</code> 进行跳转</p></li><li><p>B : 认证服务对 认证人 进行登录认证</p><ul><li><p>未登录，跳转至登录界面，进行登录认证</p></li><li><p>已登录进入下一步</p></li></ul></li><li><p>C : 确认已登录人员信息，确认 跳转进入的 应用信息（<code>app_id</code>）与 回调地址（redirect_uri ），生成授权码与跳转链接，并进行跳转</p><ul><li>应用信息确认失败的，进入 认证登录大厅页面</li></ul></li><li><p>D :   业务端在回调地址（<code>redirect_uri</code> ） 获取 授权码 <code>code</code>，并进行用户是否登录判定，</p><ul><li><p>未登录则去找认证服务，获取 <code>access_token</code></p></li><li><p>已登录，则直接进入 系统，流程完成</p></li></ul></li><li><p>E : 服务端 响应此用户对应的 <code>access_token</code></p></li><li><p>F : 业务端 通过 <code>access_token</code>  获取此用户的个人信息</p></li><li><p>G : 服务端响应用户信息后，业务端通过此信息，进行自身系统的登录注册相关逻辑</p></li></ul><h3 id="综合考虑"><a href="#综合考虑" class="headerlink" title="综合考虑"></a>综合考虑</h3><p>中小型企业，自建一套其实也就一个礼拜的功夫。自己的 UI 界面，与对应服务，定制化与扩展性肯定让你们老板满意。后续有时间的话，我可能会考虑用 golang 写一套后端相关 API。<br>我更新了一些<code>php</code>日常用得到的<code>Dockerfile</code>, <code>github.com/whyiyhw/work_dockerfile</code> 有问题可以跟我留言~</p><p>接下来，我会花上一段时间去更新 <code>golang</code> 相关的内容，其实 <code>golang</code> 算起来跟 <code>php</code> 也是互补，对抗 <code>java</code> 生态的伙伴吧，关键词少，看起来简洁而不简单，我们好好过一遍 <code>golang</code> 来弥补 <code>php</code> 所刻意掩盖的web程序开发的复杂性与细节。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术选型</tag>
      
      <tag>sso</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go design (二) slice</title>
    <link href="/posts/efa6eb50/"/>
    <url>/posts/efa6eb50/</url>
    
    <content type="html"><![CDATA[<h1 id="golang-中如何去设计变长数组"><a href="#golang-中如何去设计变长数组" class="headerlink" title="golang 中如何去设计变长数组"></a>golang 中如何去设计变长数组</h1><h2 id="我们在-谈论-slice-的时候到底在-讲什么？"><a href="#我们在-谈论-slice-的时候到底在-讲什么？" class="headerlink" title="我们在 谈论 slice 的时候到底在 讲什么？"></a>我们在 谈论 slice 的时候到底在 讲什么？</h2><ul><li><code>go</code> 中 关于 <code>slice</code>  的结构定义</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/runtime/slice.go </span><br><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer <span class="hljs-comment">// 元素指针</span><br><span class="hljs-built_in">len</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 数据的长度</span><br><span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 数据的容量</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>指针指向元素数组的地址 、 <code>len</code>  为实际数据的长度、  <code>cap</code> 为底层数组的长度</p></li><li><p>所以 默认 <code>cap &gt;= len</code>  </p></li><li><p>底层数组是可以被多个 <code>slice</code> 同时指向的，因此对一个 <code>slice</code> 的元素进行操作是有可能影响到其他 <code>slice</code> </p><p><img src="/img/12.png" alt="12"></p></li></ul><h2 id="slice-的创建"><a href="#slice-的创建" class="headerlink" title="slice 的创建"></a>slice 的创建</h2><ul><li><p>在谈具体的 创建之前 必须要理解 <code>nil slice</code>  与 <code>empty slice</code> 两种情况</p><ul><li><code>nil slice</code> <code>empty slice</code>  的 <code>len</code> 与 <code>cap</code> 都是 <code>0</code> </li><li>但 <code>empty slice</code> 其指针地址为 <code>0xc42003bda0</code> 所有的 <code>empty slice</code> 共享这个地址</li><li>而 <code>nil slice</code> 默认是没有 指针地址 等同于 <code>nil</code></li><li>所以官方默认推荐 为 <code>nil slice</code></li></ul></li><li><p>直接声明</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1 []<span class="hljs-type">int</span>           <span class="hljs-comment">// nil slice</span><br><span class="hljs-keyword">var</span> s2 = []<span class="hljs-type">int</span>&#123;&#125;       <span class="hljs-comment">// empty slice</span><br>fmt.Println(s1 == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br>fmt.Println(s2 == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// false</span><br>    <br>marshal1, _ := json.Marshal(s1)<br>marshal2, _ := json.Marshal(s2)<br>fmt.Println(<span class="hljs-type">string</span>(marshal1)) <span class="hljs-comment">// null 注意 json 格式化时候的坑</span><br>fmt.Println(<span class="hljs-type">string</span>(marshal2)) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure></li><li><p>字面量</p>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>: <span class="hljs-number">100</span>&#125;<br>fmt.Println(s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1)) <span class="hljs-comment">// [0 1 2 0 0 100] 6 6</span><br></code></pre></td></tr></table></figure><ul><li><strong>特性 字面量支持 使用索引号，直接赋值</strong></li></ul></li><li><p>new</p>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// nil slice</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(*slice), <span class="hljs-built_in">len</span>(*slice), *slice == <span class="hljs-literal">nil</span>)<span class="hljs-comment">// 0 0 true</span><br></code></pre></td></tr></table></figure><ul><li><code>new</code>  返回的是对 <code>slice</code> 的引用 , 解引用之后的值为 <code>nil slice</code></li></ul></li><li><p>make</p><ul><li><code>make</code>函数需要传入三个参数：切片类型，长度，容量[选填，默认等于长度]</li></ul>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)   <span class="hljs-comment">// empty slice</span><br>fmt.Println(s == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li><code>make</code>  会返回一个有初始值的类型， 所以 当 <code>len = 0</code> 时 <code>make</code>  出来的实际上是 一个 <code>empty slice</code></li></ul></li><li><p>从切片或数组截取</p>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>s1 := slice[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>fmt.Println(s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1)) <span class="hljs-comment">// 2, 3, 4         [8] [3]</span><br>s2 := s1[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]<br>fmt.Println(s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2)) <span class="hljs-comment">// 4, 5, 6, 7     [5] [4]</span><br>        <br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">100</span>)                <span class="hljs-comment">// 不发生 数组 copy</span><br>fmt.Println(s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2))          <span class="hljs-comment">// 4, 5, 6, 7 ,100    [5] [5]</span><br>fmt.Println(s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1))          <span class="hljs-comment">// 2, 3, 4         [8] [3]</span><br>fmt.Println(slice, <span class="hljs-built_in">cap</span>(slice), <span class="hljs-built_in">len</span>(slice)) <span class="hljs-comment">// 0, 1, 2, 3, 4, 5, 6, 7, 100, 9  [10]  [10]</span><br>        <br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">200</span>)                <span class="hljs-comment">// 发生 数组 copy</span><br>fmt.Println(s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2))          <span class="hljs-comment">// 4, 5, 6, 7 ,100,200    [10] [6]</span><br>fmt.Println(s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1))          <span class="hljs-comment">// 2, 3, 4         [8] [3]</span><br>fmt.Println(slice, <span class="hljs-built_in">cap</span>(slice), <span class="hljs-built_in">len</span>(slice)) <span class="hljs-comment">// 0, 1, 2, 3, 4, 5, 6, 7, 100, 9  [10]  [10]</span><br>        <br>s1[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span><br>fmt.Println(s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1))    <span class="hljs-comment">// 2, 3, 20        [8] [3]</span><br>fmt.Println(s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2))    <span class="hljs-comment">// 4, 5, 6, 7 ,100,200    [10] [6]</span><br>fmt.Println(slice)  <span class="hljs-comment">// 0, 1, 2, 3, 20, 5, 6, 7, 100, 9</span><br></code></pre></td></tr></table></figure><ul><li><code>s := [low,high,max] </code> <code>low</code> 包含 <code>high</code> 不包含 <code>low &lt;= high &lt;= max &lt;= 底层数组的cap</code>  </li><li><code>max</code> 默认值为  <code>底层数组的 cap - low</code> </li><li><code>make</code> 生成的 <code>slice</code> 如果 <code>cap</code> 不为 <code>0</code> ，其申请了一个 <code>cap</code> 长度的数</li></ul></li></ul><h2 id="append-到底做了什么"><a href="#append-到底做了什么" class="headerlink" title="append 到底做了什么"></a>append 到底做了什么</h2><ul><li><p><code>func append(slice []Type, elems ...Type) []Type</code> <code>elems</code> 为不定参数</p></li><li><p><code>append</code> 就是 向 原<code>slice</code> 追加元素 ，也可以追加多个 <code>slice...</code> 实际上还是往底层数组添加元素</p></li><li><p>但数组的底层大小是固定的，当加入的元素大于 <code>cap</code> 时，<code>slice</code> 会迁移到新的内存位置，新底层数组的长度也会增加。</p></li><li><p>新 <code>slice</code> 的容量预留了一定的 <code>buffer</code> 。但是 并不是 按照所谓的 <code>1024</code> 长度以前翻倍 <code>1024</code> 以后 <code>1.25</code>倍 增长直到大于新的长度</p></li><li><p>让我们来看下源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1.17.2  runtime/slice.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> slice &#123;<br>    <span class="hljs-comment">// ......</span><br>newcap := old.<span class="hljs-built_in">cap</span><br>doublecap := newcap + newcap<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> old.<span class="hljs-built_in">cap</span> &lt; <span class="hljs-number">1024</span> &#123;<br>newcap = doublecap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><br><span class="hljs-comment">// and prevent an infinite loop.</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>newcap += newcap / <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-comment">// Set newcap to the requested cap when</span><br><span class="hljs-comment">// the newcap calculation overflowed.</span><br><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 根据实际分配的内存来 反推 cap</span><br><span class="hljs-keyword">var</span> overflow <span class="hljs-type">bool</span><br><span class="hljs-keyword">var</span> lenmem, newlenmem, capmem <span class="hljs-type">uintptr</span><br><span class="hljs-comment">// Specialize for common values of et.size.</span><br><span class="hljs-comment">// For 1 we don&#x27;t need any division/multiplication.</span><br><span class="hljs-comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span><br><span class="hljs-comment">// For powers of 2, use a variable shift.</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> et.size == <span class="hljs-number">1</span>:<br>lenmem = <span class="hljs-type">uintptr</span>(old.<span class="hljs-built_in">len</span>)<br>newlenmem = <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>)<br>capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap))<br>overflow = <span class="hljs-type">uintptr</span>(newcap) &gt; maxAlloc<br>newcap = <span class="hljs-type">int</span>(capmem)<br><span class="hljs-keyword">case</span> et.size == sys.PtrSize:<br>lenmem = <span class="hljs-type">uintptr</span>(old.<span class="hljs-built_in">len</span>) * sys.PtrSize<br>newlenmem = <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>) * sys.PtrSize<br>capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap) * sys.PtrSize)<br>overflow = <span class="hljs-type">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize<br>newcap = <span class="hljs-type">int</span>(capmem / sys.PtrSize)<br><span class="hljs-keyword">case</span> isPowerOfTwo(et.size):<br><span class="hljs-keyword">var</span> shift <span class="hljs-type">uintptr</span><br><span class="hljs-keyword">if</span> sys.PtrSize == <span class="hljs-number">8</span> &#123;<br><span class="hljs-comment">// Mask shift for better code generation.</span><br>shift = <span class="hljs-type">uintptr</span>(sys.Ctz64(<span class="hljs-type">uint64</span>(et.size))) &amp; <span class="hljs-number">63</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>shift = <span class="hljs-type">uintptr</span>(sys.Ctz32(<span class="hljs-type">uint32</span>(et.size))) &amp; <span class="hljs-number">31</span><br>&#125;<br>lenmem = <span class="hljs-type">uintptr</span>(old.<span class="hljs-built_in">len</span>) &lt;&lt; shift<br>newlenmem = <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>) &lt;&lt; shift<br>capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap) &lt;&lt; shift)<br>overflow = <span class="hljs-type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)<br>newcap = <span class="hljs-type">int</span>(capmem &gt;&gt; shift)<br><span class="hljs-keyword">default</span>:<br>lenmem = <span class="hljs-type">uintptr</span>(old.<span class="hljs-built_in">len</span>) * et.size<br>newlenmem = <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>) * et.size<br>capmem, overflow = math.MulUintptr(et.size, <span class="hljs-type">uintptr</span>(newcap))<br>capmem = roundupsize(capmem)<br>newcap = <span class="hljs-type">int</span>(capmem / et.size)<br>&#125;<br><span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>所以 结论就是 <strong>slice</strong> <strong>扩容规则</strong>是， <ul><li>先是 估算 预期 <code>cap</code> 传入值大于本身两倍时，等于传入值，其他情况 低于 1024 翻倍 高于 1024 逐步增加 1.25 倍直至 大于传入值</li><li>然后进行内存对齐算法计算 </li><li>最终获取新的 <code>cap</code> 值</li></ul></li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 验证内存对齐实例</span><br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">4</span>)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">5</span>)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">6</span>)<span class="hljs-comment">// [5] , [8]</span><br>    <br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<span class="hljs-comment">//  [5] , [6]</span><br></code></pre></td></tr></table></figure><ul><li><code>s1</code> 原来只有 2 个元素，<code>len</code> 和 <code>cap</code> 都为 2，<code>append</code> 了三个元素后，长度变为 3，容量最小要变成 5，即调用 <code>growslice</code> 函数时，传入的第三个参数应该为 5。即 <code>cap=5</code>。而一方面，<code>doublecap</code> 是原 <code>slice</code>容量的 2 倍，等于 4。满足第一个 <code>if</code> 条件，所以 <code>newcap</code> 变成了 5</li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据 内存对齐的判定 走到 第二个判定</span><br>capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap) * sys.PtrSize)<br>overflow = <span class="hljs-type">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize<br>newcap = <span class="hljs-type">int</span>(capmem / sys.PtrSize)<br><span class="hljs-comment">// sys.PtrSize 在 64 位 机器上为 8</span><br><span class="hljs-type">uintptr</span>(newcap) * sys.PtrSize = <span class="hljs-number">5</span> * <span class="hljs-number">8</span> = <span class="hljs-number">40</span><br><span class="hljs-comment">// 所以相当于 调用了 roundupsize(40)</span><br><span class="hljs-comment">// runtime/msize.go </span><br>_MaxSmallSize = <span class="hljs-number">32768</span><br>smallSizeMax  = <span class="hljs-number">1024</span><br>smallSizeDiv  = <span class="hljs-number">8</span><br>size   = <span class="hljs-number">40</span> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">roundupsize</span><span class="hljs-params">(size <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">uintptr</span> &#123;<br>          <span class="hljs-keyword">if</span> size &lt; _MaxSmallSize &#123;<br>              <span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-type">uintptr</span>(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">// ......</span><br>              &#125;<br>          &#125;<br><span class="hljs-comment">//......</span><br>      &#125;<br><span class="hljs-comment">// 所以最终 调用的是 </span><br>class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]<br><span class="hljs-comment">// runtime/stubs.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divRoundUp</span><span class="hljs-params">(n, a <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">uintptr</span> &#123;<br>          <span class="hljs-comment">// a is generally a power of two. This will get inlined and</span><br>          <span class="hljs-comment">// the compiler will optimize the division.</span><br>          <span class="hljs-keyword">return</span> (n + a - <span class="hljs-number">1</span>) / a<br>      &#125;<br>divRoundUp(size, smallSizeDiv) = (<span class="hljs-number">40</span> + <span class="hljs-number">8</span> <span class="hljs-number">-1</span>) / <span class="hljs-number">8</span> = <span class="hljs-number">5</span><br>size_to_class8[<span class="hljs-number">5</span>] = <span class="hljs-number">5</span><br>class_to_size[<span class="hljs-number">5</span>] = <span class="hljs-number">48</span> <br><span class="hljs-comment">//最终</span><br>newcap = <span class="hljs-type">int</span>(capmem / sys.PtrSize) = <span class="hljs-number">48</span> / <span class="hljs-number">8</span>  = <span class="hljs-number">6</span><br><br></code></pre></td></tr></table></figure><ul><li>所以 在经过 内存对齐 算法后  新的 <code>cap</code>  为 6 而不是想象中的 8</li></ul></li></ul><h2 id="为什么-nil-slice-可以直接-append？"><a href="#为什么-nil-slice-可以直接-append？" class="headerlink" title="为什么 nil slice 可以直接 append？"></a>为什么 <code>nil slice</code> 可以直接 <code>append</code>？</h2><ul><li>其实 <code>nil slice</code> 或者 <code>empty slice</code> 都是可以通过调用 append 函数来获得底层数组的扩容。</li><li>最终都是调用 <code>mallocgc</code> 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的<code>nil slice</code> 或 <code>empty slice</code>，然后摇身一变，成为“真正”的 <code>slice</code> 了。</li></ul><h2 id="传-slice-和-slice-指针有什么区别"><a href="#传-slice-和-slice-指针有什么区别" class="headerlink" title="传 slice 和 slice 指针有什么区别"></a>传 <code>slice</code> 和 <code>slice</code> 指针有什么区别</h2><ul><li><p><code>slice</code>  与 <code>slice</code>  指针 都是值传递，只不过是 <code>copy</code> 了一份 同样的结构，但是底层都是指向同一个数组</p></li><li><p>不改变底层数据的情况下是不会对 原始 <code>slice</code>  产生影响</p></li></ul>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>f(s)<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">// i只是一个副本，不能改变s中元素的值</span><br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> s &#123;<br>   i++<br>&#125;<br><br><span class="hljs-comment">// 这个 改变了底层数组 会产生影响</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>s[i] += <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// append 对底层数组进行了迁移 也不会应用到 原来的数组</span><br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">20</span>)<br>s[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span><br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 <code>append</code> 元素后 新 <code>len</code> 不超过 <code>cap</code> 时, 会公用底层部分的 <code>slice</code></li></ul>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>b := a<br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-number">1</span>)<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">19</span><br>fmt.Println(a, <span class="hljs-built_in">cap</span>(a), <span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">// [19 0] 3 2</span><br>fmt.Println(b, <span class="hljs-built_in">cap</span>(b), <span class="hljs-built_in">len</span>(b)) <span class="hljs-comment">// [19 0 1] 3 3</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>b := a<br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">19</span><br>fmt.Println(a, <span class="hljs-built_in">cap</span>(a), <span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">// [0 0]      3 2</span><br>fmt.Println(b, <span class="hljs-built_in">cap</span>(b), <span class="hljs-built_in">len</span>(b)) <span class="hljs-comment">// [19 0 1 2] 6 4</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="copy-函数的小坑"><a href="#copy-函数的小坑" class="headerlink" title="copy 函数的小坑"></a>copy 函数的小坑</h2><ul><li><code>func copy(dst, src []Type) int</code> 将 <code>src</code> 的值 拷贝给 <code>dst</code> ,<code>dst</code> 必须先确定好新 <code>len</code> 跟 <code>cap</code>,多于 <code>dst.len</code> 的 值 会被忽略。</li><li><code>copy</code> 是 <code>slice</code> 专用数据复制函数。默认是值进行复制，不是引用复制 用 <code>nil slice</code> 跟 <code>empty slice</code> 进行赋值是没意义的，因为多余的值被忽略，你永远也赋值不进去</li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>slice</tag>
      
      <tag>《go语言设计与实现》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go design (一) array</title>
    <link href="/posts/a5d408b/"/>
    <url>/posts/a5d408b/</url>
    
    <content type="html"><![CDATA[<h1 id="golang-中-array-的实现"><a href="#golang-中-array-的实现" class="headerlink" title="golang 中 array 的实现"></a>golang 中 array 的实现</h1><p>数组是由相同类型元素的集合组成的数据结构。<br>计算机操作系统会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素 。<br>常见的数组大多都是一维的线性数组。多维数组在数值计算和图形应用方面非常有用。</p><h2 id="golang-中-对于数组的实现-array"><a href="#golang-中-对于数组的实现-array" class="headerlink" title="golang 中 对于数组的实现 array"></a><code>golang</code> 中 对于数组的实现 <code>array</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// cmd/compile/internal/types/type.go</span><br><br><span class="hljs-comment">// Array contains Type fields specific to array types.</span><br><span class="hljs-keyword">type</span> Array <span class="hljs-keyword">struct</span> &#123;<br>Elem  *Type <span class="hljs-comment">// element type</span><br>Bound <span class="hljs-type">int64</span> <span class="hljs-comment">// number of elements; &lt;0 if unknown yet</span><br>&#125;<br><br><br><span class="hljs-comment">// NewArray returns a new fixed-length array Type.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArray</span><span class="hljs-params">(elem *Type, bound <span class="hljs-type">int64</span>)</span></span> *Type &#123;<br><span class="hljs-keyword">if</span> bound &lt; <span class="hljs-number">0</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;NewArray: invalid bound %v&quot;</span>, bound)<br>&#125;<br>t := New(TARRAY)<br>t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;<br>t.SetNotInHeap(elem.NotInHeap())<br><span class="hljs-keyword">if</span> elem.HasTParam() &#123;<br>t.SetHasTParam(<span class="hljs-literal">true</span>)<br>&#125;<br><span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-comment">// A Type represents a Go type.</span><br><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>    ······<br>    <span class="hljs-comment">// Extra contains extra etype-specific fields.</span><br><span class="hljs-comment">// TARRAY: *Array</span><br>Extra <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-comment">// Width is the width of this Type in bytes.</span><br>Width <span class="hljs-type">int64</span> <span class="hljs-comment">// valid if Align &gt; 0</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>由源码可以了解编译前的 <code>golang</code> 中的 <code>array</code> 由<code>elem</code>(任意类型元素 <code>Type</code>） 跟 <code>bound</code> 元素个数 组成, <code>type.Width</code> 代表了此元素的长度。知道数组的元素个数，元素的起始位置，每个元素的长度之后，后续的对于数组的操作就简单了。</li><li>对于元素类型一致但声明 <code>bound</code> 不一致 <code>array</code> 是不可比较的</li></ul><p><img src="/img/11.png" alt="11"></p><h2 id="array-的初始化"><a href="#array-的初始化" class="headerlink" title="array 的初始化"></a>array 的初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">arr1 := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>arr2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于 […] 声明的数组，底层会自动推导 <code>bound</code> 并转成 上一种声明方式</li></ul><h2 id="访问与赋值"><a href="#访问与赋值" class="headerlink" title="访问与赋值"></a>访问与赋值</h2><ul><li>数组的长度固定，那么对于简单的越界操作，编译时就能发现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">arr2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>arr2[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span><br><span class="hljs-comment">//invalid array index 3 (out of bounds for 3-element array)</span><br><span class="hljs-comment">//Compilation finished with exit code 2</span><br></code></pre></td></tr></table></figure><ul><li>而对于变量去替代索引的情况，就只能由运行时去判定</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>rand.Seed(time.Now().Unix())<br>i := rand.Int()<br>arr2[i] = <span class="hljs-number">2</span><br><span class="hljs-comment">//panic: runtime error: index out of range [6089373529803393694] with length 3</span><br></code></pre></td></tr></table></figure><ul><li>如何证明array在内存中的连续性？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">arr2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt.Println(unsafe.Pointer(&amp;arr2[<span class="hljs-number">0</span>]), unsafe.Pointer(&amp;arr2[<span class="hljs-number">1</span>]), unsafe.Pointer(&amp;arr2[<span class="hljs-number">2</span>]), unsafe.Pointer(&amp;arr2[<span class="hljs-number">3</span>]))<br><span class="hljs-comment">//0xc000010180 0xc000010188 0xc000010190 0xc000010198</span><br></code></pre></td></tr></table></figure><ul><li>很显然 数组中每一位的地址 相差为 10 进制的 8 ，那就是说在我64位的机器上 int  为 8字节</li></ul><p>  数组是程序中最基础的结构之一，知道索引时，其 <code>O(1)</code> 的读写速度也十分优秀，但其定长的特性，注定了灵活性的不足。<code>golang</code> 中 我们使用最多的 <code>slice</code> ，但其底层也是依赖于<code>array</code>。</p><p>  下一篇, 我们一起看看 <code>slice</code> 的设计与实现。</p><ul><li>相关参考<ul><li>[维基百科]：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>《go语言设计与实现》</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我管理</title>
    <link href="/posts/dd4cdbb5/"/>
    <url>/posts/dd4cdbb5/</url>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>​因疫情而更关注现实的我，根据疫情期间的实事，以及自己的一些经历所总结的对于当代（20世界10年代）现实的理解。希望以后的自己能对现在的我进行更深刻的批判。本系列也是一个废宅，在4年间适应社会改造并逐步成长为技术宅的故事，无趣但确实有效。涉及日常生活的各个领域。</p><h3 id="思想上的独立"><a href="#思想上的独立" class="headerlink" title="思想上的独立"></a>思想上的独立</h3><p>​一般人所受的教育，都是应试教育，总是期待一个标准答案来解释，从学校中出来，生活中遇到的各种问题。但现实是没有标准的答案，高速发展的社会，需要你自行去适应，去探寻带有时效性的答案，选择对了，就能获得中短期内的丰厚回报，而连续的错误选择，则会导致你的生活身不由己。因此需要你有做独立选择的能力，也要有做选择的勇气。</p><p>​人的行为由思想控制，而思想是文化、家庭、社会、教育的混合体。我们要求思想上的独立，首先需要理解我们为什么会有这样的思想。</p><p>​比如我选专业时候的困惑，来自于我对于家庭、家族权威的无条件盲从，也来自于人生与目标教育的缺失，出校门时的恐惧，则来自于责任感与使命感的获得，我实习时的工资足以养活自己，但当时的我，内心却是无比的迷茫。我可能想过了无数应该为我负责的人，但没有想过，自己为什么会觉得别人应该为我负责。</p><p>​得力于身体上的独立，我很快开始反思自身的行为，了解我所处的社会。很不幸的是，我所处的工作环境算是个半封闭的小社会，而我来了解大社会用的是UC新闻（<del>充满震惊体与偏见的新闻</del>）。以至于我对于自我认识与解开思想限制的进度一直很慢，因为年轻（<del>便宜</del>），能干（<del>人傻</del>）当我回过头来发现这个小社会已经不适合我的时候，带着对于虚幻现实的认知一头扎进了更大的社会。</p><p>​现在回过头来，发现自己真的是走了一次独木桥，靠着傻人傻福走了过来，结论虽然是多接触社会有好处。但在目前的大环境下，做一个正直乐观的社会人，真的是对一个人的教育与品行要求极高。</p><p>​思想的独立要求其实很简单，<strong>求同存异</strong>，多思考你为什么这么想（<del>是因为什么因素，家庭，教育，社会</del>），而不是靠本能去做选择。我做了，是我按自己的意愿做的，是我自己选择的意愿。只有这样，人才能活的通透，行知合一。</p><h3 id="思想管理"><a href="#思想管理" class="headerlink" title="思想管理"></a>思想管理</h3><p>​<strong>人和人之间最大的区别就是对于事物的定义不同</strong> </p><p>​我们在谈论一件事物的时候，首先要明确事物的定义，先来看看自我管理（self-management）的定义，它可以视为与自我的关系管理，就是指个体对自己本身，对自己的目标、思想、心理和行为等等表现进行的管理，自己把自己组织起来，自己管理自己，自己约束自己，自己激励自己，自己管理自己的事务，最终实现自我奋斗目标的一个过程。</p><p>​现在我们对于自我管理的定义一致了，才能进行下一步的讨论，思想上的管理。世界上我们听的最多的矛盾就是自由与专制。这也体现在自我管理中，我们完全不约束自己的行为，由着自我性子，随意生活，这对于一般人来说，是做不到的。而对于自身行为有着严格限制的监狱，绝大多数人都想越狱。如果你觉得生活总是处于两者之间来回切换，那么不妨考虑下，用自律来隔离出更大的自我发挥空间与时间。如果时不时处于极端消极的思想中，那么你就要考虑，是什么在带动自己的走向消极思想，它的目的是什么。</p><p>​中庸不是平庸，自律不是逞强。思想上的管理是行为管理的内驱，也没有哪一种思想能解决生活上的所有问题，愿诸位在反思与总结中走出属于自己的生活之道。</p><h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><p>还是太小看写一个系列的难度，如果按照我第一篇4个小时的时间来算，我估计能写到今年年底，加之写完之后精神比较兴奋，所以会导致晚上睡眠质量很差。这个时候就想到了使用工具，我的矛盾主要在于，思想比较快但由于打字限制了我的表达，所以采用了语音转文字这样一种形式，这样就能大大的提升我的码字效率。</p><p>今天主要是来谈论效率工具，先说结论，效率工具不是万能的，适合自己的才是最好的。所谓的适合，要能量化，能拿出数据，不然就会陷入第一篇中我们所谈的定义不一致的陷阱中，每个人都一套适合自己的工具。效率工具：顾名思义就是提升你做事的一个效率。具体情况因人而异，但在信息技术，不断接入生活的方方面面时候，其实就已经说明了，效率工具确实了很有效果的。</p><p>做同一件事有人3分钟就搞定，有人15分钟也做不完，但每个人每天都是24小时，这对于做事慢的人来说就很不公平，所以在做为一个有追求的程序员，首先要有时间概念。我目前在用的华为GT手表。虽然有很多功能，但说来惭愧，我用最多的是定时器功能。简单直接，提升效率，如果编码时候，屏幕上时不时出现中断的画面，真的很打断思路，相对来说，我更能接受这种自定义时间的振动提示，结合时间计划工具，能有效提升工作完成时间。生活中使用的话，比如早上煮鸡蛋煮几分钟，你定个时间，这样的小场景有很多，手表的定时功能都比较适合。</p><p>刚刚提到的时间计划工具，市面上有很多任务提示的工具，我尝试过几次之后就不再用了，问就是因为不适合，对于我的效率提升没有太大帮助，反而给我一种小时候被盯着写作业的紧迫感。我目前在用的是幕布，一款结构化笔记工具，配合手表定时器，能给我更大的发挥空间，幕布的好处在于它能让你把发散的思维在重新的归纳起来，形成你自己的观点与脉络。人类所创造的一切东西，都能简化并归纳成结构化的树状图，或是网状图。如果你对认识某件事物，心里有关于这个东西性质的图或者列表，那么，你看待事物的方式的话就会更加的全面。</p><p>最后就是带测体脂功能的电子秤，每隔两天称一下，提示自己要健康生活，好多东西少吃，多运动，虽然我也做的不好，但是一旦我下定决心，减肥这件事真的不难，目前 74.5，预计下个礼拜五72.5（5月1号），关于减肥，健身的话题我之后还会再开一篇来说，今天就到这。</p><p>我目前觉得最有用的话，就是这三个，今天我也是想测试一下讯飞语音这个功能，实际效果会怎么样。目前看来效果还可以，这篇小短文修改完善大概50分钟。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>plan</title>
    <link href="/posts/dd5a5b7d/"/>
    <url>/posts/dd5a5b7d/</url>
    
    <content type="html"><![CDATA[<ul><li>基础目标<ul><li>网络协议</li><li>数据结构与算法 <strong>原理与实践</strong>（需要刷题）</li><li>计算机操作系统（linux与windows）</li><li>设计模式与设计范式</li></ul></li><li>语言目标<ul><li>主要<ul><li>php 基础，原理与近年来大版本的改进<ul><li>laravel与tp6框架实现源码流程</li><li>基础数据结构，基础数据结构在内存中的分布</li><li>GC的实现</li><li>swoole</li><li>刷题</li></ul></li><li>golang 熟悉各个标准库包的使用，需要刷题<ul><li>gin框架实现源码流程</li><li>基础数据结构，基础数据结构在内存中的分布</li><li>GC的实现</li><li>协程</li><li>刷题</li></ul></li></ul></li><li>次要<ul><li>javaScript 上述目标完成的情况下 熟悉ES6 与三大标准库，了解前沿发展</li><li>Vue库 要能 搞清楚其生命周期</li><li>几种经典布局要学会</li></ul></li></ul></li><li>高性能系统目标<ul><li>主要<ul><li>数据库原理与设计（mysql）包括运维</li><li>缓存原理与设计（redis）</li><li>队列原理与设计（mq）</li><li>定时器原理与设计</li></ul></li><li>次要<ul><li>分布式系统相关设计 （微服务架构）</li><li>搜索ES</li></ul></li></ul></li><li>运维方向<ul><li>nginx</li><li>php-fpm</li><li>docker</li><li>shell</li></ul></li><li>业务系统设计目标<ul><li>支付宝</li><li>钉钉</li><li>微信</li><li>一卡通系统</li><li>通用的用户协议</li></ul></li><li><strong>最主要要达成一点就是 每一个目标里面至少要有一个能深入与人探讨，lnmp属于phper基础不能弱</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议(一)</title>
    <link href="/posts/f6db84d9/"/>
    <url>/posts/f6db84d9/</url>
    
    <content type="html"><![CDATA[<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li><p>协议，网络协议的简称，网络协议是指通信计算机双方必须共同遵从的一组约定。</p></li><li><p>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），它最终体现为在网络上传输的数据包的格式。</p><ul><li>协议的三要素包括 <strong>语法</strong> <strong>语义</strong> <strong>时序</strong></li></ul></li><li><p><em>以上内容来自百度百科</em></p><p>不谈它在网络中的表示，我们所理解的，字面上的<code>协议</code>，就是约定，双方都明白且遵循的一种规则，也就是说是人为规定的，不是自然产生的。有人的地方就有江湖，协议也不例外，人有时代局限性，协议当然也有，也可以说网络协议是人们为了避免纷争，妥协出来的产物。协议一直在不断完善中，我们要学习与理解现在的协议发展，就要从头开始去理解。</p></li><li><h3 id="ISO-OSI-协议模型"><a href="#ISO-OSI-协议模型" class="headerlink" title="ISO/OSI 协议模型"></a><code>ISO/OSI</code> 协议模型</h3></li></ul><table><thead><tr><th>层次</th><th align="left">说明</th></tr></thead><tbody><tr><td>物理层</td><td align="left">物理层（Physical Layer）在局部局域网上传送<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%B8%A7">数据帧</a>（data frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</td></tr><tr><td>数据链路层</td><td align="left">数据链路层（<code>Data Link Layer</code>）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（<code>DLH</code>）是包含了物理地址和错误侦测及改错的方法。数据链表尾（<code>DLT</code>）是一串指示数据包末端的字符串。例如以太网、无线局域网（<code>Wi-Fi</code>）和通用分组无线服务（<code>GPRS</code>）等。分为两个子层：逻辑链路控制（<code>logical link control，LLC</code>）子层和介质访问控制（<code>Media access control，MAC</code>）子层</td></tr><tr><td>网络层</td><td align="left">网络层（<code>Network Layer</code>）决定数据的路径选择和转寄，将网络表头（<code>NH</code>）加至数据包，以形成报文。网络表头包含了网络数据。例如:互联网协议（<code>IP</code>）等。</td></tr><tr><td>传输层</td><td align="left">传输层（<code>Transport Layer</code>）把传输表头（<code>TH</code>）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（<code>TCP</code>）等。</td></tr><tr><td>会话层</td><td align="left">会话层（Session Layer）负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</td></tr><tr><td>表示层</td><td align="left">表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</td></tr><tr><td>应用层</td><td align="left">应用层（<code>Application Layer</code>）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: <code>HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3,HTML</code>等。</td></tr></tbody></table><ul><li><p><code>1984</code>年，<code>ISO</code>发布了著名的<code>ISO/IEC 7498</code>标准，它定义了网络互联的7层框架，也就是开放式系统互联参考模型 （<code>OSI</code>，Open Systems Interconnection）(by来自维基百科)</p></li><li><p>因为协议由人设计，所以各大公司都有一套自己的玩意，这些东西一直到现在（2019）依然对兼容性有着很大的约束.</p></li><li><p>七层模型也称为理想中的模型，实际上一般的业务程序员在工作中能感知的 无非就是上层的应用层 <code>http</code>  网络层 <code>IP</code>  传输层 <code>TCP</code> 一般没事都不会关心，这也体现出分层的好处，减少心智负担</p><ul><li><p>所以 也有 </p><ul><li><p><strong>五层</strong>划分为：<strong>应用层（应用，表示，会话）、传输层、网络层、数据链路层、物理层</strong>。</p></li><li><p><strong>四层</strong>划分为：<strong>应用层（应用，表示，会话）、传输层、网络层、网络接口层（数据链路层、物理层）</strong>。</p></li></ul></li></ul></li><li><p>通俗来说 物理层就是来保证数据能正常在实体设备间进行传输的，它只负责跟硬件设备打交道，数据链路层就是对电信号进行分组</p></li><li><p>数据链路层的以太网协议<code>Ethernet</code>。</p><ul><li>一组电信号称之为一个数据包，或者叫做一个<strong>“帧”</strong></li><li>每一数据帧分成：报头head和数据data两部分</li><li>[【head】【data】]<ul><li>head包含：（固定18个字节）<ul><li>发送者（源地址，6个字节）</li><li>接收者（目标地址，6个字节）</li><li>数据类型（6个字节）</li></ul></li><li>data包含：（最短46字节，最长1500字节）</li><li>其中的源地址和目标地址指的是<strong>mac地址</strong></li></ul></li><li><code>Ethernet</code>规定接入Internet的设备都必须具备网卡，发送端的和接收端的地址便是指网卡的地址，即<code>Mac</code>地址。每块网卡出厂时都被烧录上一个实际上唯一的Mac地址，长度为48位2进制，通常由12位16进制数表示</li></ul></li><li><p>有了以太网协议后，在同一局域网内的设备就可以通信，局域网内的计算机不管是对内还是对外都是靠吼，这就是数据链路层的工作方式—–广播（<code>ARP</code>协议），这个里面肯定还有细节点，之后再写</p></li><li><p>当然，数据链路层仅限于局域网的信息传递，问题是，跨局域网设备通讯是怎么做的呢？</p></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li><p>HTTP 协议始于 1991 年的 HTTP&#x2F;0.9，</p></li><li><p>1996 年 HTTP&#x2F;1.0 规范的发布</p><ul><li>在 HTTP&#x2F;1.0 中，客户端和服务器之间交换的每个请求 &#x2F; 响应都会创建一个新的 TCP 连接</li><li>这意味着所有 <code>TCP</code> 握手均在每个请求之前完成，因此所有请求都会产生延迟。</li><li>TCP 不是在建立连接后尽快发送所有未完成的数据，而需要“慢启动”的预热时间，这使 <code>TCP</code> 拥塞控制算法能够随时确定可以传输的数据量，防止网络路径发生拥塞，并避免将无法处理的数据包都堆到网络中。但是，由于新连接必须经过缓慢的启动过程，因此它们无法立即使用所有可用的网络带宽。</li></ul></li><li><p>1999 年演变为 HTTP&#x2F;1.1，并由 <code>IETF</code>（互联网工程任务组）负责进行标准化。</p><ul><li><p>引入<code>保持活动</code>连接的概念来解决这些问题 <code>Connection: keep-alive</code></p></li><li><p>允许客户端复用 TCP 连接，从而分摊了建立初始连接和针对多个请求缓慢启动的成本</p></li><li><p>尽管多个请求可以共享同一个连接，但它们仍需逐个序列化它们，因此任意时点上客户端和服务器只能为每个连接执行一次请求 &#x2F; 响应交换</p></li><li><p>随着网络的发展，多年来网站所需资源（<code>CSS、JavaScript</code> 和图像等）不断增长，浏览器在获取和呈现网页时需要越来越多的并发性。但由于 <code>HTTP/1.1</code> 只允许客户端同时进行一次 <code>HTTP 请求 / 响应交换</code>，因此在网络层上获得并发能力的唯一方法是<code>并行使用多个 TCP 连接到同一来源</code>，代价就是<code>牺牲了活动连接的大多数好处</code>。尽管连接仍会在一定程度上（但程度不大）被复用，但我们又回到了起点。</p></li><li><p><strong>Chrome 有个机制，对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</strong>使用持久连接时，虽然能共用一个 TCP 管道，<strong>但是在一个管道中同一时刻只能处理一个请求</strong>，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p></li><li><p><code>HTTP/1.1</code> 有两个主要的缺点：安全不足和性能不高。</p><ul><li>明文传输 – 带来不安全性</li><li>高延迟 – 带来页面加载速度的降低<ul><li><strong>网络延迟问题主要由于队头阻塞 (Head-Of-Line Blocking) 产生，导致带宽无法被充分利用</strong></li><li>TCP协议的堵塞</li></ul><p></p></li><li>无状态特性 – 带来巨大的 HTTP 头部 ，<code>Header</code> 里携带的内容过大，在一定程度上增加了传输成本 </li><li>不支持服务器推送消息</li></ul></li></ul></li><li><p>HTTP&#x2F;2 在 2015 年出现了。</p><ul><li><p><strong><code>HTTP/2</code> 基于 <code>SPDY</code>，专注于性能，最大的目标是在用户和网站间只用一个连接（<code>connec-tion</code>）</strong></p></li><li><p>率先引入了 <code>HTTP</code>“流”的概念：这是一种抽象概念，允许 <code>HTTP</code> 实现将不同的 <code>HTTP</code> 交换并发地复用到同一 <code>TCP</code> 连接上， 使浏览器更高效地复用 <code>TCP</code> 连接。</p></li><li><p><code>HTTP/2</code> 解决了最初的问题——单个 <code>TCP</code> 连接的使用效率低——因为现在可以通过同一连接同时传输多个请求 &#x2F; 响应。但是，即使只有单个请求丢失数据，所有请求和响应也会同样受到数据包丢失（比如因为网络拥塞）的影响。这是因为尽管 <code>HTTP/2</code> 层可以在不同的流上隔离不同的 <code>HTTP</code> 交换，但是 <code>TCP</code> 不了解这种抽象，并且后者所看到的只是字节流，没有特殊含义。</p></li><li><p><code>TCP</code> 的作用是以正确的顺序从一个端点到另一端点传递整个字节流。当承载某些字节的 <code>TCP</code> 数据包在网络路径上丢失时将在流中造成间隙，并且 <code>TCP</code> 需要在检测到丢失时重新发送受影响的数据包来弥补这一间隙。这样做时，即使丢失数据之后的数据属于完全不同的 <code>HTTP</code> 请求，自己也根本没有丢失，也能正常传递成功，它们还是不能正常传递给应用程序。因此它们只能毫无必要地产生延迟，因为 <code>TCP</code> 无法知道应用程序缺少了丢失的数据包时能否处理后面的数据。这个问题称为“行首阻塞”</p></li><li><p><code>SPDY</code> 位于 <code>HTTP</code> 之下，<code>TCP</code> 和 <code>SSL</code> 之上，这样可以轻松兼容老版本的 <code>HTTP</code> 协议 (将 <code>HTTP1.x</code> 的内容封装成一种新的 <code>frame</code> 格式)，同时可以使用已有的 <code>SSL</code> 功能</p></li><li><p>二进制传输</p></li><li><p><strong>HTTP&#x2F;2 传输数据量的大幅减少, 主要有两个原因: 以二进制方式传输和 Header 压缩</strong></p></li><li><p><strong>HTTP&#x2F;2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</strong>。</p></li><li><p><strong>多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装</strong>。</p></li><li><p>Header 压缩</p><ul><li>采用了新的压缩算法，主要解决了header头重复的问题</li></ul></li><li><p>多路复用</p><ul><li>在 HTTP&#x2F;2 中引入了多路复用的技术。多路复用很好地解决了浏览器限制同一个域名下请求数量的问题，同时也更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</li><li>同域名下所有通信都在单个连接上完成。</li><li>单个连接可以承载任意数量的双向数据流。</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li></ul></li><li><p>服务器推送</p></li><li><p>服务器不再完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 <code>JS、CSS</code> 文件发给客户端，减少等待的延迟，这被称为 “ 服务器推送 “（ <code>Server Push，也叫 Cache push</code>）</p></li><li><p>提高安全性</p><ul><li>内容不再明文，而是以 二进制传输, 实际上 目前的<code>http/2</code> 基本上都是跑在 <code>TLS</code> 上的 都需要解密</li></ul></li><li><p><strong>HTTP&#x2F;2 的缺点</strong></p><ul><li>主要是底层支撑的 TCP 协议造成的<ul><li><code>TCP</code> 和 <code>TCP+TLS</code> 建立连接的延时</li><li><code>TCP</code> 的队头阻塞并没有彻底解决<ul><li><code>HTTP/2</code> 中，多个请求是跑在一个 <code>TCP</code> 管道中的。但当出现了丢包时，<code>HTTP/2</code> 的表现反倒不如 <code>HTTP/1</code> 了。因为 <code>TCP</code> 为了保证可靠传输，有个特别的<code>“丢包重传”</code>机制，丢失的包必须要等待重新传输确认，<code>HTTP/2</code> 出现丢包时，整个 <code>TCP</code> 都要开始等待重传，那么就会阻塞该 <code>TCP</code> 连接中的所有请求。而对于 <code>HTTP/1.1</code> 来说，可以开启多个 <code>TCP</code> 连接，出现这种情况反倒只会影响其中一个连接，剩余的 <code>TCP</code> 连接还可以正常传输数据</li></ul></li></ul></li></ul></li></ul></li><li><p>2018年底，<code>IETF</code> 又推出新版本 <code>HTTP/3</code>（<code>QUIC</code> 和 <code>HTTP/3</code>）</p><ul><li>这就是 <code>HTTP/3</code> 的用武之地：它不是使用 <code>TCP</code> 作为会话的传输层，而是使用 <code>QUIC</code> （一种新的互联网传输协议）。该协议率先在传输层将流作为一等公民引入。多个 <code>QUIC </code>流共享相同的 <code>QUIC</code> 连接，因此<code>不需要额外的握手和慢启动</code>来创建新的 <code>QUIC</code> 流。但 <code>QUIC</code> 流是独立交付的，因此在大多数情况下，只影响一个流的丢包不会影响其他流。这是因为 <code>QUIC</code> 数据包封装在 <code>UDP</code> 数据报的顶部。</li><li>与 <code>TCP</code> 相比，使用 <code>UDP</code> 可以提供更大的灵活性，并且可以使 <code>QUIC</code> 实现完全存在于用户空间中——协议实现的更新不像 <code>TCP</code> 那样依赖操作系统的更新。借助 <code>QUIC</code>，可以将 <code>HTTP</code> 级别的流简单地映射到 <code>QUIC</code> 流的顶部，从而在享受 <code>HTTP/2</code> 所有好处的同时避免了<code>行首阻塞</code>。</li><li><code>QUIC</code> 还结合了典型的 <code>3 向 TCP 握手</code>和 <code>TLS 1.3</code> 的握手。结合这些步骤意味着加密和身份验证能够默认提供，并且还可以更快地建立连接。换句话说，即使 <code>HTTP</code> 会话中的初始请求需要新的 <code>QUIC</code> 连接，在数据开始流动之前的等候延迟也比使用 <code>TLS</code> 的 <code>TCP</code> 要低。</li></ul></li><li><p>总结</p><ul><li>&#96;HTTP&#x2F;1.1· 有两个主要的缺点：安全不足和性能不高。</li><li><code>HTTP/2</code> 完全兼容 <code>HTTP/1</code>，是“更安全的 <code>HTTP</code>、更快的 <code>HTTPS</code>“，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验。</li><li><code>QUIC</code> 基于 <code>UDP</code> 实现，是 <code>HTTP/3</code> 中的底层支撑协议。该协议基于 <code>UDP</code>，又汲取了 <code>TCP</code> 中的精华，实现了既快又可靠的协议。</li></ul></li></ul><p>以上就解释了为什么会出现 <code>http/2</code>与<code>http/3</code>？</p><h3 id="http-tls-传输的基本结构"><a href="#http-tls-传输的基本结构" class="headerlink" title="http + tls 传输的基本结构"></a><code>http + tls</code> 传输的基本结构</h3><p><img src="/medias/image/03.jpg" alt="&quot;图片&quot;"></p><ul><li>三次握手后 使用 <code>tls</code> 协议（也是三次握手）沟通传输密钥，最后才是 <code>http</code>内容的请求</li></ul><h3 id="http-3-tls-传输的基本结构"><a href="#http-3-tls-传输的基本结构" class="headerlink" title="http/3 + tls 传输的基本结构"></a><code>http/3 + tls</code> 传输的基本结构</h3><p><img src="/medias/image/04.jpg" alt="&quot;图片&quot;"></p><ul><li>三次握手时 顺便使用 <code>tls</code> 协议沟通传输密钥，最后才是 <code>http</code>内容的请求</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.infoq.cn/article/kU4OkqR8vH123a8dLCCJ">infoQ-解密 HTTP&#x2F;2 与 HTTP&#x2F;3 的新特性</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于php后端的100个话题（一）消息队列</title>
    <link href="/posts/99abd062/"/>
    <url>/posts/99abd062/</url>
    
    <content type="html"><![CDATA[<h2 id="消息队列解决了什么问题？"><a href="#消息队列解决了什么问题？" class="headerlink" title="消息队列解决了什么问题？"></a>消息队列解决了什么问题？</h2><ul><li>消息队列最主要解决了系统间 <strong>数据通信</strong> 的问题</li></ul><h2 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h2><ul><li>异步处理<ul><li>把不重要的同步串行，改成异步，可以更快地返回结果</li><li>减少等待，自然实现了步骤之间的并发，提升系统的性能</li></ul></li><li>流量控制<ul><li>将网关将请求放入请求队列进入等待状态，后端去处理请求队列的参数，然后网关再响应 ，一旦超时就丢弃响应服务错误给请求，来限制流量<ul><li>大致的思路是，网关会把用户的request缓存起来，然后发消息，至于发的消息内容不一定就是这个原封不动的request对象，只要把Request中必要的信息发给后端就可以了。后端服务可以用<code>RPC</code>通知网关秒杀结果，网关收到结果后找到对应的Request来构建Response返回即可。</li></ul></li><li>使用令牌桶<ul><li>控制流量的原理是：单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须先从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求，这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用</li></ul></li></ul></li><li>服务解耦<ul><li>订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中， 多有下游系统都订阅主题 Order 这样每个下游系统都可以获得一份实时完整的订单系统，而不必在创建订单的时候一个个系统进行</li></ul></li></ul><h2 id="常见的消息队列选型"><a href="#常见的消息队列选型" class="headerlink" title="常见的消息队列选型"></a>常见的消息队列选型</h2><ul><li>选型的基本标准<ul><li>开源</li><li>流行，热门，兼容性好</li><li>消息的可靠传递： 不丢消息</li><li>Cluster: 支持集群</li><li>性能：具备足够好的性能</li></ul></li></ul><h2 id="可供选择的消息队列产品"><a href="#可供选择的消息队列产品" class="headerlink" title="可供选择的消息队列产品"></a>可供选择的消息队列产品</h2><ul><li><strong><code>RabbitMQ</code></strong><ul><li>优势<ul><li>轻量级</li><li>灵活的路由配置</li><li>兼容性好</li></ul></li><li>问题<ul><li>对消息堆积的支持并不好，设计理念为消息队列是一个管道，大量的消息挤压是一种不正常的情况</li><li>性能一般，每秒钟可以处理几万到十几万条消息</li><li>使用Erlang 二次开发的可维护性</li></ul></li></ul></li><li><strong><code>RocketMQ</code></strong><ul><li>优势<ul><li>响应时延做了优化，金融级别的稳定性</li><li>国人开发中文社区活跃，每秒钟可以处理几十万条消息</li></ul></li><li>问题<ul><li>国际上没那么流行，与周边生态系统的集成跟兼容要略逊一筹</li></ul></li></ul></li><li><strong><code>Kafka</code></strong><ul><li>优势<ul><li>设计目的是为了处理海量日志，早期版本存在一定问题</li><li>Kafka与周边生态系统的兼容性时最好的，特别是大数据和流计算领域，几乎所有的相关开源系统都会优先支持 Kafka</li><li>异步收发性能是最好的，每秒也是 几十万条消息</li></ul></li><li>问题<ul><li>对于消息数量达不到一定量时，<code>Kafka</code>的时延反而比较高，所以<code>kafka</code>不太适合在线业务场景</li></ul></li></ul></li><li><strong><code>ActiveMQ</code></strong><ul><li>已经进入老年期，性能无法跟现代消息队列做比较，存在的目的是为了兼容老一辈的产品</li></ul></li><li><strong><code>ZeroMQ</code></strong> <ul><li>不是一个纯粹的消息队列，而是一个基于消息队列的多线程网络库</li></ul></li><li>总结<ul><li>一般场景 开箱即用可以考虑**<code>RabbitMQ</code>**</li><li>在线业务，如交易系统可以考虑 <strong><code>RocketMQ</code></strong> </li><li>海量数据处理，收集日志，监控信息，前端埋点，大数据，流计算，Kafka比较适合</li></ul></li></ul><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><ul><li>主题与队列的区别<ul><li>队列 是一种先进先出的线性表，通常使用链表或者数组来实现，队列只允许在后端进行插入，在前端进行删除操作，是严格有序的。<ul><li>早期的消息队列，就是严格按照队列数据结构来设计，队列模式<ul><li>消费者（consumer）《—- 队列《—- 生产者（producer）</li><li>特点<ul><li>如果有多个消费者，消费者之间是竞争的关系，每个消费者只能接受到队列中的一部分消息</li></ul></li><li>不足之处<ul><li>如果需要把一份消息数据分配给多个消费者，要求每个消费者都能收到全量的消息，就很难做到了</li></ul></li></ul></li><li>另一种消息队列 发布-订阅模型（Publish-Subscribe Pattern）<ul><li>发布者 Publisher<ul><li>发送——-》主题Topic</li></ul></li><li>订阅者 Subscribe<ul><li>订阅主题 </li><li>从主题中 接受 —–》消息</li></ul></li></ul></li><li>两者最大的区别就是，一份消息数据能不能被消费多次的问题</li><li><code>RabbitMQ</code> 的消息模型<ul><li>现代的消息队列产品使用的消息模型大多是这种发布-订阅模型，但是 <code>RabbitMQ</code> 坚持使用 队列模型</li><li><code>RabbitMQ</code> 解决发布订阅问题的方案是 处于生产者与队列之间的Exchange 模块<ul><li>生产者 Producer</li><li>Exchange<ul><li>队列1 —》消费者</li><li>队列2 —》消费者</li></ul></li><li><img src="/images/02.jpg" alt="图片"></li></ul></li><li>由Exchange将消息发送到多个队列，这样就变相实现了发布订阅模型</li></ul></li><li><code>RocketMQ</code> 的消息模型<ul><li>中规中矩的<code>RocketMQ</code> 属于发布-订阅模型</li><li><img src="/images/01.jpg" alt="&quot;图片&quot;"></li><li>消息队列的请求确认机制<ul><li>生产者向主题中投放 消息时 一定要主题响应成功，它才会确认已经存入，不然会再次投放</li><li>消费者在收到消息完成业务逻辑后也会向消息队列端响应消费成功的信息，不然就会一直给消费者发送消息</li><li>也就是说每个主题任意时刻，只会有一个消费者实例来消费，效率太低</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong><code>RabbitMQ</code></strong></h2><ul><li><code>RabbitMQ</code>安装教程 <a href="https://segmentfault.com/a/1190000018916099">https://segmentfault.com/a/1190000018916099</a> </li><li>基础使用教程（一 ~ 五）<ul><li><a href="https://segmentfault.com/a/1190000011825148">https://segmentfault.com/a/1190000011825148</a></li><li><a href="https://segmentfault.com/a/1190000011829380">https://segmentfault.com/a/1190000011829380</a></li></ul></li><li>点对点模式  一个生产者者一个消费者模式<ul><li>生产者生成数据送往 管道</li><li>消费者监听管道消费数据</li><li>模式的特点在于实时性，你发了我马上就能知道，并能处理</li><li>模式的缺点在于易堆积，一个消费者一次只能处理一条消息，要是处理时间比较长，就会消息堆积，影响正常业务</li></ul></li><li>一个生产者多个消费者模式<ul><li>一个生产者生成数据送往管道</li><li>多个消费者监听管道消费数据</li><li>模式的特点在于实时性，你发了我马上就能知道，多开几个消费者总能及时的去处理数据</li><li>模式的缺点在于资源浪费，你要按照最大峰值去配置消费者的数量</li></ul></li><li>消息确认机制<ul><li>我发你了—-》我收到了OK 结束 </li><li>我发你了—-》我觉得有问题  循环到 出现我收到了为止</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>php后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java学习笔记（一）</title>
    <link href="/posts/cd1a8393/"/>
    <url>/posts/cd1a8393/</url>
    
    <content type="html"><![CDATA[<h2 id="java-执行流程"><a href="#java-执行流程" class="headerlink" title="java 执行流程"></a><code>java</code> 执行流程</h2><ul><li><code>java</code> 粗略执行流程<ul><li>源文件编译成 <code>.class</code> 字节码文件 <code>-&gt;</code>解释执行 <code>jre</code>( 装载 <code>-&gt;</code> 字节码校验 <code>-&gt;</code> <code>jvm</code> 执行)</li><li><code>jdk</code> 包含了 <code>javac</code> <code>jre</code> <code>debugging</code> <code>tools</code> <code>javap</code></li></ul></li><li><code>javeSE</code>(<code>java</code>标准版本) <code>JAVAEE</code>(<code>java</code>商业版) 与 <code>JAVAME</code>(设备专用) 一般分为这三块</li></ul><h3 id="第一个-java-程序"><a href="#第一个-java-程序" class="headerlink" title="第一个 java 程序"></a>第一个 java 程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<span class="hljs-comment">// 这里的分号必加</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>注意点</p><ul><li>需要先使用 <code>javac</code> 编译出 <code>.class</code> 文件 再执行 <code>java</code></li><li>源文件只能有一个跟文件名相同的 <code>public</code> 类名</li><li><code>main</code> 方法为 <code>java</code> 固定入口 有固定的书写格式 <code>public static void main(String[] args)&#123;&#125;</code></li><li><code>JAVA</code> 对大小写敏感</li><li><code>windows</code> 安装后 1.5以上只需要 设置 <code>JAVAHOME /path/to</code> 与<code>%JAVA_HOME%\bin</code> 便于执行 <code>java -version</code> <code>javac</code>…</li></ul></li><li><p><code>eclipse</code> 编辑器<a href="https://www.eclipse.org/downloads/packages/">下载地址</a> 确实下的很慢</p><ul><li>如何打开 <code>package explorer</code> 在 <code>windows</code> 里面的 <code>show view</code> 下的 <code>package explorer</code></li></ul></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>&#x2F;&#x2F; 单行注释</li><li>&#x2F;* 多行注释 *&#x2F;</li><li>&#x2F;** 文档注释 *&#x2F;</li><li>注释是不会出现在字节码文件中的</li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>可以用 <code>_ $</code> 字母 开头 建议使用小驼峰，不要使用 <code>$</code>与 <code>_</code> 开头</li><li>大小写敏感，不能用关键字</li><li>类名 大驼峰 , 其它小驼峰</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量名称</p><ul><li>见标识符</li></ul></li><li><p>变量类型</p></li><li><p>变量作用域</p><ul><li><p>局部变量</p><ul><li>方法或者语句块中定义的变量</li><li>使用时必须要先 &#x3D;&#x3D;初始化&#x3D;&#x3D;</li><li>生命周期从声明位置开始到语句块 比如<code>&#123;&#125;</code> 或者 方法执行完毕为止</li></ul></li><li><p>成员变量</p><ul><li><p>也叫实例对象(member variable)方法外部，类的内部定义的变量，从属于&#x3D;&#x3D;对象&#x3D;&#x3D;，</p></li><li><p>生命周期伴随对象始终</p></li><li><p>如果不赋值，它会自动初始化成该类型的默认初始化值</p><table><thead><tr><th align="center">数据类型</th><th align="center">实例化初始值</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">0</td></tr><tr><td align="center">double</td><td align="center">0.0</td></tr><tr><td align="center">char</td><td align="center"><code>&#39;\u0000&#39;</code></td></tr><tr><td align="center">boolean</td><td align="center">false</td></tr></tbody></table></li></ul></li><li><p>静态变量</p><ul><li>使用 static 定义，从属于&#x3D;&#x3D;类&#x3D;&#x3D;，生命周期伴随类始终，从类加载到卸载</li></ul></li></ul></li><li><p>变量声明 与 初始化</p><ul><li>int ss 声明</li><li>int ss &#x3D; 2 声明并赋值</li></ul></li></ul><h3 id="常量（Constant）"><a href="#常量（Constant）" class="headerlink" title="常量（Constant）"></a>常量（Constant）</h3><ul><li>声明后值不会改变的量叫常量</li><li>使用 <code>final</code> 关键字可以将变量转为<code>符号常量</code></li><li>1,’2’,3,”hello” 属于<code>字面常量</code> 也就是说直接写出来的常量</li></ul><h3 id="基本数据类型（primitive-data-type）"><a href="#基本数据类型（primitive-data-type）" class="headerlink" title="基本数据类型（primitive data type）"></a>基本数据类型（primitive data type）</h3><ul><li>数值<ul><li>整数类型(<code>byte 1字节8位,short 2,int 4,long 8</code>)</li><li>浮点类型(<code>float 4,double 8</code>)字节</li><li>字符型（<code>char</code>）2字节</li><li>布尔型（<code>boolean</code>）1位</li></ul></li><li>引用数据类型 <code>4字节存储对象的地址</code><ul><li>类 <code>class</code></li><li>接口 <code>interface</code></li><li>数组 <code>array</code></li></ul></li></ul><h4 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h4><table><thead><tr><th>类型</th><th>占用存储空间</th><th>表示范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节 8位</td><td>-2^7 ~ 2^7-1(-128~127)</td></tr><tr><td>short</td><td>2字节 16位</td><td>-2^15 ~ 2^15-1(-32768~32767)</td></tr><tr><td>int</td><td>4字节 32位</td><td>-2^31 ~ 2^31-1 约21亿</td></tr><tr><td>log</td><td>8字节 64位</td><td>-2^63 ~ 2^63-1</td></tr></tbody></table><ul><li>进制<ul><li>八进制 以 0 开头</li><li>十六进制 以 <code>0x</code>或者 <code>0X</code> 开头 <code>0x15</code></li><li>二进制 要求以 <code>0b</code>或者<code>0B</code>开头， <code>0b01110011</code></li></ul></li><li><strong>long 类型需要显示的加上 &#x3D;&#x3D;L&#x3D;&#x3D;</strong> 不加<code>l</code> 是避免混淆<ul><li><code>long e = 222222222L</code>;</li></ul></li></ul><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><table><thead><tr><th>类型</th><th>占用存储空间</th><th>表示范围</th></tr></thead><tbody><tr><td>float</td><td>4字节 32位</td><td><code>-3.403E38</code> ~&#96; 3.403E38&#96;</td></tr><tr><td>double</td><td>8字节 64位</td><td><code>-1.798E308</code> ~ <code>1.798E308</code></td></tr></tbody></table><ul><li>浮点数的表示形式<ul><li>十进制 3.14 314.0 0.314</li><li>科学计数法 <code>314e2 314*100</code> <code>134E-2 314/100</code></li></ul></li><li><code>float</code> 可以表示&#x3D;&#x3D;7&#x3D;&#x3D;位有效数字<ul><li><code>float</code> 类型 &#x3D;&#x3D;<strong>必须</strong>&#x3D;&#x3D; 要 在后面加上 <strong>F</strong></li></ul></li><li><code>double</code> 可以表示&#x3D;&#x3D;15&#x3D;&#x3D;位有效数字<ul><li><code>bouble</code> 为<code>默认小数的类型</code> 如 <code>3.13 或 3.14D</code> 也可以在后面加上 <code>D</code></li></ul></li><li>浮点数<code>运算</code>与<code>比较</code>都是不精确的，一般使用 <code>java.math</code>的 <code>BigInterge</code>,<code>BigDecimal</code> 类用于不容许舍入误差的金融计算领域</li></ul><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><ul><li><code>char</code> 是表示 <code>Unicode</code> 编码的一种实现 <code>2</code>字节 <code>65535</code></li></ul><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><ul><li><code>true</code> | <code>false</code></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>算术运算符</td><td>二元运算符</td><td>+，-，*，&#x2F;，%</td></tr><tr><td>算术运算符</td><td>一元运算符</td><td>++，–</td></tr></tbody></table><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>扩展运算符</td><td>+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</td></tr><tr><td>关系运算符</td><td>&gt;,&lt;, &gt;&#x3D; ,&lt;&#x3D;,&#x3D;&#x3D; ,!&#x3D;, <code>instanceof</code></td></tr><tr><td>逻辑运算符</td><td><code>&amp;&amp;</code>,&#96;</td></tr><tr><td>位运算符</td><td><code>&amp;</code> ，&#96;</td></tr><tr><td>条件运算符</td><td>？</td></tr><tr><td>字符串连接运算符</td><td>+</td></tr></tbody></table><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><ul><li>算术运算符<ul><li>整数运算<ul><li>两个操作数，只要有一个为<code>long</code> 结果为<code>long</code></li><li>没有<code>long</code> 时结果为<code>int</code>,即使操作数全为<code>short</code> 或 <code>byte</code> 结果也是 <code>int</code></li></ul></li><li>浮点运算<ul><li>如果两个数有一个为 <code>double</code> 结果为 <code>double</code></li><li>&#x3D;&#x3D;只有两个数都是&#x3D;&#x3D; <code>float</code> 结果才是 <code>float</code></li></ul></li><li>取模运算<ul><li>其操作数可以为<strong>浮点数</strong>，结果为还是按上面规则走</li><li>余数的符号跟&#x3D;&#x3D;左边操作数的符号&#x3D;&#x3D;相同</li><li><code>7%3=1</code> <code>-7%3=-1</code> <code>7%-3=1</code> <code>3.14%3=0.14000000000000012</code></li></ul></li><li><code>++</code> <code>--</code><ul><li><code>前++</code> 与<code>后++</code> 的区别 先赋值还是后赋值的问题</li></ul></li></ul></li></ul><h4 id="赋值运算符与扩展运算符"><a href="#赋值运算符与扩展运算符" class="headerlink" title="赋值运算符与扩展运算符"></a>赋值运算符与扩展运算符</h4><ul><li><code>=</code> <code>+=</code> …</li></ul><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><ul><li><code>&lt;,&gt;,&lt;=,=&gt;,!=</code> 结果为 <code>boolean</code></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li><code>^</code> 相同为 <code>false</code> 不同为 <code>true</code> <code>&amp; | !</code> 用与<code>bool</code>数之间是比较 用于 <code>int</code> 数之间为位运算</li><li>注意 <code>&amp;</code>与<code>|</code> 还有 <code>&amp;&amp;</code> 与 <code>||</code> 的 逻辑短路现象</li></ul><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul><li><code>&lt;&lt; 1</code>乘<code>2</code>   <code>&gt;&gt; 1</code>除以<code>2</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">as</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>System.out.println(~as); <span class="hljs-comment">//-2</span><br>System.out.println(bs&lt;&lt;<span class="hljs-number">2</span>); <span class="hljs-comment">//8</span><br>System.out.println(bs&gt;&gt;<span class="hljs-number">1</span>); <span class="hljs-comment">//1</span><br>System.out.println(bs&gt;&gt;<span class="hljs-number">3</span>); <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h4 id="字符串连接符"><a href="#字符串连接符" class="headerlink" title="字符串连接符"></a>字符串连接符</h4><ul><li><code>+</code> 前后 如果有一者为 字符串 那么就变成字符串连接操作</li></ul><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><ul><li>三目（元）运算符 <code>a?x:y;</code></li></ul><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><table><thead><tr><th>优先级</th><th>运算符</th><th>类</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td><code>&#123;&#125;</code></td><td>括号运算符</td><td>由左至右</td></tr><tr><td>2</td><td><code>！</code>，<code>+</code>（正号），<code>-</code>（负号）</td><td>一元运算符</td><td>由左至右</td></tr><tr><td>2</td><td><code>~</code></td><td>位逻辑运算符</td><td>由右至左</td></tr><tr><td>2</td><td><code>++</code>，<code>--</code></td><td>递增递减运算符</td><td>由右至左</td></tr><tr><td>3</td><td><code>*</code>，<code>/</code>，<code>%</code></td><td>算术运算符</td><td>由左至右</td></tr><tr><td>4</td><td><code>+</code>，<code>-</code></td><td>算术运算符</td><td>由左至右</td></tr><tr><td>5</td><td><code>&lt;&lt;</code>，<code>&gt;&gt;</code></td><td>位运算符</td><td>由左至右</td></tr><tr><td>6</td><td><code>&lt;</code>,<code>&gt;</code>，<code>&gt;=</code>,<code>&lt;=</code></td><td>关系运算符</td><td>由左至右</td></tr><tr><td>7</td><td><code>==</code>，<code>!=</code></td><td>关系运算符</td><td>由左至右</td></tr><tr><td>8</td><td><code>&amp;</code></td><td>位运算符,逻辑运算符</td><td>由左至右</td></tr><tr><td>9</td><td><code>^</code></td><td>位运算符，逻辑运算符</td><td>由左至右</td></tr><tr><td>10</td><td>&#96;</td><td>&#96;</td><td>位运算符，逻辑运算符</td></tr><tr><td>11</td><td><code>&amp;&amp;</code></td><td>逻辑运算符</td><td>由左至右</td></tr><tr><td>12</td><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td>13</td><td><code>?:</code></td><td>条件运算符</td><td>由右至左</td></tr><tr><td>14</td><td><code>=</code>,<code>+=</code>,<code>-=</code>,<code>*=</code>,<code>/=</code>,<code>%=</code></td><td>赋值运算符，扩展运算符</td><td>由右至左</td></tr></tbody></table><ul><li><code>！</code>&gt;<code>&amp;</code>&gt;<code>^</code>&gt;<code>|</code>&gt;<code>&amp;&amp;</code>&gt;<code>||</code></li><li>a||b&amp;&amp;c 意思是 a||(b&amp;&amp;c)</li><li>简记为 &#x3D;&#x3D;算术&gt;关系&gt;逻辑&#x3D;&#x3D; 也就是先运算再比较最后为赋值</li></ul><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><ul><li>原则为 容量小转换为 容量大的 （不一定是字节数）</li><li><code>byte--&gt;short--&gt;int--&gt;long</code></li><li><code>char--&gt;int</code></li><li><code>int--&gt;double</code></li><li><code>int--&gt;float</code>(精度丢失)</li><li><code>int--&gt;double</code></li><li><code>long--&gt;float</code>(精度丢失)</li><li><code>long--&gt;double</code> (精度丢失)</li><li><code>float--&gt;double</code></li></ul><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li>强制类型转换进行运算的时候先要考虑溢出情况</li><li>只需要在变量前面加上<code>（type）</code> 就能强制转换，可强制转换的 type 只包括数值与字符类型</li><li><code>double x = 3.14;</code> <code>int nx = (int)x</code></li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ul><li>if 单选择结构</li><li>if else 双选择结构</li><li>if else if else 多选择结构<ul><li>else if 中间必须加空格</li></ul><p></p></li><li>switch 多选择结构<ul><li>跟 <code>php</code> 没什么区别</li><li>switch中<code>case</code>标签在 <code>jdk1.5</code> 以前必须是整数（long类型除外）或者，枚举，不能是字符串</li><li>在 <code>jdk1.7</code> 以后允许使用字符串（String）</li></ul></li></ul><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul><li>while(布尔表达式){ 循环体 }</li><li>do{ 循环体 }while(布尔表达式)</li><li>for(赋值,赋值;比较条件,默认值){ 循环体 }<ul><li>支持逗号隔开的多重初始化</li><li>赋值的作用域仅限于循环内部使用</li></ul></li><li>break &#x2F; continue<ul><li>带标签的break   <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i =<span class="hljs-number">1</span>;<br>outime:<span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">100</span>) &#123;<br><span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">100</span>) &#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">22</span>) &#123;<br><span class="hljs-keyword">break</span> outime;<br>&#125;<br>i++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>没有 goto 语法，标签仅限于一个循环（单&#x2F;嵌套）体内部使用</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>program language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>think-工作方法论</title>
    <link href="/posts/344cac0c/"/>
    <url>/posts/344cac0c/</url>
    
    <content type="html"><![CDATA[<h2 id="论如何高效且有质量的处理工作"><a href="#论如何高效且有质量的处理工作" class="headerlink" title="论如何高效且有质量的处理工作"></a>论如何高效且有质量的处理工作</h2><ul><li>目的 预测 实践 反馈</li><li>SMART原则构成<ul><li>绩效指标必须是具体的（Specific）</li><li>绩效指标必须是可以衡量的（Measurable）</li><li>绩效指标必须是可以达到的（Attainable）</li><li>绩效指标是要与其他目标具有一定的相关性(Relevant)</li><li>绩效指标必须具有明确的截止期限（Time-bound）</li></ul></li></ul><h2 id="其它待整理的方法论"><a href="#其它待整理的方法论" class="headerlink" title="其它待整理的方法论"></a>其它待整理的方法论</h2><ul><li>大圈小圈：指导职场晋升的方法论<ul><li>影响圈是自己本质，是基础；关注圈是扩展区域，是下一步发展；只有把影响圈做好才能进一步扩大影响圈；</li><li>虽然关注圈对你当下的绩效产出往往没有很明显的价值，但是只有提前关注关注圈，你才有机会，也才有可能扩大影响圈。</li><li>所以，当你抱怨“自己怀才不遇”的时候，请首先反思的问题是：我当下的“影响圈”做到极致了吗？</li><li>80% 的精力 用与关注影响圈内部，20%的精力用于关注影响圈外部</li></ul></li><li>721原则 ：指导个人发展的方法论<ul><li>技能获得：70% 是由实践获得，20% 是学习获得，10% 是培训（被指导）获得。</li><li>推论一：最快学习路径是：优先选择学习，能够立刻或者即将实践的知识或技能<ul><li>推论看似简单，但是周围，往往有很多人都没有注意到这一点；比如他们往往更注重于：更前沿知识（专刊、博客），而忽略了那些能够直接在工作中实践的知识点。</li><li>一个人的从小白成为某项领域的专家，所需要学习的知识会非常多；如果你规划好整体学习知识点后，其实如何让自己快速的成长，就是一个路径选择问题。</li></ul></li><li>推论二：请不要尝试，只通过学习或者培训方式，能够掌握某项技能或者成为某方面的专家<ul><li>如果你想尽快真正的成为某方面的专家，这个方法告诉你的是：最重要的首先要考虑如何实践或者哪儿可以找到实践机会</li></ul></li></ul></li><li>人无完人：自我驱动的方法论<ul><li>简单说解决方案有：向上、横向、向下沟通问题收集；横向对比，和高阶同学对比思考差距在那里；思考学习哪些知识来开拓自己的当前面临的视野局限问题等等</li><li>第一层循环：在层次内，提升的过程</li><li>第二层循环：是突破层次的瓶颈，达到上一个层次的过程</li></ul></li><li>抽象问题具体化，具体问题抽象化：解决实际问题的方法论<ul><li>1、在问题分析时多从全局观进行思考，而不是局限在问题本身。</li><li>2、问题最后抽象到的最后只有两类：技术问题 or 管理问题（流程）。切忌把一切问题都归到“人的问题”上</li></ul></li></ul><h2 id="如何思考与有效工作"><a href="#如何思考与有效工作" class="headerlink" title="如何思考与有效工作"></a>如何思考与有效工作</h2><ul><li>该如何更高效地工作，怎样才能把时间和精力尽可能地放在处理本质复杂度的事情上，减少在偶然复杂度上的消耗</li></ul><h3 id="我们在哪-我们要去哪-我们怎么去-这种方法论"><a href="#我们在哪-我们要去哪-我们怎么去-这种方法论" class="headerlink" title="我们在哪 我们要去哪 我们怎么去 这种方法论"></a>我们在哪 我们要去哪 我们怎么去 这种方法论</h3><ul><li>如果一个人能够清晰地回答出这三个问题，通常意味着他对要做的事有着清晰的认识</li><li>优秀程序员的开发效率是普通程序员的 10 倍</li></ul><h3 id="四个思考原则"><a href="#四个思考原则" class="headerlink" title="四个思考原则"></a>四个思考原则</h3><ul><li>以终为始<ul><li>真正的目标</li></ul></li><li>任务分解<ul><li>分解越细致，工作越轻松</li></ul></li><li>沟通反馈<ul><li>是为了疏通与其他人交互的渠道。一方面，我们保证信息能够传达出去，减少因为理解偏差造成的工作疏漏；</li><li>另一方面，也要保证我们能够准确接收外部信息，以免因为自我感觉良好，阻碍了进步。</li></ul></li><li>自动化<ul><li>就是将繁琐的工作通过自动化的方式交给机器执行</li><li>形成完善的层次，完善到可以自动化代码生成</li></ul></li></ul><h3 id="当面对一个新需求时"><a href="#当面对一个新需求时" class="headerlink" title="当面对一个新需求时"></a>当面对一个新需求时</h3><ul><li>为什么要做这个特性，它会给用户带来怎样的价值？</li><li>什么样的用户会用到这个特性，他们在什么场景下使用，他们又会怎样使用它？</li><li>达成这个目的是否有其它手段？是不是一定要开发一个系统？</li><li>这个特性上线之后，怎么衡量它的有效性？</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>大多数人工作低效是由于工作中偶然复杂度太多造成的，只要能够更多地将注意力放到本质复杂度上，减少偶然复杂度造成的消耗，我们“真实”的工作效率自然会得大幅度提升。</li><li>我们不是一个人孤独地在工作，而是与其他人在协作，想要做到高效工作，我们就要“抬起头”来，跳出写代码这件事本身。 所以，程序员解决的问题，大多不是程序问题。</li><li>面对问题 现状 目标与路径</li></ul><h3 id="五级工程师理论"><a href="#五级工程师理论" class="headerlink" title="五级工程师理论"></a>五级工程师理论</h3><h4 id="第五级工程师"><a href="#第五级工程师" class="headerlink" title="第五级工程师"></a>第五级工程师</h4><ul><li><p>能够独立设计和实现一项功能的人</p></li><li><p>这是对工程师的基本要求，如果一个人只是懂一点工程实现的手段，需要别人告诉他怎么做，那最多算是助理工程师或者技工。虽然能独立写出一项功能，关于业务的内容完全都是问需求经理啊，技工是说的好听，其实就是最底层开发人员，以后要加强工程师的概念，努力向上一级跃进。</p></li></ul><h4 id="第四级工程师"><a href="#第四级工程师" class="headerlink" title="第四级工程师"></a>第四级工程师</h4><ul><li><p>需要有些产品头脑</p></li><li><p>在做一件事之前，要知道所做出来的东西是否有用 、易用，是否便于维护，是否性能稳定，等等。除了要具备产品设计方面的基本知识，还要具有一定的领导才能，能在整个产品的生命周期从头到尾将一个产品负责到底。这在很多硅谷的公司里，基本上是一个高级工程师所应有的基本素质。对大部分工程师来讲，这些素质不是一个工学院就能培养出来的，而是需要在工业界实际锻炼三四年甚至更长时间。当然。个别天赋很好的年轻人在学校里就具备了这种素质，但这是可遇不可求的。</p></li><li><p>这需要长时间的锻炼和自己的悟性，这个阶段的工程师就像是组内的开发组长、系统架构师之类的角色，对技术使用纯熟，并有产品经理的素质，会从用户角度考虑产品的易用性，会从运维工程师角度考虑系统的可维护性，会从下批搞二次开发的程序员角度考虑系统的可读性与可扩展性等。这个确实需要时间和精力去锤炼技术水平和产品意识。</p></li></ul><h4 id="第三级工程师"><a href="#第三级工程师" class="headerlink" title="第三级工程师"></a>第三级工程师</h4><ul><li><p>可以做出行业里最好的产品</p></li><li><p>他们与第四等工程师有着质的差别，这不仅反映在技术水平、对市场的了解 、对用户心理的了解以及组织能力等诸方面，而且也反映在悟性的差异上。当然这种悟性很多是后天培养出来的，但这就需要更长的时间了。有些人从工作一开始，可能需要十年八年，经过多次失败，不断总结，终于在某个时间点豁然开朗。而另一些人可能非常幸运，在一开始就有幸和最优秀的人一起工作，加上善于学习，五六年下来就能达到第三等的水平。在硅谷，有极少数工程师只花了五六年时间就达到了这个水平。但是即使一个人再聪明，基础再好，也需要在工程上花够足够的时间才能达到这个水平，一个年轻人工作了四五年就开始做行政管理工作，基本上就和这个水平无缘了。</p></li><li><p>到这一级别的工程师，由于心智坚定加上长期的刻苦努力再加上个人的天赋和一些机遇，终于一飞冲天。都说机会是给有准备的人的，这类人其实就是被机会垂青的一类人，因为他们确实有准备，也准备的很充分。他们是行业内的佼佼者，对技术、产品都有自己的一套感觉、系统，都有自己独到的认识，并做出过业内称赞的产品。我觉得在一等的工程师里也可以分三等，初级、中级和高级。初级就是经过自己的长期努力，对技术掌握扎实，对新技术也有很快的理解能力和应用能力，能够胜任一般公司产品经理、CTO的角色。中级就是在初级的基础上，加上了个人的艺术修养，加上了个人长期经验、经历、感悟的总结，形成了一套完整的对技术、产品、美学、用户、包括市场的基础正确的认识，这超越了大多数技术好的工程师。这一级别高段位的工程师，就有点需要借助些小的时运了，比如刚好移动互联网兴起，刚好加入移动互联创业公司，刚好开发出了能行业执牛耳的产品。</p></li></ul><h4 id="第二级工程师"><a href="#第二级工程师" class="headerlink" title="第二级工程师"></a>第二级工程师</h4><ul><li><p>刻意给世界带来惊喜的人</p></li><li><p>比如实现第一台实用化个人电脑的沃兹尼亚克(这个在池老师的《跨越边界》里有专门一章讲他，并他合照)、DSL之父约翰西奥菲、iPhone和Google Glass的总设计师，以及前面提到的鲁宾、迪恩等。他们与第三、四等工程师的差别在于其工作的原创性以及对世界的影响力。当然他们的工作不是科学研究，这一点和科学家毕竟不同。</p></li><li><p>关于这一点，吴军博士还专门介绍过硅谷的公司有多元的文化，开发产品会立足于世界，多语言版本不会比英语版本晚六个月。因此公司的很多产品就是世界级产品，还提到微信的国际化走的不顺畅，只是在国内是爆品。</p></li></ul><h4 id="第一级工程师"><a href="#第一级工程师" class="headerlink" title="第一级工程师"></a>第一级工程师</h4><ul><li><p>开创一个全新行业的人</p></li><li><p>历史上有爱迪生（直流电等）、特斯拉（交流电等）、福特，二战后有保时捷博士、本田宗一郎和硅谷的诺伊斯（集成电路等）等人。这些工程师不仅在技术和产品等各个方向与第二等工程师有质的差别，而且在经验和管理上也是好手，他们通常是企业家，并通过自己的产品改变了世界。这一类人常常是可遇而不可求的，正如朗道列出的第一等物理学家只有个位数一样，第一等的工程师也是如此。朗道认为每一等物理学家之间的贡献相差十倍，每一等的工程师差距也是这么大。当然很多企业家都希望能够遇到一些第二等甚至第一等的工程师，这就需要由工程师构建的完整金字塔：要想出几个第一等的工程师，就需要有足量的第二等工程师作为基础；同样，产生第二等工程师要靠大量的第三等工程师为基础。在一个产业里，不可能指望在一大堆第五等工程师的基础上突然冒出一两个第一或者第二等的工程师的。甚至有时，即时高薪聘请来一个第二等的工程师，如果没有第三、第四等的工程师与之配合，他也很难直接依靠第五等的人做出一流的产品。</p></li><li><p>第一等的工程师，完全是和推动人类文明进步最有力的人归为一类的，他们永远是时代的先行者，时代的开拓者，处于时代的浪潮之巅。</p></li><li><p>和马斯洛的五层需求理论类似，永远都是一级依靠一级，每上层级都需要大量的下一级作为支撑与配合，然而在大多中国IT企业里，大家喜欢当领导，也有许多在选择做技术还是管理两者间纠结的人，所以在第五等工程师上会有断层，影响到产品开发的质量和原创性。</p></li></ul><h2 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h2><ul><li>遇见事情，倒着想，远见不是天生会有的，不断预测，失败后加以复盘，整理自己思维误区才能走的更远</li><li>构建一个共同的想象</li><li>测试驱动开发，</li><li>践行“以终为始”就是在做事之前，先考虑结果，根据结果来确定要做的事情。</li><li>向后工作的方法，开发一项产品的顺序为：<ul><li>写新闻稿；</li><li>写 FAQ（常见问题解答）；</li><li>写用户文档；</li><li>写代码。</li></ul></li><li>拿到一个需求先写接口文档，评审过了再开发代码。争取做到接口文档就是最终的实现方案，不需要做着做着再去沟通方案。而不是拿了需求文档，直接就写代码。</li><li>定好目标后，倒推时间表，安排好每一步要做的事情。梳理出关键节点，提前发现问题。</li></ul><h3 id="对于完成的定义不一致"><a href="#对于完成的定义不一致" class="headerlink" title="对于完成的定义不一致"></a>对于完成的定义不一致</h3><ul><li>DoD 对于完成的定义 Definition of Done<ul><li>DoD 是一个清单，清单是由一个个的检查项组成的，用来检查我们的工作完成情况。</li><li>DoD 的检查项应该是实际可检查的。</li><li>DoD 是团队成员间彼此汇报的一种机制。别把“汇报”想复杂了，最简单的汇报就是说一句“这个功能做完了”。</li><li>当我们有了 DoD，做事只有两种状态，即“做完”和“没做完”。</li></ul></li><li>它不仅局限在团队内部协作上，如果你可以放开思路，会发现 DoD 的思维在工作中用途非常广泛。</li><li>DoD 是一个的思维模式，是一种尽可能消除不确定性，达成共识的方式。</li><li>人与人协作，总会有这样或那样的理解差异。开始协作之前，我们最好先同步一下彼此的理解，确保之后不会因为理解不一致，而让协作方措手不及.</li></ul>]]></content>
    
    
    <categories>
      
      <category>思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>database design（一）范式</title>
    <link href="/posts/53433fc6/"/>
    <url>/posts/53433fc6/</url>
    
    <content type="html"><![CDATA[<h2 id="范式与实现"><a href="#范式与实现" class="headerlink" title="范式与实现"></a>范式与实现</h2><ul><li>目前关系数据库有六种范式：第一范式（1NF）、</li><li>第二范式（2NF）、</li><li>第三范式（3NF）、</li><li>巴斯-科德范式（BCNF）、</li><li>第四范式(4NF）</li><li>和第五范式（5NF，又称完美范式）</li><li>满足最低要求的范式是第一范式（1NF）在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。</li><li>一般来说，数据库只需满足第三范式(3NF）就行了</li></ul><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><ul><li>所谓第一范式（1NF）是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。</li><li>即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。</li><li>简而言之，第一范式就是无重复的域。</li><li>每一项都是独立与原子，不可分割</li></ul><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><ul><li>在第一范式的基础上</li><li>要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，</li><li>如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。</li><li>为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。</li><li>简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。1对1</li></ul><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><ul><li>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li><li>第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</li><li>如员工表不应出现部门名称的属性</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang base (three)</title>
    <link href="/posts/d987e558/"/>
    <url>/posts/d987e558/</url>
    
    <content type="html"><![CDATA[<h2 id="error-处理"><a href="#error-处理" class="headerlink" title="error 处理"></a>error 处理</h2><ul><li><p>没有异常机制</p></li><li><p>error 类型实现了 error 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span>&#123;<br>    Error <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以通过 errors.New 来快速创建错误实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go">errors.New(<span class="hljs-string">&quot; error info&quot;</span>)<br><span class="hljs-keyword">var</span> NumberLess2Error =  errors.New(<span class="hljs-string">&quot;n must be not less than 2&quot;</span>)<br><span class="hljs-keyword">var</span> NumberLarger100Error =  errors.New(<span class="hljs-string">&quot;n must be not larger than 100&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetFibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (c []<span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 及早失败</span><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>  &#123;<br>        err = NumberLess2Error<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">100</span>  &#123;<br>        err = NumberLarger100Error<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    c = <span class="hljs-built_in">append</span>(c, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>    a, b := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        a, b = b, a+b<br>        c = <span class="hljs-built_in">append</span>(c, b)<br>    &#125;<br>    <span class="hljs-keyword">return</span> c, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetFibonacci</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n,err := GetFibonacci(<span class="hljs-number">-10</span>);err!=<span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">if</span> err == NumberLess2Error&#123;<br>            fmt.Printf(<span class="hljs-string">&quot;less &quot;</span>)<br>        &#125;<br>        t.Error(err)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        t.Log(n)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="panic-与-recover"><a href="#panic-与-recover" class="headerlink" title="panic 与 recover"></a><code>panic</code> 与 <code>recover</code></h2><ul><li><p><code>panic</code> 与 <code>os.Exit</code></p><ul><li><code>os.Exit</code> 退出时不会调用 defer 指定的函数</li><li><code>os.Exit</code> 退出时不输出当前调用栈信息</li></ul></li><li><p><code>recover</code> 错误恢复,类似于java与php 的 try{}catch(){}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPanicVxExit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;recover from:&quot;</span>, err)<br>&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;Start&quot;</span>)<br><span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;Something is Wrong&quot;</span>))<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>recover 成为恶魔</p><ul><li>形成僵尸服务进程，导致  health check 失效</li><li>“Let it Crash!” 往往是我们恢复不确定性的最好方法 简称实在不行就重启</li></ul></li></ul><h2 id="package-构建可复用的模块"><a href="#package-构建可复用的模块" class="headerlink" title="package 构建可复用的模块"></a>package 构建可复用的模块</h2><ul><li>基本复用单元<ul><li>以首字母大写来表明可被包外当代码访问</li></ul></li><li>代码的package 可以和所在目录不一致</li><li>同一目录里的 Go 代码的 package 要保持一致</li><li>init 方法<ul><li>在main被执行前，所有依赖的 package 的init 方法 都会被执行</li><li>不同包的init 函数按照包的依赖关系决定执行顺序</li><li>每个包可以有多个init 函数</li><li>包的每个源文件也可以有多个 init 函数，这点很特殊</li></ul></li><li>通过go get 来获取远程依赖<ul><li>go get -u 每次都去拉取最新的包</li><li>包是从GOPATH&#x2F;src&#x2F; 开始算的</li></ul></li><li>注意代码在Github 上的组织形式，以适应 go get<ul><li>直接以代码路径开始，不要有src</li></ul></li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul><li>Go未解决的依赖问题<ul><li>同一环境下，不同项目使用同一包的不同版本</li><li>无法管理对包的特定版本的依赖</li></ul></li><li>vendor 路径<ul><li>随着 Go 1.5 版本的发布，vendor目录被添加到除了GOPATH 与 GOROOT 之外的依赖目录查找方案，在go 1.6以前，需要手动的设置环境变量</li></ul></li><li>查找依赖包路径的解决方案如下<ul><li><ol><li>在当前包下的 vendor 目录</li></ol></li><li><ol start="2"><li>向上级目录查找，直到找到src下的 vendor 目录</li></ol></li><li><ol start="3"><li>在 GOPATH 下面查找</li></ol></li><li><ol start="4"><li>在 GOROOT 下面查找</li></ol></li></ul></li><li>第三方依赖管理工具<ul><li>godep 早期 <a href="https://github.com/tools/godep">https://github.com/tools/godep</a></li><li>glide <a href="https://github.com/Masterminds/glide">https://github.com/Masterminds/glide</a></li><li>dep 最新 <a href="https://github.com/golang/dep">https://github.com/golang/dep</a></li><li>都是充分利用了 vendor 路径</li></ul></li></ul><h2 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h2><ul><li>线程与携程 Thead vs Groutine<ul><li>JDK5 以后 java thread stack 默认为 1M</li><li>Groutine 的 Stack 初始化大小为 2K</li></ul></li><li>和 KSE（Kernel Speace Entity）的对应关系<ul><li>java thread 是 1:1</li><li>Groutine 是 M:N 多对多</li><li>系统线程切换的消耗 比较大 go与系统线程是多对多关系，无需系统的线程切换，自己去调度，尽可能的去利用系统线程的能力</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang base (two)</title>
    <link href="/posts/931b1dd1/"/>
    <url>/posts/931b1dd1/</url>
    
    <content type="html"><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li>声明</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 直接声明并赋值</span><br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;two&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;three&quot;</span>:<span class="hljs-number">3</span>&#125;<br>t.Log(m, <span class="hljs-built_in">len</span>(m))<span class="hljs-comment">//map[one:1 two:2 three:3] len 3</span><br><span class="hljs-comment">// 声明并赋予零值</span><br>m1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>m1[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span><br>t.Log(m1, <span class="hljs-built_in">len</span>(m1))<span class="hljs-comment">//map[one:1] len 1</span><br><span class="hljs-comment">// slice map</span><br>m2 :=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>,<span class="hljs-number">5</span><span class="hljs-comment">/*cap 实际上预先设定了5的容量*/</span>)<span class="hljs-comment">// map 类型 ,len</span><br>t.Log(m2,<span class="hljs-built_in">len</span>(m2))<span class="hljs-comment">//map[] len 0</span><br></code></pre></td></tr></table></figure><ul><li>访问不存在的key</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">m3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>t.Log(m3[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 0</span><br>m3[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span><br>t.Log(m3[<span class="hljs-number">2</span>]) <span class="hljs-comment">// 0</span><br>m3[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 判断存在或者为 零值</span><br><span class="hljs-keyword">if</span> v, ok := m3[<span class="hljs-number">3</span>]; ok &#123;<br>    t.Log(v, <span class="hljs-string">&quot;key 3 is exist.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    t.Log(<span class="hljs-string">&quot;KEY 3 is not existing.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 在访问 不存在的 key 的时候 会返回对应的零值 而不是异常</span><br></code></pre></td></tr></table></figure><ul><li>遍历</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    t.Log(k, <span class="hljs-string">&quot;=&gt;&quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>map 实现工厂模式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(op <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;&#125;<span class="hljs-comment">//</span><br>m[<span class="hljs-number">1</span>] = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(op <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> op<br>&#125;<br>m[<span class="hljs-number">2</span>] = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(op <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> op * op<br>&#125;<br>m[<span class="hljs-number">3</span>] = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(op <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> op *op* op<br>&#125;<br>t.Log(m[<span class="hljs-number">1</span>](<span class="hljs-number">2</span>),m[<span class="hljs-number">2</span>](<span class="hljs-number">2</span>),m[<span class="hljs-number">3</span>](<span class="hljs-number">2</span>))<span class="hljs-comment">// 2 4 8</span><br></code></pre></td></tr></table></figure><ul><li>用 <code>map</code> 实现 <code>set</code> 的功能</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 元素是唯一的</span><br><span class="hljs-comment">// 1) 添加元素</span><br><span class="hljs-comment">// 2) 判断元素是否存在</span><br><span class="hljs-comment">// 3) 删除元素</span><br><span class="hljs-comment">// 4) 元素个数</span><br>    mySet := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    mySet[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br>    mySet[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span><br>    n:= <span class="hljs-number">3</span><br>    <span class="hljs-keyword">if</span> mySet[n]&#123;<br>        t.Logf(<span class="hljs-string">&quot;%d is existing&quot;</span>,n)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        t.Logf(<span class="hljs-string">&quot;%d is not existing&quot;</span>,n)<br>        t.Log(mySet[n])<br>    &#125;<br><br>    t.Log(<span class="hljs-built_in">len</span>(mySet))<br>    <span class="hljs-built_in">delete</span>(mySet, n)<br><br>    <span class="hljs-keyword">if</span> mySet[n]&#123;<br>        t.Logf(<span class="hljs-string">&quot;%d is existing&quot;</span>,n)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        t.Logf(<span class="hljs-string">&quot;%d is not existing&quot;</span>,n)<br>        t.Log(mySet[n])<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><code>string</code> 是数据类型,不是引用或是指针类型,零值为空字符串</li><li><code>string</code> 是 只读的 <code>byte</code> <code>slice</code> , <code>len</code> 函数可以展示它所包含的 <code>byte</code></li><li><code>string</code> 的 <code>byte</code> 数组可以存放任何数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>t.Log(s)<span class="hljs-comment">// &quot;&quot;</span><br>s = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-comment">// s[1] = &#x27;2&#x27;//can&#x27;t assign s[1]</span><br>t.Log(<span class="hljs-built_in">len</span>(s))<span class="hljs-comment">// 5</span><br>s = <span class="hljs-string">&quot;\xE4\xB8\xA5&quot;</span><br>t.Log(s,<span class="hljs-built_in">len</span>(s))<span class="hljs-comment">// 严 3 len 是 byte 长度</span><br><span class="hljs-comment">// Unicode 是一种字符集（code point) 只规定了对应关系，没有规定怎么实现</span><br><span class="hljs-comment">// UTF8 是 unicode 的存储实现（转换为字节序列的规则）</span><br><br>s =<span class="hljs-string">&quot;中&quot;</span><br>t.Log(<span class="hljs-built_in">len</span>(s))<span class="hljs-comment">// byte 数 3</span><br><br>c:=[]<span class="hljs-type">rune</span>(s)<br>t.Log(<span class="hljs-built_in">len</span>(c))<span class="hljs-comment">// 1</span><br>t.Log(<span class="hljs-string">&quot;rune size :&quot;</span>, unsafe.Sizeof(c))<span class="hljs-comment">// 24 3*8 就是 3 byte 24字节</span><br><br>t.Logf(<span class="hljs-string">&quot;中 unicode %x&quot;</span>,c[<span class="hljs-number">0</span>])<br>t.Logf(<span class="hljs-string">&quot;中 UTF8 %x&quot;</span>,s)<br><br><span class="hljs-comment">// 遍历string的时候，实际自动把string转成了rune再遍历。</span><br><span class="hljs-comment">// 而不是根据 len(string)的byte数组个数</span><br>s = <span class="hljs-string">&quot;中华人民共和国&quot;</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s &#123;<br>    t.Logf(<span class="hljs-string">&quot;%[1]c %[1]x&quot;</span>,v)<br>&#125;<br><br><span class="hljs-comment">// strings strconv</span><br><span class="hljs-comment">// 字符串分割 string</span><br>s = <span class="hljs-string">&quot;A,B,C&quot;</span><br>parts := strings.Split(s,<span class="hljs-string">&quot;,&quot;</span>)<span class="hljs-comment">// []string 的切片</span><br>t.Logf(<span class="hljs-string">&quot;%T&quot;</span>, parts)<br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> parts&#123;<br>    t.Logf(<span class="hljs-string">&quot;%T&quot;</span>, v)<span class="hljs-comment">// string</span><br>&#125;<br><span class="hljs-comment">// 合并</span><br>t.Log(strings.Join(parts,<span class="hljs-string">&quot;-&quot;</span>))<br><span class="hljs-comment">// 转换</span><br>s1 := strconv.Itoa(<span class="hljs-number">10</span>)<span class="hljs-comment">// Itoa AtoI</span><br>t.Log(<span class="hljs-string">&quot;str &quot;</span>+ s1)<br><span class="hljs-keyword">if</span> s2,err := strconv.Atoi(s1);err == <span class="hljs-literal">nil</span>&#123;<br>    t.Log(<span class="hljs-number">10</span>+s2)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数是一等公民<ul><li>函数有多个返回值</li><li>所有参数都是值传递：<code>slice</code> <code>map</code> <code>channel</code> 会有传引用的错觉</li><li>函数可以作为变量的值</li><li>函数可以作为参数和返回值</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 支持多返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnMultiValues</span><span class="hljs-params">()</span></span> (a, b <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">return</span> rand.Intn(<span class="hljs-number">10</span>), rand.Intn(<span class="hljs-number">20</span>)<br>&#125;<br><span class="hljs-comment">// 可以作为参数与返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">timeSpent</span><span class="hljs-params">(inner <span class="hljs-keyword">func</span>(op <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) (<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(op <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        start := time.Now()<br>        ret := inner(n)<br>        fmt.Println(<span class="hljs-string">&quot;time Spent:&quot;</span>,time.Since(start).Seconds())<br>        <span class="hljs-keyword">return</span> ret<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slowFun</span><span class="hljs-params">(op <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    time.Sleep(time.Second*<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span>  op<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFn</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    i, l := returnMultiValues()<br>    t.Log(i, l)<br><br>    tsSF := timeSpent(slowFun)<br>    t.Log(tsSF(<span class="hljs-number">10</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变长参数与-defer"><a href="#可变长参数与-defer" class="headerlink" title="可变长参数与 defer"></a>可变长参数与 <code>defer</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 可变长参数 参数类型一致</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(ops ...<span class="hljs-type">int</span>)</span></span>(res <span class="hljs-type">int</span>)&#123;<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> ops&#123;<br>        res += v<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFn1</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>    t.Log(Sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))<br>    t.Log(Sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;errs&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;close&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;err&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clear2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;errs2&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;close2&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;err&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDefer</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>    <span class="hljs-keyword">defer</span> Clear()<br>    <span class="hljs-keyword">defer</span> Clear2()<br>    fmt.Println(<span class="hljs-string">&quot;Start&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;err&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 执行顺序为</span><br><span class="hljs-comment">// Start close2 errs2 close errs</span><br><span class="hljs-comment">// defer 类似于栈结构 先进后出</span><br><span class="hljs-comment">// 在 defer 中引发 panic 只会导致当前的 defer 体里面的程序中断</span><br></code></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="封装数据和行为（方法）"><a href="#封装数据和行为（方法）" class="headerlink" title="封装数据和行为（方法）"></a>封装数据和行为（方法）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 数据封装</span><br><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    Id   <span class="hljs-type">string</span><br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCreateEmployeeObj</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>    e:= Employee&#123;<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">23</span>&#125;<br>    e1 := Employee&#123;Id:<span class="hljs-string">&quot;张三&quot;</span>,Name:<span class="hljs-string">&quot;李四&quot;</span>,Age:<span class="hljs-number">25</span>&#125;<br>    e2 := <span class="hljs-built_in">new</span>(Employee) <span class="hljs-comment">// 返回的是一个指针</span><br>    e2.Age = <span class="hljs-number">29</span><br>    e2.Name = <span class="hljs-string">&quot;王五&quot;</span><br>    e2.Id = <span class="hljs-string">&quot;3&quot;</span><br>    t.Log(e)<br>    t.Log(e1)<br>    t.Log(e2)<br>    t.Logf(<span class="hljs-string">&quot;e is %T&quot;</span>, e)<br>    t.Logf(<span class="hljs-string">&quot;e2 is %T&quot;</span>, e2)<br>&#125;<br><br><span class="hljs-comment">//    main_test.go:437: &#123;0 张三 23&#125;</span><br><span class="hljs-comment">//    main_test.go:438: &#123;张三 李四 25&#125;</span><br><span class="hljs-comment">//    main_test.go:439: &amp;&#123;3 王五 29&#125;</span><br><span class="hljs-comment">//    main_test.go:440: e is main.Employee</span><br><span class="hljs-comment">//    main_test.go:441: e2 is *main.Employee</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 行为封装</span><br><span class="hljs-comment">// 通过引用去使用这个方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Employee)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Address is %x\n&quot;</span>, unsafe.Pointer(&amp;e.Name))<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)<br>&#125;<br><span class="hljs-comment">// 通过值拷贝去使用这个方法 这种会带来更大的内存消耗</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Address is %x\n&quot;</span>, unsafe.Pointer(&amp;e.Name))<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><ul><li>非入侵的，实现不依赖接口定义</li><li>所以接口的定义可以包含在接口使用者包内</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Programmer <span class="hljs-keyword">interface</span> &#123;<br>    WriterHelloWorld() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span>  GoProgrammer <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(to *GoProgrammer)</span></span> WriterHelloWorld() <span class="hljs-type">string</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fmt.Println(\&quot;hello world!\&quot;)&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>    <span class="hljs-keyword">var</span> p Programmer<br>    p = <span class="hljs-built_in">new</span>(GoProgrammer)<br>    t.Log(p.WriterHelloWorld())<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="接口变量"><a href="#接口变量" class="headerlink" title="接口变量"></a>接口变量</h3><ul><li>声明 <code>var prog Coder = &amp;GoPaogrammer&#123;&#125;</code></li><li>prog 由两部分组成<ul><li><code>type GoPaogrammer struct&#123;&#125;</code> 数据类型</li><li><code>&amp;GoPaogrammer&#123;&#125;</code> 数据实例</li></ul></li></ul><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><ul><li>golang 中组合的成分高于继承,甚至可以说没有一般语言的继承概念</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pet <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pet)</span></span> Speck()  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pet)</span></span> SpeckTo(host <span class="hljs-type">string</span>) &#123;<br>    p.Speck()<br>    fmt.Println(<span class="hljs-string">&quot; &quot;</span>, host)<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">//p *Pet // 复合</span><br>    Pet<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span></span> Speck()  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;www&quot;</span>)<br>    d.SpeckTo(<span class="hljs-string">&quot;laowan&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//func (d *Dog) SpeckTo(host string) &#123;</span><br><span class="hljs-comment">//  //d.SpeckTo(host)</span><br><span class="hljs-comment">//  d.Speck()</span><br><span class="hljs-comment">//  fmt.Println(host)</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInherit</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>    <span class="hljs-comment">// var dog Pet = new(Dog) 不能使用 Dog 去作为 Pat 类型</span><br>    <span class="hljs-keyword">var</span> dog = <span class="hljs-built_in">new</span>(Dog)<br>    <span class="hljs-comment">//dog.SpeckTo(&quot;张三&quot;) // ... 张三 匿名变量 只能调用 变量自己的方法</span><br>    dog.Speck() <span class="hljs-comment">//www ... lanwan</span><br>    <span class="hljs-comment">// 子类可以调用 匿名变量的方法但是这不算是完整意义上的继承</span><br><br>    <span class="hljs-comment">// 关于继承这部分 跟 php 差距很大，与其说是继承，我更加倾向于说这是 组合</span><br>    <span class="hljs-comment">// 类似于 php 中的 traits 但又不像，因为匿名变量分界线很清楚，</span><br>    <span class="hljs-comment">// traits 是可以在被使用后 根据使用者的情况展示不同的特性</span><br>    <span class="hljs-comment">// 是你的就是你的，是我的就是我的，你用我的，那就是我的，上层不能使用下层的方法</span><br>    <span class="hljs-comment">// 下层在使用上层的方法时候，可以理解为全在上层使用</span><br></code></pre></td></tr></table></figure><h3 id="接口与多态"><a href="#接口与多态" class="headerlink" title="接口与多态"></a>接口与多态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Code <span class="hljs-type">string</span><br><span class="hljs-keyword">type</span> Programmer <span class="hljs-keyword">interface</span> &#123;<br>    WriterHelloWorld() Code<br>&#125;<br><br><span class="hljs-keyword">type</span> GoProgrammer <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(to *GoProgrammer)</span></span> WriterHelloWorld() Code &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fmt.Println(\&quot;hello world!\&quot;)&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> JavaProgrammer <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(to *JavaProgrammer)</span></span> WriterHelloWorld() Code &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fmt.Println(\&quot;hello world!\&quot;)&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriterFirstProgrammer</span><span class="hljs-params">(programmer Programmer)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T %v\n&quot;</span>, programmer, programmer.WriterHelloWorld())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPolymorphism</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    goProg := <span class="hljs-built_in">new</span>(GoProgrammer)<span class="hljs-comment">// 指针</span><br>    javaProg := <span class="hljs-built_in">new</span>(JavaProgrammer)<span class="hljs-comment">// 指针</span><br>    WriterFirstProgrammer(goProg)<br>    WriterFirstProgrammer(javaProg)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空接口与断言"><a href="#空接口与断言" class="headerlink" title="空接口与断言"></a>空接口与断言</h3><ul><li><p>空接口可以表示任何类型</p></li><li><p>通过断言来将空接口转换为指定类型</p><ul><li>v,ok :&#x3D; p.(int) &#x2F;&#x2F; ok&#x3D;true 时为转换成功</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(p <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>  <span class="hljs-comment">//if i,ok := p.(int);ok&#123;</span><br>  <span class="hljs-comment">// fmt.Println(&quot;Integer&quot;, i)</span><br>  <span class="hljs-comment">// return</span><br>  <span class="hljs-comment">//&#125;</span><br>  <span class="hljs-comment">//if i,ok := p.(string);ok&#123;</span><br>  <span class="hljs-comment">// fmt.Println(&quot;String&quot;, i)</span><br>  <span class="hljs-comment">// return</span><br>  <span class="hljs-comment">//&#125;</span><br>  <span class="hljs-keyword">switch</span> i := p.(<span class="hljs-keyword">type</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>      fmt.Println(<span class="hljs-string">&quot;Integer&quot;</span>, i)<br>      <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>      fmt.Println(<span class="hljs-string">&quot;String&quot;</span>, i)<br>      <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">default</span>:<br>      fmt.Println(<span class="hljs-string">&quot;unKnow Type&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDoSomething</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>  DoSomething(<span class="hljs-number">10</span>)<br>  DoSomething(<span class="hljs-string">&quot;10&quot;</span>)<br>  DoSomething(<span class="hljs-string">&#x27;1&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Go接口最佳实践"><a href="#Go接口最佳实践" class="headerlink" title="Go接口最佳实践"></a>Go接口最佳实践</h3><ul><li><p>倾向于使用小的接口定义，很多接口只包含一个方法（对于实现者负担更新 single Interface）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span>&#123;<br>    Read(p []<span class="hljs-type">byte</span>)(n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;  <br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span>&#123;<br>    Write(p []<span class="hljs-type">byte</span>)(n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;  <br></code></pre></td></tr></table></figure></li><li><p>较大的接口定义，可以由多个小接口定义组合而成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span>&#123;<br>    Reader<br>    Writer<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>只依赖必要功能的最小接口(会使方法的复用性更强)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreData</span><span class="hljs-params">(reader Reader)</span></span> <span class="hljs-type">error</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于composer的一些记录</title>
    <link href="/posts/a9fab0f7/"/>
    <url>/posts/a9fab0f7/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么-上线要使用-composer-dump-autoload-o"><a href="#为什么-上线要使用-composer-dump-autoload-o" class="headerlink" title="为什么 上线要使用 composer dump-autoload -o"></a>为什么 上线要使用 <code>composer dump-autoload -o</code></h3><ul><li><p><code>composer dump-autoload -o</code> 做了什么？</p><ul><li>自动生成了 注册类的 <code>key=&gt;value</code> 数组 按A-Z进行排序并生成了对应的索引</li></ul></li><li><p><code>Compsoer\ClassLoader</code> 会优先查看 <code>autoload_classmap</code> 中所有生成的注册类。</p></li><li><p>如果在<code>classmap</code> 中没有发现再 <code>fallback</code> 到 <code>psr-4</code>规则去找 然后 <code>psr-0</code>规则去找</p></li><li><p>所以当执行 <code>composer dump-autoload -o</code> 之后，<code>composer</code> 就会提前加载需要的类并提前返回。这样大大减少了 <code>IO</code> 和深层次的 <code>loop</code></p></li></ul><h3 id="问题点-You-made-a-reference-to-a-non-existent-script-php-artisan-package-discover"><a href="#问题点-You-made-a-reference-to-a-non-existent-script-php-artisan-package-discover" class="headerlink" title="问题点 You made a reference to a non-existent script @php artisan package:discover"></a>问题点 <code>You made a reference to a non-existent script @php artisan package:discover</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">composer -V<br>Composer version 1.2.1 2016-09-12 11:27:19<br></code></pre></td></tr></table></figure><ul><li>解决方法，升级 composer 版本</li><li><code>composer self-update</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>Updating to version 1.6.3 (stable channel).<br>    Downloading: 100%<br>Use composer self-update --rollback to return to version 1.2.1<br></code></pre></td></tr></table></figure><h3 id="composer-使用镜像后-却依然会去-github-原始地址拉取代码？"><a href="#composer-使用镜像后-却依然会去-github-原始地址拉取代码？" class="headerlink" title="composer 使用镜像后 却依然会去 github 原始地址拉取代码？"></a>composer 使用镜像后 却依然会去 github 原始地址拉取代码？</h3><ul><li>在 <code>docker</code> 里使用 <code>php-fpm:8.1</code> 这个镜像的时候，默认是没有 <code>zip</code> 扩展的</li><li>因为 <code>zip</code> 的依赖版本对不上也没法使用 <code>docker-php-ext-install  zip</code> 进行安装</li><li>这个时候使用 <code>composer install</code> 的时候 因为没法去解压 从镜像中拉取的 <code>zip</code> 文件</li><li>所以退化为从 <code>GitHub</code> 上 进行仓库的拉取</li></ul><h3 id="composer-常用命令"><a href="#composer-常用命令" class="headerlink" title="composer 常用命令"></a>composer 常用命令</h3><ul><li><code>composer config -gl</code> 配置查看</li><li><code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer</code> 改为阿里云的源</li></ul><h3 id="composer-安装"><a href="#composer-安装" class="headerlink" title="composer 安装"></a>composer 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sS https://getcomposer.org/installer | php \<br>    &amp;&amp; mv composer.phar /usr/local/bin/composer \<br>    &amp;&amp; composer self-update --clean-backups<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>composer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php之道</title>
    <link href="/posts/be3b3e4e/"/>
    <url>/posts/be3b3e4e/</url>
    
    <content type="html"><![CDATA[<h2 id="PHPer-web-技能点"><a href="#PHPer-web-技能点" class="headerlink" title="PHPer web 技能点"></a>PHPer web 技能点</h2><ul><li><a href="https://github.com/z-jingjie/developer-roadmap-zh-CN">后端技能点</a></li></ul><h3 id="必需技能"><a href="#必需技能" class="headerlink" title="必需技能"></a>必需技能</h3><ul><li><p>git-版本控制</p></li><li><p>ssh-安全外壳协议</p></li><li><p>http&#x2F;https 协议和 API</p></li><li><p>命令行基础指令</p></li><li><p>学习理解</p></li><li><p>数据结构与算法</p></li><li><p>字符编码</p></li><li><p>设计模式</p></li><li><p><code>github/gitlab</code> 平台与工作流</p></li><li><p><code>php7</code></p><ul><li>包管理工具 <code>composer</code></li><li>调试&#x2F;分析工具<ul><li><code>xDebug</code></li><li><code>XHProf</code></li><li><code>New Relic</code></li><li><code>Blackfire</code></li></ul></li><li>开发框架<ul><li><code>Laravel -&gt; symfony</code></li><li><code>Slim-&gt;lumen</code></li></ul></li><li>测试工具<ul><li><code>PHPUnit</code></li><li><code>phpspec</code></li><li><code>Codeception</code></li><li><code>Mockery</code></li></ul></li><li>消息代理<ul><li><code>RabbitMQ</code></li><li><code>Apache Kafak</code></li></ul></li><li>存储<ul><li>缓存<ul><li><code>Memcached</code></li><li><code>Redis</code></li></ul></li><li>关系数据库<ul><li><code>PostgreSQL</code></li><li><code>MariaDB</code></li><li><code>MySQL</code></li></ul></li><li>非关系数据库<ul><li><code>Redis</code></li><li><code>MongoDB</code></li></ul></li></ul></li><li>Web 服务器<ul><li>Apache</li><li>Nginx</li></ul></li><li>RESTful API 架构</li><li>身份认证机制<ul><li><code>JWT</code></li><li><code>OAuth2.0</code></li></ul></li><li><code>SOLID,YAGNI,KISS</code></li><li>正则</li><li><code>Docker</code></li><li>搜索引擎<ul><li><code>ElasticSearch</code></li><li><code>Sphinx</code></li><li><code>Solr</code></li></ul></li><li><code>GOF</code> 设计模式</li><li>体系结构模式</li><li>了解 <code>DDD</code></li><li>学习各类测试技术</li></ul></li></ul><p><a href="https://laravel-china.github.io/php-the-right-way/">php之道中文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>php后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>build yourself Linux dev env</title>
    <link href="/posts/db0de75c/"/>
    <url>/posts/db0de75c/</url>
    
    <content type="html"><![CDATA[<h2 id="ContOS7-php多版本环境的配置"><a href="#ContOS7-php多版本环境的配置" class="headerlink" title="ContOS7  php多版本环境的配置"></a><code>ContOS7</code>  php多版本环境的配置</h2><h3 id="使用最小化安装之后的第一个问题，内外网不通"><a href="#使用最小化安装之后的第一个问题，内外网不通" class="headerlink" title="使用最小化安装之后的第一个问题，内外网不通"></a>使用最小化安装之后的第一个问题，内外网不通</h3><ul><li><p><code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p></li><li><p>修改 <code>ONBOOT=yes</code> 后 <code>systemctl restart network.service</code></p></li><li><p>重启主机，如果此时内外网通了但是 <code>yum list</code> 失败，主要是服务不可达，考虑为 <code>DNS</code> 的原因</p></li><li><p>修改 <code>vi /etc/resolv.conf</code> 修改 <code>dns</code> 为 <code>nameserver 8.8.8.8</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update # 成功<br>yum install wget -y # 装一个下载工具<br>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup # 备份<br>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # 添加阿里源<br>yum clean all # 清除缓存<br>yum makecache # 生成缓存<br>yum update -y # 更新<br>  <br></code></pre></td></tr></table></figure></li></ul><h3 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h3><ul><li><code>yum install vim -y &amp;&amp; yum install net-tools -y</code>   习惯了 <code>vim</code> 加上一个网络分析小工具</li><li><code>yum install gcc gcc-c++ httpd-tools autoconf pcre pcre-devel make automake -y</code> 安装一些编译测试工具</li><li><code>systemctl stop firewalld.service &amp;&amp; systemctl disable firewalld.service</code> 关闭并禁用 防火墙</li><li><code>vim /etc/selinux/config</code></li><li>修改 <code>SELINUX=disabled</code> 千万不要改错位置  </li><li>下面的 <code>selinuxtype</code> 要是改成 <code>disable</code> 建议删了重装会快一些</li><li>不然 <code>selinux</code> 可能会导致你的网络端口不可访问</li></ul><h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 <code>nginx</code></h3><ul><li><p><a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS">参考</a></p></li><li><p><code>vim /etc/yum.repos.d/nginx.repo</code> 创建 <code>yum</code> 源文件</p></li><li><p>根据官方提示修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs conf">[nginx]<br>name=nginx repo<br>baseurl=http://nginx.org/packages/centos/7/$basearch/<br>gpgcheck=0<br>enabled=1<br></code></pre></td></tr></table></figure></li><li><p><code>yum list|grep nginx</code> 能够看到 <code>nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum list|grep nginx<br>nginx.x86_64                                1:1.16.0-1.el7.ngx         nginx<br>nginx-debug.x86_64                          1:1.8.0-1.el7.ngx          nginx<br>nginx-debuginfo.x86_64                      1:1.16.0-1.el7.ngx         nginx<br>nginx-module-geoip.x86_64                   1:1.16.0-1.el7.ngx         nginx<br>nginx-module-geoip-debuginfo.x86_64         1:1.16.0-1.el7.ngx         nginx<br>nginx-module-image-filter.x86_64            1:1.16.0-1.el7.ngx         nginx<br>nginx-module-image-filter-debuginfo.x86_64  1:1.16.0-1.el7.ngx         nginx<br>nginx-module-njs.x86_64                     1:1.16.0.0.3.1-1.el7.ngx   nginx<br>nginx-module-njs-debuginfo.x86_64           1:1.16.0.0.3.1-1.el7.ngx   nginx<br>nginx-module-perl.x86_64                    1:1.16.0-1.el7.ngx         nginx<br>nginx-module-perl-debuginfo.x86_64          1:1.16.0-1.el7.ngx         nginx<br>nginx-module-xslt.x86_64                    1:1.16.0-1.el7.ngx         nginx<br>nginx-module-xslt-debuginfo.x86_64          1:1.16.0-1.el7.ngx         nginx<br>nginx-nr-agent.noarch                       2.0.0-12.el7.ngx           nginx<br>pcp-pmda-nginx.x86_64                       4.1.0-5.el7_6              updates  <br></code></pre></td></tr></table></figure></li><li><p><code>yum install nginx -y</code> 安装 <code>nginx</code></p></li><li><p><code>systemctl enable nginx</code> 开机自启 <code>nginx</code></p></li><li><p><code>systemctl start nginx</code> 启动 <code>nginx</code></p></li><li><p>然后输入 <code>IP</code> 到浏览器访问成功</p></li><li><p>默认配置位置 <code>/etc/nginx/nginx.conf</code> <code>/etc/nginx/conf.d/default.conf</code></p></li></ul><h3 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a>安装 <code>PHP</code></h3><ul><li><p><a href="https://webtatic.com/packages/php72/">参考</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install epel-release<br>rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm<br></code></pre></td></tr></table></figure></li><li><p>安装 <code>php</code> 全扩展 <code>yum install mod_php72w php72w-bcmath php72w-cli php72w-common php72w-dba php72w-devel php72w-embedded php72w-enchant php72w-fpm php72w-gd  php72w-imap php72w-interbase php72w-imap php72w-intl php72w-ldap php72w-mbstring php72w-mysqlnd php72w-odbc php72w-opcache php72w-pdo php72w-pdo_dblib php72w-pear php72w-pecl-apcu php72w-pecl-imagick php72w-pecl-mongodb php72w-pgsql php72w-phpdbg php72w-process php72w-pspell php72w-recode php72w-snmp php72w-soap php72w-sodium php72w-tidy php72w-xml php72w-xmlrpc -y</code></p></li><li><p>配置文件位置 <code>/etc/php.ini</code></p></li><li><p><code>php -m</code> 就可以查看装了哪些扩展 嗯 基本都开了</p></li><li><p><code>systemctl start php-fpm</code> 虽然是一台机器但我们还是用 <code>php-fpm</code> 模式,便于后期加入 <code>docker</code> 的扩展 也可以使用 <code>.sock</code> 的模块加载模式 理论上会快一些</p></li><li><p><code>systemctl enable php-fpm</code> 开机自启</p></li><li><p>发现一个坑，并没有 <code>redis</code> 扩展 原生进行编译扩展</p><ul><li><code>wget http://pecl.php.net/get/redis-4.2.0.tgz</code></li><li><code>tar zxvf redis-4.2.0.tgz</code></li><li><code>cd redis-4.2.0</code></li><li><code>/usr/bin/phpize</code>(这个根据 <code>phpize</code> 实际情况来)</li><li><code>./configure --with-php-config=/usr/bin/php-config</code>(这个根据 <code>php-config</code> 实际情况来)</li><li><code>make &amp;&amp; make install</code></li><li><code>vim /etc/php.d/redis.ini</code> 这个根据实际情况去决定 是改 <code>php.ini</code> 还是别的什么</li><li>写入 <code>extension=redis.so</code></li><li><code>systemctl restart php-fpm</code> 就 <code>ok</code> 了</li></ul></li></ul><h3 id="php与nginx-链接起来"><a href="#php与nginx-链接起来" class="headerlink" title="php与nginx 链接起来"></a><code>php</code>与<code>nginx</code> 链接起来</h3>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cd dev<br>[root@localhost dev]# mkdir -p www/php/test/<br>[root@localhost dev]# cd www/php/test/<br>[root@localhost test]# echo &quot;&lt;?php phpinfo();&quot; &gt;&gt; ./index.php<br></code></pre></td></tr></table></figure><ul><li><p><code>vim /etc/nginx/conf.d/default.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">location / &#123;<br>      root   /dev/www/php/test;<br>      index index.php  index.html index.htm;<br>  &#125;<br><br>  location ~* \.php$ &#123;<br>      fastcgi_index   index.php;<br>      fastcgi_pass    127.0.0.1:9000;<br>      include         fastcgi_params;<br>      fastcgi_param SCRIPT_FILENAME /dev/www/php/test$fastcgi_script_name;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>nginx -t &amp;&amp; nginx -s reload</code></p></li></ul><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove docker  docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine<br><br>yum install -y yum-utils<br><br>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br><br>yum install docker-ce docker-ce-cli containerd.io -y<br><br>systemctl start docker<br><br>systemctl enable docker<br></code></pre></td></tr></table></figure><h3 id="使用docker构建-php5-4-环境"><a href="#使用docker构建-php5-4-环境" class="headerlink" title="使用docker构建 php5.4 环境"></a>使用<code>docker</code>构建 <code>php5.4</code> 环境</h3><ul><li><p>更换镜像，使用阿里云的镜像加速</p></li><li><p><code>https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</code></p></li><li><p><code>vim /etc/docker/daemon.json</code></p></li><li><p>修改成自己的镜像加速</p></li><li><p><code>&quot;registry-mirrors&quot;: [&quot;https://xxxxx.mirror.aliyuncs.com&quot;]</code></p></li><li><p><code>systemctl daemon-reload</code></p></li><li><p><code>systemctl restart docker</code></p></li><li><p>运行生成一个<code>php5.4</code> 的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>-v /dev/www/php/:/var/www/html \<br>-p 9001:9000 \<br>--name phpfpm54 --privileged=true php:5.4-fpm<br></code></pre></td></tr></table></figure></li></ul><h4 id="docker-中-扩展安装"><a href="#docker-中-扩展安装" class="headerlink" title="docker 中 扩展安装"></a>docker 中 扩展安装</h4><ul><li><code>docker exec -ti phpfpm54 /bin/bash</code></li><li><code>-ti</code> 打开图形界面</li><li><code>/bin/bash</code> 执行 这个命令</li><li><code>exec</code> 可以在 不 <code>exit</code> 的情况下进行附加操作</li><li>进去后需要 <code>apt-get update</code> 里面是 <code>debian9</code> 系统</li><li><code>docker-php-ext-install pdo_mysql</code> 来装 <code>pdo_mysql</code> 扩展</li><li>以下这些扩展都可以安装 不过好多有坑0.0</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bcmath bz2 calendar ctype curl dba dom enchant exif fileinfo filter ftp gd gettext gmp hash iconv imap interbase intl json ldap mbstring mysqli oci8 odbc opcache pcntl pdo pdo_dblib pdo_firebird pdo_mysql pdo_oci pdo_odbc pdo_pgsql pdo_sqlite pgsql phar posix pspell readline recode reflection session shmop simplexml snmp soap sockets sodium spl standard sysvmsg sysvsem sysvshm tidy tokenizer wddx xml xmlreader xmlrpc xmlwriter xsl zend_test zip<br></code></pre></td></tr></table></figure><h4 id="docker-Debian-换源安装gd-库"><a href="#docker-Debian-换源安装gd-库" class="headerlink" title="docker Debian 换源安装gd 库"></a>docker <code>Debian</code> 换源安装<code>gd</code> 库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/apt &amp;&amp; cp sources.list ./sources.list.bak<br>apt-get install vim<br><br>vim sources.list<br>deb http://mirrors.163.com/debian/ stretch main non-free contrib<br>deb http://mirrors.163.com/debian/ stretch-updates main non-free contrib<br>deb http://mirrors.163.com/debian/ stretch-backports main non-free contrib<br>deb-src http://mirrors.163.com/debian/ stretch main non-free contrib<br>deb-src http://mirrors.163.com/debian/ stretch-updates main non-free contrib<br>deb-src http://mirrors.163.com/debian/ stretch-backports main non-free contrib<br><br>//如果连apt-get update都做不到   可以先 rm sources.list 再创一个新的<br>echo &quot;deb http://mirrors.163.com/debian/ stretch main non-free contrib<br>deb http://mirrors.163.com/debian/ stretch-updates main non-free contrib<br>deb http://mirrors.163.com/debian/ stretch-backports main non-free contrib<br>deb-src http://mirrors.163.com/debian/ stretch main non-free contrib<br>deb-src http://mirrors.163.com/debian/ stretch-updates main non-free contrib<br>deb-src http://mirrors.163.com/debian/ stretch-backports main non-free contrib&quot; &gt;&gt; sources.list<br>//将源更换为上述  新的源<br><br>apt-get update<br>apt-get install libfreetype6-dev -y<br>apt-get install libpng-dev -y<br>apt-get install libjpeg62-turbo-dev -y<br>//如果源没出问题 上述应该都能安装<br>docker-php-ext-configure gd --with-freetype-dir=/usr/include --with-jpeg-dir=/usr/include<br>//先编译gd库的扩展<br>docker-php-ext-install gd<br>// 这样就在docker容器内完美安装了gd库<br></code></pre></td></tr></table></figure><ul><li>装 <code>redis</code> 扩展</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -L -o /tmp/redis.tar.gz https://github.com/phpredis/phpredis/archive/3.1.3.tar.gz<br><br>tar xfz /tmp/redis.tar.gz<br><br>rm -r /tmp/redis.tar.gz<br><br>mkdir -p /usr/src/php/ext<br><br>mv phpredis-3.1.3 /usr/src/php/ext/redis<br><br>docker-php-ext-install redis<br></code></pre></td></tr></table></figure><ul><li><p>退出测试</p></li><li><p><code>vim /etc/nginx/conf.d/default.conf</code></p></li><li><p>修改 <code>fastcgi_param SCRIPT_FILENAME /var/www/html/test$fastcgi_script_name;</code></p></li><li><p>这里由于是在容器内执行所以修改路径为这个</p></li><li><p>设置 <code>phpstrom</code> 的 <code>sftp</code> 自动上传到 本地虚拟机</p></li><li><p><code>ps aux|grep php</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 root 0:00 php-fpm: master process (/usr/local/etc/php-fpm.conf)<br>7 www-data 0:00 php-fpm: pool www<br>8 www-data 0:00 php-fpm: pool www<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现<span class="hljs-built_in">id</span> 1就是php了，给它个信号让它重启即可，执行命令如下：</span><br>kill -USR2 1<br></code></pre></td></tr></table></figure><ul><li>如果是在外面也可以：docker exec -it 容器id或名称 kill -USR2 1</li><li>或者重启容器  docker restart 容器id或名称</li></ul><h4 id="安装-swoole"><a href="#安装-swoole" class="headerlink" title="安装  swoole"></a>安装  <code>swoole</code></h4><ul><li><code>yum install git openssl-devel -y</code></li><li><code>git clone https://gitee.com/swoole/swoole.git</code></li><li>高版本<ul><li><code>cd swoole</code></li><li><code>git checkout v4.4.6</code></li><li><code>./configure --enable-openssl --enable-mysqlnd --enable-sockets</code></li><li><code>make clean &amp;&amp; make &amp;&amp; sudo make install</code></li><li><code>cd /etc/php.d/</code></li><li><code>cp sockets.ini ./swoole.ini</code></li><li><code>vim swoole.ini 修改为 swoole</code></li><li><code>systemctl restart php-fpm</code></li></ul></li><li>低版本<ul><li><p><code>wget https://github.com/redis/hiredis/archive/v0.14.0.zip</code></p></li><li><p><code>yun install -y unzip</code></p></li><li><p><code>unzip v0.14.0.zip</code></p></li><li><p><code>cd hiredis-0.14.0</code></p></li><li><p><code>make -j</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure \<br>--with-php-config=/usr/bin/php-config \<br>--enable-openssl  \<br>--enable-http2  \<br>--enable-async-redis \<br>--enable-sockets \<br>--enable-mysqlnd &amp;&amp; make clean &amp;&amp; make &amp;&amp; sudo make install<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/php.d/<br>cp sockets.ini ./swoole.ini<br>ls<br>vim swoole.ini 修改为 swoole<br>systemctl restart php-fpm<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>[root@localhost swoole]# php --ri swoole<br><br>swoole<br><br>Swoole =&gt; enabled<br>Author =&gt; Swoole Team &lt;team@swoole.com&gt;<br>Version =&gt; 4.4.0-alpha<br>Built =&gt; May 10 2019 20:30:06<br>coroutine =&gt; enabled<br>epoll =&gt; enabled<br>eventfd =&gt; enabled<br>signalfd =&gt; enabled<br>cpu_affinity =&gt; enabled<br>spinlock =&gt; enabled<br>rwlock =&gt; enabled<br>sockets =&gt; enabled<br>openssl =&gt; OpenSSL 1.0.2k-fips  26 Jan 2017<br>http2 =&gt; enabled<br>pcre =&gt; enabled<br>zlib =&gt; enabled<br>mutex_timedlock =&gt; enabled<br>pthread_barrier =&gt; enabled<br>futex =&gt; enabled<br>mysqlnd =&gt; enabled<br>async_redis =&gt; enabled<br><br>Directive =&gt; Local Value =&gt; Master Value<br>swoole.enable_coroutine =&gt; On =&gt; On<br>swoole.display_errors =&gt; On =&gt; On<br>swoole.use_shortname =&gt; On =&gt; On<br>swoole.unixsock_buffer_size =&gt; 8388608 =&gt; 8388608<br><br></code></pre></td></tr></table></figure><h3 id="docker-构建生产可用-php8-1"><a href="#docker-构建生产可用-php8-1" class="headerlink" title="docker 构建生产可用 php8.1"></a>docker 构建生产可用 php8.1</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> php:<span class="hljs-number">8.1</span>-fpm<br><br><span class="hljs-keyword">ENV</span> REDIS_VERSION=<span class="hljs-number">5.3</span>.<span class="hljs-number">5</span>  SWOOLE_VERSION=<span class="hljs-number">4.8</span>.<span class="hljs-number">6</span><br><br><span class="hljs-comment"># 设置时间</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span> &gt; /etc/timezone</span><br><br><span class="hljs-comment">#更换源</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&quot;s/deb.debian.org/mirrors.aliyun.com/g&quot;</span> /etc/apt/sources.list</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&quot;s/http/https/g&quot;</span> /etc/apt/sources.list</span><br><br><span class="hljs-comment">#编译安装扩展 gd 与其他依赖配置</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp;\</span><br><span class="language-bash">    apt-get install --allow-downgrades -y  libz-dev unzip <span class="hljs-built_in">sudo</span>  \</span><br><span class="language-bash">       libzip-dev libfreetype6-dev libjpeg62-turbo-dev libpng-dev libssl-dev libcurl4-openssl-dev &amp;&amp;\</span><br><span class="language-bash">    apt-get clean &amp;&amp;\</span><br><span class="language-bash">    apt-get autoremove &amp;&amp;\</span><br><span class="language-bash">    docker-php-ext-configure gd &amp;&amp;\</span><br><span class="language-bash">    docker-php-ext-install -j$(<span class="hljs-built_in">nproc</span>) gd</span><br><br><span class="hljs-comment"># top 与 ps 这类的监控软件 ，需要时添加</span><br><span class="hljs-comment">#RUN apt install procps --allow-downgrades -y</span><br><br><span class="hljs-comment">#pecl 安装扩展 redis</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pecl install redis-<span class="hljs-variable">$REDIS_VERSION</span> &amp;&amp; docker-php-ext-enable redis</span><br><br><span class="hljs-comment">#安装其他必需扩展</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> docker-php-ext-install bcmath pdo_mysql zip sockets pcntl</span><br><br><span class="hljs-comment">#安装swoole</span><br><span class="hljs-comment">#RUN pecl install swoole-$SWOOLE_VERSION &amp;&amp; docker-php-ext-enable swoole</span><br><br><span class="hljs-comment"># Composer安装 与设置镜像地址</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -sS https://getcomposer.org/installer | php \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">mv</span> composer.phar /usr/local/bin/composer \</span><br><span class="language-bash">    &amp;&amp; composer self-update --clean-backups \</span><br><span class="language-bash">    &amp;&amp; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br><br><span class="hljs-comment"># php-OPcache 配置</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">touch</span> /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp;  \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[opcache]&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;zend_extension=opcache.so&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.enable=1&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.enable_cli=1&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.memory_consumption=256&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.interned_strings_buffer=8&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.max_accelerated_files=100000&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.max_wasted_percentage=5&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.use_cwd=1&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.validate_timestamps=1&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.revalidate_freq=2&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.save_comments=0&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.jit_debug=0&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.jit=1255&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;opcache.jit_buffer_size=256M&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# 其他php配置&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;memory_limit=256M&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;upload_max_filesize=50M&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;post_max_size=50M&quot;</span> &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-OPcache.ini</span><br><br><span class="hljs-comment"># 更改 fpm 的分组 因为我 宿主机有 www:x:1001:1001 分组跟用户 所以才做这样的处理 其他机器按照自己想要的分组去处理就好</span><br><span class="hljs-comment"># groupadd -g 1001 www</span><br><span class="hljs-keyword">RUN</span><span class="language-bash">  useradd -u 1001 www &amp;&amp; RUN sed -i <span class="hljs-string">&quot;s/www-data/www/g&quot;</span> /usr/local/etc/php-fpm.d/www.conf</span><br><br></code></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p><code>docker build -t php81-laravel:v1 .</code></p><h3 id="构建运行时"><a href="#构建运行时" class="headerlink" title="构建运行时"></a>构建运行时</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -i -t -d \<br> --restart=always \<br> -p 8100:9000 \<br> -v /pathto/code:/var/www/html  --name=laravel8  php81-laravel:v1<br></code></pre></td></tr></table></figure><h3 id="执行者权限问题"><a href="#执行者权限问题" class="headerlink" title="执行者权限问题"></a>执行者权限问题</h3><ul><li>在容器内 <code>php-fpm</code> 的运行时分组 为 <code>www-data</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">容器内</span><br>id  www-data <br>uid=33(www-data) gid=33(www-data) groups=33(www-data)<br></code></pre></td></tr></table></figure><ul><li>所以其生成的 log 文件也是 属于这个分组下</li><li>在宿主机上 如果没有 33 的分组与用户， 展示的则为 <code>tape tape</code></li><li>如若在宿主机上使用 crontab 势必会导致 log 权限的问题，</li><li>解决方式 就是保证内外用户uid 的一致 如:</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash">  useradd -u 1001 www &amp;&amp; RUN sed -i <span class="hljs-string">&quot;s/www-data/www/g&quot;</span> /usr/local/etc/php-fpm.d/www.conf</span><br></code></pre></td></tr></table></figure><h3 id="laravel-相关任务"><a href="#laravel-相关任务" class="headerlink" title="laravel 相关任务"></a>laravel 相关任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以直接在宿主机上 执行 容器内的命令 如</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将容器内的 composer 进行更新</span><br>docker exec composer update -vvv <br><span class="hljs-meta prompt_">#</span><span class="language-bash">（此时以容器内的 root 用户去执行的命令）</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以在容器内不安装 crontab 的情况下，可以在宿主机进行配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 用户去启动 crontab  在容器内转换成 www 用户去执行 php 完美</span><br>crontab -e<br><br>* * * * *  docker exec laravel8 sudo -u www php artisan schedule:run<br></code></pre></td></tr></table></figure><h2 id="lnmp-一键安装-脚本"><a href="#lnmp-一键安装-脚本" class="headerlink" title="lnmp 一键安装 脚本"></a>lnmp 一键安装 脚本</h2><ul><li>支持到 php8.1 , 测试服用这个省心</li><li><code>https://lnmp.org/</code></li></ul><h2 id="Debian-环境配置"><a href="#Debian-环境配置" class="headerlink" title="Debian 环境配置"></a><code>Debian</code> 环境配置</h2><p>因为 <code>contOS8</code> 以后的版本会面临的风险，所以打算更换Linux的构建版本，在对比了一系列版本后，最终选择了 <code>Debian11</code> 希望这个系统能陪我10-20年。</p><h3 id="ISO-文件获取"><a href="#ISO-文件获取" class="headerlink" title="ISO 文件获取"></a>ISO 文件获取</h3><ul><li>11版本的的debian.iso 文件获取 发行版本也才300M<br><a href="https://developer.aliyun.com/mirror/debian-cd">https://developer.aliyun.com/mirror/debian-cd</a></li></ul><h3 id="VirtualBox-相关配置"><a href="#VirtualBox-相关配置" class="headerlink" title="VirtualBox 相关配置"></a>VirtualBox 相关配置</h3><ul><li><p>内存调整 4G</p></li><li><p>核心 两核</p></li><li><p>网卡开 nat 跟 host only 两个</p></li><li><p>安装过程中拒绝 <code>ghome</code> 等桌面软件, 开启 <code>ssh serve</code></p></li></ul><h3 id="初始化后调整本地的host网络"><a href="#初始化后调整本地的host网络" class="headerlink" title="初始化后调整本地的host网络"></a>初始化后调整本地的host网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看相关网卡</span><br>ip addr <br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现 enp0s8 host only 网卡没配置</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对其进行配置</span><br>vim /etc/network/interfaces<br><br>allow-hotplug enp0s8<br>iface enp0s8 inet dhcp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 ifup 来启动网卡</span><br>ifup enp0s8<br></code></pre></td></tr></table></figure><h3 id="ssh-开启允许-root-登录"><a href="#ssh-开启允许-root-登录" class="headerlink" title="ssh 开启允许 root 登录"></a>ssh 开启允许 root 登录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/ssh/sshd_config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改</span><br>PermitRootLogin yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启</span> <br>systemctl restart sshd<br><br></code></pre></td></tr></table></figure><ul><li><a href="https://developer.aliyun.com/mirror/debian">更改apt源</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更改源</span><br>vim /etc/apt/sources.list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入数据</span><br>deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib<br>deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib<br>deb http://mirrors.aliyun.com/debian-security/ bullseye-security main<br>deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main<br>deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib<br>deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib<br>deb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib<br>deb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新源与 相关软件</span><br>apt update &amp;&amp; apt upgrade -y<br><br></code></pre></td></tr></table></figure><h3 id="docker-与相关应用安装"><a href="#docker-与相关应用安装" class="headerlink" title="docker 与相关应用安装"></a>docker 与相关应用安装</h3><ul><li>docker <a href="https://docs.docker.com/engine/install/debian/">安装</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>apt install ca-certificates curl gnupg lsb-release -y<br><br>curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><br>echo \<br>&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">(lsb_release -cs) stable<span class="hljs-string">&quot; |  tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">更新源</span></span><br>apt update<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">直接安装</span></span><br>apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">查看版本 &amp; 进行安装</span></span><br>apt-cache madison docker-ce<br><br>apt-get install docker-ce=5:20.10.16~3-0~debian-bullseye docker-ce-cli=5:20.10.16~3-0~debian-bullseye containerd.io docker-compose-plugin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">持久化开启docker</span></span><br>systemctl start docker &amp;&amp; systemctl enable docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">镜像加速</span></span><br>vim /etc/docker/daemon.json<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">写入数据</span></span><br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://xxxx.mirror.aliyuncs.com&quot;]<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">重启加速</span></span><br>systemctl daemon-reload &amp;&amp; systemctl restart docker<br><br></code></pre></td></tr></table></figure><h3 id="nginx-安装"><a href="#nginx-安装" class="headerlink" title="nginx 安装"></a>nginx 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install curl gnupg2 ca-certificates lsb-release debian-archive-keyring -y<br><br>apt update  &amp;&amp; apt install nginx -y<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">持久化开启</span><br>systemctl start nginx &amp;&amp; systemctl enable nginx<br></code></pre></td></tr></table></figure><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ll 别名</span><br>alias ll=&quot;ls -l&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">oh-my-zsh 安装</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 zsh</span><br>apt-get install zsh -y<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换shell 到zsh   然后重启</span><br>chsh -s /bin/zsh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">https://github.com/ohmyzsh/ohmyzsh 想办法下载安装脚本</span><br>sh install.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更换主题</span><br>vim ~/.zshrc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 ZSH_THEME=<span class="hljs-string">&quot;cloud&quot;</span> 新开tab生效</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更多主题 可以查看 https://github.com/ohmyzsh/ohmyzsh/wiki/themes</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">xshell连接此host的终端类型，改成linux 来避免 home end 失效</span><br></code></pre></td></tr></table></figure><h2 id="docker-安装基础服务"><a href="#docker-安装基础服务" class="headerlink" title="docker 安装基础服务"></a><code>docker</code> 安装基础服务</h2><h3 id="docker-安装-portainer"><a href="#docker-安装-portainer" class="headerlink" title="docker 安装 portainer"></a><code>docker</code> 安装 <code>portainer</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取镜像</span><br>docker pull portainer/portainer<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成数据保存路径</span><br>mkdir -p /data/portainer_data<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成 portainer 运行时</span><br>docker run -d -p 9001:9000 --name portainer --restart=always \<br>-v /var/run/docker.sock:/var/run/docker.sock  -v  /data/portainer_data:/data  portainer/portainer <br></code></pre></td></tr></table></figure><h3 id="docker-安装-mysql服务"><a href="#docker-安装-mysql服务" class="headerlink" title="docker  安装 mysql服务"></a><code>docker</code>  安装 <code>mysql</code>服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装MySQL5.7</span><br>dokcer pull mysql:5.7<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成mysql数据保存路径</span><br>mkdir -p /data/mysql/datadir<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成mysql配置文件保存路径</span><br>mkdir -p /data/mysql/conf.d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成 MySQL 运行时</span><br>docker run -d \<br>--name mysql5.7 -p 3306:3306 \<br>-v /data/mysql/datadir:/var/lib/mysql \<br>-v /data/mysql/conf.d:/etc/mysql/conf.d \<br>-e MYSQL_ROOT_PASSWORD=123456  mysql:5.7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">`-e`：设置环境变量，此处指定 `root` 密码</span><br></code></pre></td></tr></table></figure><h3 id="docker-安装-shiori-书签服务"><a href="#docker-安装-shiori-书签服务" class="headerlink" title="docker  安装 shiori 书签服务"></a><code>docker</code>  安装 <code>shiori</code> 书签服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /data/shiori<br><br>chmod -R 777 /data/shiori<br><br>docker run -itd --name=&quot;shiori&quot; -p 8081:8080 -v /data/shiori:/shiori ghcr.io/go-shiori/shiori<br></code></pre></td></tr></table></figure><ul><li><p>初始密码 <code>shiori</code>   <code>gopher</code></p></li><li><p>需要进入后进行新账号生成</p></li><li><p>项目 <a href="https://github.com/go-shiori/shiori">https://github.com/go-shiori/shiori</a></p></li><li><p>衍生浏览器插件 <a href="https://github.com/go-shiori/shiori-web-ext">https://github.com/go-shiori/shiori-web-ext</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>docker</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang base (one)</title>
    <link href="/posts/fd1bbd3a/"/>
    <url>/posts/fd1bbd3a/</url>
    
    <content type="html"><![CDATA[<h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><ul><li><p>必须为 <code>package main</code></p></li><li><p>必须是 <code>func main()&#123;&#125;</code></p></li><li><p>文件名称可以不为 <code>main.go</code></p></li><li><p><code>Go</code> 中 <code>main</code> 函数不支持返回值</p></li><li><p>可以通过 <code>os.Exit()</code> 来传出 返回值</p></li><li><p><code>main</code> 函数不支持传入参数 可以通过 <code>os.Args</code> 来获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 不支持入参</span><br>    fmt.Println(<span class="hljs-string">&quot;hello world!&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) &gt;<span class="hljs-number">1</span> &#123;<span class="hljs-comment">//通过 os.Args 来获取传入的参数</span><br>        <span class="hljs-keyword">for</span> arg,value := <span class="hljs-keyword">range</span> os.Args&#123;<br>            fmt.Println(arg,value)<br>        &#125;<br>    &#125;<br><br>    os.Exit(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="变量，常量以及与其它语言的区别"><a href="#变量，常量以及与其它语言的区别" class="headerlink" title="变量，常量以及与其它语言的区别"></a>变量，常量以及与其它语言的区别</h2><h3 id="编写测试程序"><a href="#编写测试程序" class="headerlink" title="编写测试程序"></a>编写测试程序</h3><ul><li><p>源码文件以 <code>_test</code> 结尾： <code>xxx_test.go</code></p></li><li><p>测试方法名以 <code>Test</code> 开头 <code>TestXXX(t *testing.T)&#123;...&#125;</code></p></li><li><p><code>go test -v xxx_test.go</code> 才能输出 <code>t.Log</code> 里的文字</p></li><li><p>实现斐波拉契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFibList</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    a,b := <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        fmt.Println(b)<br>        a,b = b,a+b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="变量与其它静态编程语言的差异"><a href="#变量与其它静态编程语言的差异" class="headerlink" title="变量与其它静态编程语言的差异"></a>变量与其它静态编程语言的差异</h3><ul><li>赋值可以进行自动类型推断</li><li>同一个赋值语句中可以对多个变量进行同时赋值</li></ul><h3 id="常量与其它静态编程语言的差异"><a href="#常量与其它静态编程语言的差异" class="headerlink" title="常量与其它静态编程语言的差异"></a>常量与其它静态编程语言的差异</h3><ul><li><p>快速设置连续值 <code>iota</code> 遇到下一个 <code>const</code> 之前连续递增1,遇到之后变为0</p></li><li><p><code>iota</code> 只能在常量中使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (<br>    Monday    = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><br>    Tuesday              <span class="hljs-comment">// 2</span><br>    Wednesday            <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    Readable   = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">//1 0001</span><br>    Writable               <span class="hljs-comment">//2 0010</span><br>    Executable             <span class="hljs-comment">//4 0100</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    i = <span class="hljs-literal">iota</span> <span class="hljs-comment">// i=0</span><br>    j = <span class="hljs-number">3.14</span> <span class="hljs-comment">// j=3.14</span><br>    k = <span class="hljs-literal">iota</span> <span class="hljs-comment">// k=2</span><br>    l        <span class="hljs-comment">// l=3</span><br>)<br><br><span class="hljs-keyword">type</span> ByteSize <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">const</span> (<br>    _           = <span class="hljs-literal">iota</span>             <span class="hljs-comment">// ignore first value by assigning to blank identifier</span><br>    KB ByteSize = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>) <span class="hljs-comment">// 1 &lt;&lt; (10*1)</span><br>    MB                             <span class="hljs-comment">// 1 &lt;&lt; (10*2)</span><br>    GB                             <span class="hljs-comment">// 1 &lt;&lt; (10*3)</span><br>    TB                             <span class="hljs-comment">// 1 &lt;&lt; (10*4)</span><br>    PB                             <span class="hljs-comment">// 1 &lt;&lt; (10*5)</span><br>    EB                             <span class="hljs-comment">// 1 &lt;&lt; (10*6)</span><br>    ZB                             <span class="hljs-comment">// 1 &lt;&lt; (10*7)</span><br>    YB                             <span class="hljs-comment">// 1 &lt;&lt; (10*8)</span><br>)<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>基本数据类型 值类型 初始化时默认会有零值<ul><li><code>bool</code> : <code>false</code></li><li><code>string</code> : <code>&quot;&quot;</code></li><li><code>int int8 int16 int32 int64</code> : <code>0</code></li><li><code>uint uint8 uint16 uint32 uint64 uintptr</code> : <code>0</code></li><li><code>byte</code> : <code>0</code> &#x2F;&#x2F; alias for uint8</li><li><code>rune</code>: <code>0</code> &#x2F;&#x2F; alias for int32，represents a Unicode code point</li><li><code>float32 float64</code>:<code>0</code></li><li><code>complex64 complex128</code>: <code>(0+0i)</code></li></ul></li><li>复合类型<ul><li><code>pointer function interface slice channel map</code> : <code>nil</code></li><li>对于复合类型, <code>go</code> 语言会自动递归地将每一个元素初始化为其类型对应的零值。比如：数组， 结构体</li></ul></li></ul><h3 id="整型占用字节问题"><a href="#整型占用字节问题" class="headerlink" title="整型占用字节问题"></a>整型占用字节问题</h3><ul><li><p>int，uint整型：和机器平台有关，最小32位，占用4字节，64位，占用8字节。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//机器位数</span><br>cpu := runtime.GOARCH<br>t.Log(cpu) <span class="hljs-comment">// amd64</span><br><span class="hljs-comment">//int占用位数</span><br>int_size := strconv.IntSize<br>t.Log(int_size) <span class="hljs-comment">// 64</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><table><thead><tr><th>类型</th><th>长度（字节）</th><th>数值范围</th></tr></thead><tbody><tr><td>int8</td><td>1</td><td>-128~127 （-2^(8-1) ~ 2^7-1）</td></tr><tr><td>uint8</td><td>1</td><td>0~255 (0 ~ 2^8-1)</td></tr><tr><td>int16</td><td>2</td><td>-32768~32767</td></tr><tr><td>uint16</td><td>2</td><td>0~65535</td></tr><tr><td>int32</td><td>4</td><td>-2^31 ~ 2^31-1 (-2147483648~2147483647)</td></tr><tr><td>uint32</td><td>4</td><td>0<del>2^32-1 (0</del>4294967295)</td></tr><tr><td>int64</td><td>8</td><td>-2^63 ~2^63-1</td></tr><tr><td>uint64</td><td>8</td><td>0～2^63</td></tr></tbody></table><h3 id="数据类型与其它静态编程语言的差异"><a href="#数据类型与其它静态编程语言的差异" class="headerlink" title="数据类型与其它静态编程语言的差异"></a>数据类型与其它静态编程语言的差异</h3><ul><li><p>Go语言不允许隐式类型转换</p></li><li><p>别名和原有类型也不能进行隐式类型转换</p><ul><li>在某些语言中允许小范围类型向大范围类型转换，因为数据精度不会丢失</li><li>大范围向小范围转换会导致精度丢失</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int64</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDataType</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int64</span><br>    b = <span class="hljs-type">int64</span>(a)<br>    <span class="hljs-keyword">var</span> c MyInt<br>    c = MyInt(b)<br>    t.Log(a,b,c)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Go</code> 语言不支持指针运算</p></li><li><p><code>string</code> 是值类型，其默认的初始值为 <code>&quot;&quot;</code> 空字符串，而不是<code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPoint</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>      a := <span class="hljs-number">1</span><br>      aPtr := &amp;a<br>      <span class="hljs-comment">// aPtr = aPtr + 1 是不被允许的</span><br>      t.Log(a, aPtr)<span class="hljs-comment">// 1 0xc00000a2b8</span><br>      t.Logf(<span class="hljs-string">&quot;%T %T&quot;</span>, a, aPtr)<span class="hljs-comment">// int *int</span><br>      <span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>      <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br>          t.Log(<span class="hljs-string">&quot;string 零值为空字符串&quot;</span>)<br>      &#125;<br>      t.Log(<span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">//0</span><br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://mp.weixin.qq.com/s/BbZcp5OJSQHNi6nlnu3_eA">golang代码编写最佳实践</a></p><h2 id="运算符号与其它静态编程语言的差异"><a href="#运算符号与其它静态编程语言的差异" class="headerlink" title="运算符号与其它静态编程语言的差异"></a>运算符号与其它静态编程语言的差异</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li><code>+ - * / % 后++ 后--</code></li></ul><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li><p><code>==</code> <code>!=</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code></p></li><li><p>在 <code>golang</code> 比较数组 如果两个数组的维度相等是可以比较的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Go">a :=[...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125; <span class="hljs-comment">// 数组声明</span><br>b :=[...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;<br>c :=[...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br>t.Log(a == b) <span class="hljs-comment">// false</span><br>t.Log(a == c) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><code>！</code>  <code>&amp;&amp;</code>  <code>||</code></li></ul><h3 id="位运算符号"><a href="#位运算符号" class="headerlink" title="位运算符号"></a>位运算符号</h3><ul><li><p><code>&amp;</code> 按位与（A &amp; B） 结果为12 二进制为00001100</p></li><li><p><code>|</code> 按位或（A|B）结果为61，二进制为00111101</p></li><li><p><code>^</code> 按位异或（A^B）结果为49，二进制为00110001</p></li><li><p><code>&lt;&lt;</code>A &lt;&lt; 2 结果为240 ，二进制为11110000</p></li><li><p><code>&gt;&gt;</code>A &gt;&gt; 2 结果为15 ，二进制为00001111</p></li><li><p><code>&amp;^</code> 按位清零 运算符 右边为1 则左边清零 为0则左边为原值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-number">1</span> &amp;^ <span class="hljs-number">0</span> --&gt; <span class="hljs-number">1</span> <span class="hljs-comment">// 右边为0 则左边不变</span><br><span class="hljs-number">1</span> &amp;^ <span class="hljs-number">1</span> --&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 右边为1 则左边清零</span><br><span class="hljs-number">0</span> &amp;^ <span class="hljs-number">1</span> --&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 右边为1 则左边清零</span><br><span class="hljs-number">0</span> &amp;^ <span class="hljs-number">0</span> --&gt; <span class="hljs-number">1</span> <span class="hljs-comment">// 右边为0 则左边不变</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="第八讲-流程控制"><a href="#第八讲-流程控制" class="headerlink" title="第八讲 流程控制"></a>第八讲 流程控制</h2><h3 id="只有-for-一个关键字"><a href="#只有-for-一个关键字" class="headerlink" title="只有 for 一个关键字"></a>只有 <code>for</code> 一个关键字</h3><ul><li><code>for</code> 不需要前后的括号</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// while 循环</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestWhileLoop</span><span class="hljs-params">(t *testing.T)</span></span>&#123;<br>  n:= <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> n &lt;<span class="hljs-number">5</span>&#123;<br>  n++<br>  t.Log(n)<br>  &#125;<br>  <span class="hljs-comment">// 无限循环</span><br>  <span class="hljs-keyword">for</span>&#123;<br><br>  &#125;<br>  <span class="hljs-comment">// 这个类似于 goto 与 php 的 break 2 跳出指定的控制结构</span><br>  n:= <span class="hljs-number">0</span><br>  m:=<span class="hljs-number">0</span><br>  I:<br>  <span class="hljs-keyword">for</span> m &lt; <span class="hljs-number">5</span> &#123;<br>      m++<br>      t.Log(m)<br>      <span class="hljs-keyword">for</span> n &lt;<span class="hljs-number">5</span>&#123;<br>          n++<br>          <span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">3</span>&#123;<br>              <span class="hljs-keyword">break</span> I<br>          &#125;<br>          t.Log(n)<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-条件"><a href="#if-条件" class="headerlink" title="if 条件"></a><code>if</code> 条件</h3><ul><li>只有结果为 <code>bool</code> 值，才能成为 <code>if</code> 的条件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition &#123;<br>    <span class="hljs-comment">// code will be executed if condition is true</span><br>&#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition<span class="hljs-number">-1</span> &#123;<br>    <span class="hljs-comment">// code will be executed if condition-1 is true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// code will be executed if condition-1 and condition are false</span><br>&#125;<br><span class="hljs-comment">// 前半部分支持 赋值</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> delaration; condition&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch-条件"><a href="#switch-条件" class="headerlink" title="switch 条件"></a><code>switch</code> 条件</h3><ul><li><p>条件表达式 不限制为常量或者整数</p></li><li><p>单个case中，可以出现多个结果选项，用逗号分隔</p></li><li><p>与 C 语言规则相反， Go 不需要加上break 来明确推出一个case</p></li><li><p>可以不设定 swtich 之后的条件表达式，在此种情况下，整个 switch 结构与多个 if…else… 的逻辑作用相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>    <span class="hljs-keyword">switch</span> i &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>, <span class="hljs-number">2</span>:<br>        t.Log(<span class="hljs-string">&quot;Even&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">3</span>:<br>        t.Log(<span class="hljs-string">&quot;Odd&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        t.Log(<span class="hljs-string">&quot;it is not 0-3&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>    <span class="hljs-keyword">switch</span>  &#123;<br>    <span class="hljs-keyword">case</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        t.Log(<span class="hljs-string">&quot;Even&quot;</span>)<br>    <span class="hljs-keyword">case</span> i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>        t.Log(<span class="hljs-string">&quot;Odd&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        t.Log(<span class="hljs-string">&quot;unKnow&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="第九讲-数组与切片"><a href="#第九讲-数组与切片" class="headerlink" title="第九讲 数组与切片"></a>第九讲 数组与切片</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组的声明</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>            <span class="hljs-comment">// 声明并初始化为默认零值</span><br>t.Log(arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>])     <span class="hljs-comment">// 0,0</span><br>arr1 := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;         <span class="hljs-comment">// 声明并初始化</span><br>t.Log(arr1[<span class="hljs-number">0</span>], arr1[<span class="hljs-number">1</span>])   <span class="hljs-comment">// 1,0</span><br>arr2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125; <span class="hljs-comment">// 声明并初始化 ... 代表根据后面的值来确定前面的长度</span><br>t.Log(arr2[<span class="hljs-number">0</span>], arr2[<span class="hljs-number">1</span>])   <span class="hljs-comment">// 1,1</span><br>arr2[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>               <span class="hljs-comment">// 修改 直接访问下标即可</span><br><br><span class="hljs-comment">// 多维数组的声明</span><br>b := [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;<br>t.Log(b)<br>c := [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;<br>t.Log(c)<br></code></pre></td></tr></table></figure><ul><li>数组与 <code>slice</code> 的循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-comment">// 原始 for 循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>    t.Log(arr[i])<br>&#125;<br><span class="hljs-comment">// for range 类似于 php foreach</span><br><span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> arr &#123;<br>    t.Log(e)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组与slice 的截取</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 数组截取操作 包括开始不包括结束</span><br>arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>a1 := arr[:<span class="hljs-number">3</span>]<br>a2 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>a3 := arr[<span class="hljs-number">1</span>:]<br>a4 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>]<br>a4 = <span class="hljs-built_in">append</span>(a4, <span class="hljs-number">1</span>)<br>t.Log(<span class="hljs-built_in">len</span>(a4), <span class="hljs-built_in">cap</span>(a4))<span class="hljs-comment">// len 2 cap 5</span><br>t.Log(a4[<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 截取出来的东西 实际上是一个 slice</span><br><span class="hljs-comment">// 修改slice的值后 其它截取的slice 都发生了改变 也就是 说</span><br><span class="hljs-comment">// slice 实际上是对于 arr 的一个引用 并没有实际的空间去存储值</span><br>t.Log(a1, a2, a3, a4, arr)<br></code></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// slice 可以看作一个结构体 包括三部分</span><br><span class="hljs-comment">// 指针 指向连续内存 数组 *ptr</span><br><span class="hljs-comment">// len 元素的个数 len</span><br><span class="hljs-comment">// cap 内部数组的容量</span><br><br><span class="hljs-comment">// 声明 区别在于 不用加 ... 与显示的申明长度</span><br><span class="hljs-keyword">var</span> s0 []<span class="hljs-type">int</span><br>s0 = <span class="hljs-built_in">append</span>(s0, <span class="hljs-number">1</span>) <span class="hljs-comment">// 增 append 后记得接受值</span><br>t.Log(<span class="hljs-built_in">len</span>(s0), <span class="hljs-built_in">cap</span>(s0))<span class="hljs-comment">//1,1</span><br><br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>t.Log(<span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<span class="hljs-comment">//2,2</span><br><br><span class="hljs-comment">// make 可用于声明一个 slice 第二个c</span><br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 长度为3 容量为5</span><br>t.Log(<span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<br>t.Log(s2[<span class="hljs-number">0</span>], s2[<span class="hljs-number">1</span>], s2[<span class="hljs-number">2</span>])<br><span class="hljs-comment">// len 初始化元素的个数</span><br><span class="hljs-comment">// cap 总容量</span><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">1</span>)<br>t.Log(<span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2)) <span class="hljs-comment">// 4,5</span><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">2</span>)<br>t.Log(<span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2)) <span class="hljs-comment">// 5,5</span><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">3</span>)<br>t.Log(<span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2)) <span class="hljs-comment">// 6,10</span><br><span class="hljs-comment">// 如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</span><br><span class="hljs-comment">// 如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for &#123;newcap += newcap/4&#125;）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</span><br><span class="hljs-comment">// 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量(cap)</span><br><br><span class="hljs-comment">// 切片共享存储结构</span><br>year := []<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;Jan&quot;</span>, <span class="hljs-string">&quot;Feb&quot;</span>, <span class="hljs-string">&quot;Mar&quot;</span>, <span class="hljs-string">&quot;Apr&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;Jun&quot;</span>, <span class="hljs-string">&quot;Jul&quot;</span>, <span class="hljs-string">&quot;Aug&quot;</span>, <span class="hljs-string">&quot;Sep&quot;</span>, <span class="hljs-string">&quot;Oct&quot;</span>,<br>    <span class="hljs-string">&quot;Nov&quot;</span>, <span class="hljs-string">&quot;Dec&quot;</span>&#125;<br>Q2 := year[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]<br>t.Log(Q2, <span class="hljs-built_in">len</span>(Q2), <span class="hljs-built_in">cap</span>(Q2))<span class="hljs-comment">// 3,9</span><br>summer := year[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>]<br>t.Log(summer,<span class="hljs-built_in">len</span>(summer), <span class="hljs-built_in">cap</span>(summer))<br>summer[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;unKnow&quot;</span><br>t.Log(Q2,year)<br><span class="hljs-comment">// 共享内存修改值会相互影响</span><br></code></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>容量是否可伸缩</p><ul><li>切片容量可伸缩<ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap）</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量(cap)</li><li>slice的共享内存存在一个隐患，就是使用共享内存的双方slice如果有一方出现扩容，则扩容一方将不再指向原有空间。所以程序中想以修改一方达到数据同步时需要小心</li><li>扩容后会指向一个更大的空间,不再指向原有空间,所以共享内存失效</li></ul></li><li>数组声明后长度不可修改</li></ul></li><li><p>是否可比较</p><ul><li>数组可以比较 同一类型 同一长度的数组可以比较</li><li>slice 只能与 nil 进行比较</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于在windows服务器上使用定时任务执行 laravel artisan 命令行</title>
    <link href="/posts/24c27ca1/"/>
    <url>/posts/24c27ca1/</url>
    
    <content type="html"><![CDATA[<h1 id="关于在windows服务器上使用定时任务执行-laravel-artisan-命令行"><a href="#关于在windows服务器上使用定时任务执行-laravel-artisan-命令行" class="headerlink" title="关于在windows服务器上使用定时任务执行 laravel artisan 命令行"></a>关于在windows服务器上使用定时任务执行 laravel artisan 命令行</h1><ul><li><p>需解决的问题</p><ul><li>公司windows 服务器上 的 laravel 项目需要定时去更新一批数据（频率不高）</li></ul></li><li><p>解决思路 </p><ul><li><ol><li>可以使用 golang 去完成 更新数据的操作，编译打包成 exe 文件 用windows 自带的计划任务去处理</li></ol></li><li><ol start="2"><li>对外提供一个 url 接口，在外部服务器上定时去 curl 请求</li></ol></li><li><ol start="3"><li>使用 windows 自带的 .bat 脚本加计划任务，配合larave artisan 命令行去处理</li></ol></li></ul></li><li><p>实际方案</p><ul><li>考虑了生产环境比较封闭，采取第三种方式去处理</li></ul></li><li><p>bat 脚本的编写</p><ul><li><code>cd /d D:\path\to  php artisan queue:check</code></li><li>因为我已经将 php.exe 写入环境变量 所以可以直接在 test.bat 中这么写</li><li>如果为独立的 php 脚本文件，也是一样的写法</li></ul></li><li><p>laravel 命令行的编写</p><ul><li><code>php artisan make:command QueueCheck</code></li><li>然后去对应的文件下面去修改与完成逻辑代码即可</li></ul></li><li><p>windows 计划任务</p><ul><li>win+R 输入 taskschd.msc 即可使用图形化的计划任务表</li><li>新增计划任务，选择执行频次与触发时机，最后要记得改为管理员权限去执行，</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>laravel</tag>
      
      <tag>bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新理解css(一)</title>
    <link href="/posts/d5681d32/"/>
    <url>/posts/d5681d32/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><pre><code class="hljs">- 全称 层叠样式表 Cascading Style Sheet</code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><pre><code class="hljs">- 分类和权重    - 元素选择器   a&#123;&#125;    - 伪元素选择器 ::before&#123;&#125;    - 类选择器    .link&#123;&#125;    - 属性选择器  [type=radio]&#123;&#125;    - 伪类选择器  :hover&#123;&#125;    - ID选择器    #id&#123;&#125;    - 组合选择器  [type=checkbox] + label&#123;&#125;    - 否定选择器  :not(.link)&#123;&#125;    - 通用选择器  *&#123;&#125;    - 权重        - ID选择器 #id&#123;&#125; + 100        - 类 属性 伪类 +10        - 元素 伪元素 +1        - 其它选择器 +0        - 权重不会进位 11 个类 的权重 也比 ID 选择器 小    - !important 优先级最高    - 元素属性（内部关联写法） 优先级高 但是 没有!important 优先级高    - 相同的权重 后写的生效（覆盖）- 解析方式和性能    浏览器 是 从右往左去 解析的</code></pre><h2 id="非布局样式"><a href="#非布局样式" class="headerlink" title="非布局样式"></a>非布局样式</h2><pre><code class="hljs">- 字体、字重、颜色、大小、行高- 背景、边框- 滚动、换行- 粗体、斜体、下划线  - 其他---- 字体    - 字体族    - 多字体 fallback    - 网络字体，自定义字体    - iconfont 原理实际上是自定义字体- 行高    - 行高的构成        - inline-box 的高度 决定行高        - 行高变大，会导致外层元素高度变高，但是文字排版渲染高度不会变（仅与字体大小有关）    - 行高相关的现象        - 垂直居中            - 设定 height-align 和外层元素高度一致就行        - 文字对齐            - 设定 vertical-align: middle        - 图片 3px 空隙问题            - 解决方案 设定 vertical-align: bottom- 背景    - 背景颜色        - background: #f00 | hsl(230,100%,50%,0.3) | rgba(255,0,0,0.3)        - background:url(./test.png)    - 渐变色背景        - background: linear-gradient(90deg, red, yellow 80%, blue) 线性渐变    - 多背景叠加    - 背景图片和属性（雪碧图）    - base64 和性能优化    - 多分辨率适配        - 把 大图片 通过 background-size 来缩小 之后 在高分辨屏幕下查看 不会模糊</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小白的摄影与生活（二）焦点与对焦</title>
    <link href="/posts/c879291a/"/>
    <url>/posts/c879291a/</url>
    
    <content type="html"><![CDATA[<h1 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h1><h2 id="照片拍不清楚的原因"><a href="#照片拍不清楚的原因" class="headerlink" title="照片拍不清楚的原因"></a>照片拍不清楚的原因</h2><pre><code class="hljs">- 相机的抖动导致 画面模糊     - 使用三脚架    - 提高快门速度- 拍照对象在晃动    - 提高快门速度- 天气不好    - 低对比度 导致朦胧    - 天气越恶劣，拍照越精彩- 曝光过度    - 细节损失- 曝光不足    - 细节损失- 镜头凝露    - 温差导致 凝水    - 模拟 冷凝水效果        - 在 UA 镜上涂抹凡士林        - 注意留出中心位置- 焦外虚化    - 背景虚化 前景虚化- 对焦失误    - 对焦到背景上    - 对焦到空气中        - 对焦不在前景，也不再后景    - 没有方向感     - 拍人没有对焦在眼睛上        - 应对在离相机近的眼睛上</code></pre><h2 id="焦点的概念"><a href="#焦点的概念" class="headerlink" title="焦点的概念"></a>焦点的概念</h2><pre><code class="hljs">- 好照片的关键之一    - 焦点明确- 内容的焦点 focal point- 光学的焦点 focal plane 焦平面    - 在视线物体焦点中心呈现为垂直的那一个平面为前焦平面    - 在 相机内部成像的那个平面为后焦平面    - 交叉部分为光学平面    - 焦平面的部分都会很清晰</code></pre><h2 id="对焦目标的选择"><a href="#对焦目标的选择" class="headerlink" title="对焦目标的选择"></a>对焦目标的选择</h2><pre><code class="hljs">- 对焦命令    - 快门 半按 对焦 全按 拍摄- 对焦点    - 对焦目标区域    - 多点对焦 相机自己对焦        - 就近原则 会选择离焦点近的事物对焦        - 不适合，有前景遮挡时 会拍到前景而模糊真正的焦点    - 单点对焦        - 人工控制对焦点            - 佳能相机 摇杆            - 尼康 在ok键的周围    - 多点/单点的切换        - D5300 info 转 I 在 跳到 模式 改到 MF- 自动对焦    - 单次对焦 AF-S Auto Fucos-Single        - 适用范围            - 风光            - 静物            - 静止的人物        - 不适合            - 无规律运动规律对焦（乒乓球）            - 宠物摄影            - 手持拍摄微距    - 跟踪对焦        - 运动物体        - 不适用            - 目标太小            - 对焦目标与背景颜色，亮度太接近    - 连续对焦 AF-C Auto Fucos-Continue        - 可预测运动规律的事物        - 旋转相机，保证对焦点在焦点中央- 自动对焦失败    - 太近        - 近于 最近对焦距离会导致无法对焦    - 无反差 结构方向        - 没有线条，边界的事物对焦    - 一字对焦点不适用的情况    - 光线昏暗        - 使用强光手电- 手动对焦（不到迫不得已不会使用）    - 完全的前景遮挡    - 弱光环境    - 手动对焦的准备        - 需要手动对焦镜头        - 裂像对焦屏</code></pre><h2 id="拍照十八式"><a href="#拍照十八式" class="headerlink" title="拍照十八式"></a>拍照十八式</h2><h3 id="待机姿势"><a href="#待机姿势" class="headerlink" title="待机姿势"></a>待机姿势</h3><pre><code class="hljs">- 膝盖不要弯曲- 身体 可以前屈 不要后仰- 想降低身体高度，可以使用弓步- 蹲姿    - 左腿在前，右腿半跪支撑- 趴姿    - 不要撅屁股- 主要都是为了相机稳定，尽可能的去找支撑点</code></pre><h3 id="握姿"><a href="#握姿" class="headerlink" title="握姿"></a>握姿</h3><pre><code class="hljs">- 左手拿镜头（重要）- 竖排 右手在上</code></pre><h3 id="用哪只眼睛取景"><a href="#用哪只眼睛取景" class="headerlink" title="用哪只眼睛取景"></a>用哪只眼睛取景</h3><pre><code class="hljs">- 右眼取景，左眼可以先闭起来，构图完毕再睁开，观察现实事物进入构图</code></pre><h2 id="拍不清楚的原因"><a href="#拍不清楚的原因" class="headerlink" title="拍不清楚的原因"></a>拍不清楚的原因</h2><pre><code class="hljs">- 相机的抖动导致 画面模糊     - 使用三脚架    - 提高快门速度- 拍照对象在晃动    - 提高快门速度- 天气不好    - 低对比度 导致朦胧    - 天气越恶劣，拍照越精彩- 曝光过度    - 细节损失- 曝光不足    - 细节损失- 镜头凝露    - 温差导致 凝水    - 模拟 冷凝水效果        - 在 UA 镜上涂抹凡士林        - 注意留出中心位置- 焦外虚化    - 背景虚化 前景虚化- 对焦失误    - 对焦到背景上    - 对焦到空气中        - 对焦不在前景，也不再后景    - 没有方向感     - 拍人没有对焦在眼睛上        - 应对在离相机近的眼睛上</code></pre><h2 id="焦点的概念-1"><a href="#焦点的概念-1" class="headerlink" title="焦点的概念"></a>焦点的概念</h2><pre><code class="hljs">- 好照片的关键之一    - 焦点明确- 内容的焦点 focal point- 光学的焦点 focal plane 焦平面    - 在视线物体焦点中心呈现为垂直的那一个平面为前焦平面    - 在 相机内部成像的那个平面为后焦平面    - 交叉部分为光学平面    - 焦平面的部分都会很清晰</code></pre><h2 id="对焦目标的选择-1"><a href="#对焦目标的选择-1" class="headerlink" title="对焦目标的选择"></a>对焦目标的选择</h2><pre><code class="hljs">- 对焦命令    - 快门 半按 对焦 全按 拍摄- 对焦点    - 对焦目标区域    - 多点对焦 相机自己对焦        - 就近原则 会选择离焦点近的事物对焦        - 不适合，有前景遮挡时 会拍到前景而模糊真正的焦点    - 单点对焦        - 人工控制对焦点            - 佳能相机 摇杆            - 尼康 在ok键的周围    - 多点/单点的切换        - D5300 info 转 I 在 跳到 模式 改到 MF- 自动对焦    - 单次对焦 AF-S Auto Fucos-Single        - 适用范围            - 风光            - 静物            - 静止的人物        - 不适合            - 无规律运动规律对焦（乒乓球）            - 宠物摄影            - 手持拍摄微距    - 跟踪对焦        - 运动物体        - 不适用            - 目标太小            - 对焦目标与背景颜色，亮度太接近    - 连续对焦 AF-C Auto Fucos-Continue        - 可预测运动规律的事物        - 旋转相机，保证对焦点在焦点中央- 自动对焦失败    - 太近        - 近于 最近对焦距离会导致无法对焦    - 无反差 结构方向        - 没有线条，边界的事物对焦    - 一字对焦点不适用的情况    - 光线昏暗        - 使用强光手电- 手动对焦（不到迫不得已不会使用）    - 完全的前景遮挡    - 弱光环境    - 手动对焦的准备        - 需要手动对焦镜头        - 裂像对焦屏</code></pre>]]></content>
    
    
    <categories>
      
      <category>摄影相机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>相机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小白的摄影与生活（一）相机保养与拍照姿势</title>
    <link href="/posts/11658ceb/"/>
    <url>/posts/11658ceb/</url>
    
    <content type="html"><![CDATA[<h1 id="摄影与生活"><a href="#摄影与生活" class="headerlink" title="摄影与生活"></a>摄影与生活</h1><p>因为一年过去，发现一点用来留念的相片，视频都没有。入手了一台新手级别的单反，记录认真生活的自己。</p><h2 id="相机的保养"><a href="#相机的保养" class="headerlink" title="相机的保养"></a>相机的保养</h2><p>虽然不是特别贵重的东西，但是坏了总归要心疼一会，所以日常的保养维护也很重要。</p><h3 id="相机损坏的原因有哪些？"><a href="#相机损坏的原因有哪些？" class="headerlink" title="相机损坏的原因有哪些？"></a>相机损坏的原因有哪些？</h3><h4 id="潮湿"><a href="#潮湿" class="headerlink" title="潮湿"></a>潮湿</h4><p>当湿度大于 60% 以上时，会有利于霉菌生长从而腐蚀镜头（<strong>镜头好贵</strong>），日常保存的最佳湿度为30%-40%。<br>防潮可以考虑使用电子吸湿度卡，干燥剂。如果进水了，烘干时不能使用热风，相机镜头也很容易因为温差产生冷凝水。</p><h4 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h4><p>海水，海风也有腐蚀性，去海边拍后记得使用50%浓度的酒精擦拭镜头。</p><h4 id="沙尘与撞击"><a href="#沙尘与撞击" class="headerlink" title="沙尘与撞击"></a>沙尘与撞击</h4><p>这个时候，遮光罩的作用既会明显出来了，防撞，防止强光源的影响，也可以阻挡一些感光灰尘。</p><h4 id="磁场"><a href="#磁场" class="headerlink" title="磁场"></a>磁场</h4><p>强磁场对于相机的电子元件的影响是致命的。</p><h4 id="低温与低气压"><a href="#低温与低气压" class="headerlink" title="低温与低气压"></a>低温与低气压</h4><p>出门拍照要记得带备用电池哦，低温也会导致电池可能无法正常工作。</p><h3 id="什么时候需要清洁镜头？"><a href="#什么时候需要清洁镜头？" class="headerlink" title="什么时候需要清洁镜头？"></a>什么时候需要清洁镜头？</h3><p>当镜头上有明显的 灰尘、油渍、指纹、水渍等对摄影产生影响的污渍后。<br>先用吹气球 吹开杂物，再用镜头纸沾50%酒精按圆形进行擦拭。</p><h2 id="拍照的一般姿势"><a href="#拍照的一般姿势" class="headerlink" title="拍照的一般姿势"></a>拍照的一般姿势</h2><p>拍照当然可以随心所欲的拍，但正确的姿势会给你更好的体验。</p><h3 id="姿势的类型"><a href="#姿势的类型" class="headerlink" title="姿势的类型"></a>姿势的类型</h3><h4 id="待机姿势"><a href="#待机姿势" class="headerlink" title="待机姿势"></a>待机姿势</h4><ul><li>膝盖不要弯曲</li><li>身体可以前屈不要后仰</li><li>想降低身体高度，可以使用弓步</li><li>蹲姿<ul><li>左腿在前，右腿半跪支撑</li></ul></li><li>趴姿<ul><li>不要撅屁股</li></ul></li><li>主要都是为了相机稳定，尽可能的去找支撑点</li></ul><h4 id="握姿"><a href="#握姿" class="headerlink" title="握姿"></a>握姿</h4><ul><li>需要左手托住镜头（重要），右手按快门</li><li>如果你是竖着拍，那么需要右手在上，左手在下托着</li></ul><h4 id="用哪只眼睛取景？"><a href="#用哪只眼睛取景？" class="headerlink" title="用哪只眼睛取景？"></a>用哪只眼睛取景？</h4><ul><li>右眼取景，左眼可以先闭起来，构图完毕再睁开，观察现实事物进入构图</li></ul><h1 id="相机的保养-1"><a href="#相机的保养-1" class="headerlink" title="相机的保养"></a>相机的保养</h1><h2 id="潮湿-1"><a href="#潮湿-1" class="headerlink" title="潮湿"></a>潮湿</h2><pre><code class="hljs">- 湿度大于 60% 以上 会导致 霉菌生长腐蚀镜头- 30%-40% 为 最佳湿度- 防潮    - 电子吸湿度卡    - 干燥剂- 适量晒太阳- 烘干不能使用热风- 冷凝水 来自温差</code></pre><h2 id="腐蚀-1"><a href="#腐蚀-1" class="headerlink" title="腐蚀"></a>腐蚀</h2><pre><code class="hljs">- 海水，海风也有腐蚀性- 擦拭镜头 使用50%浓度的酒精</code></pre><h2 id="沙尘"><a href="#沙尘" class="headerlink" title="沙尘"></a>沙尘</h2><pre><code class="hljs">- 感光元件上的灰尘- 感光玻璃</code></pre><h2 id="撞击"><a href="#撞击" class="headerlink" title="撞击"></a>撞击</h2><pre><code class="hljs">- 遮光罩的作用     - 防撞    - 防止强光源的影响</code></pre><h2 id="磁场-1"><a href="#磁场-1" class="headerlink" title="磁场"></a>磁场</h2><pre><code class="hljs">- 强磁场 对于 相机的电子元件的影响是致命的</code></pre><h2 id="低温与低气压-1"><a href="#低温与低气压-1" class="headerlink" title="低温与低气压"></a>低温与低气压</h2><pre><code class="hljs">- 备用电池    - 低温会导致电池可能无法正常工作</code></pre><h2 id="什么时候清洁镜头"><a href="#什么时候清洁镜头" class="headerlink" title="什么时候清洁镜头"></a>什么时候清洁镜头</h2><pre><code class="hljs">- 灰尘- 指纹- 油渍- 水渍- 吹气球 吹- 镜头纸 圆形擦 50%酒精- 镜头湿纸巾</code></pre>]]></content>
    
    
    <categories>
      
      <category>摄影相机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>相机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读http权威指南(综述一)</title>
    <link href="/posts/e67c0ae7/"/>
    <url>/posts/e67c0ae7/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-的概述"><a href="#HTTP-的概述" class="headerlink" title="HTTP 的概述"></a>HTTP 的概述</h2><ul><li>全名为 Hypertext Transfer Protocol 超文本传输协议</li><li>web<ul><li>特点 基于tcp的 http协议 保证传输安全,无需考虑丢包</li><li>web 一般分为客户端(浏览器)和服务端(apache&#x2F;nginx)</li><li>我们可以将响应抽象为一个对象<ul><li>响应对象,对象类型,对象长度,以及其他一些信息给客户端</li></ul></li></ul></li><li>资源<ul><li>web 上一切的东西都是资源(哲学0.0)</li><li>web 服务器 是 web 资源的宿主,所有的 http 请求,都是为了得到一个资源响应</li><li>媒体类型<ul><li>既然所有东西都是资源,文本,图片,视频…</li><li>那么浏览器与服务器怎么分辨呢?<ul><li>http 会给每种 要通过 web传输的对象打上 MIME 类型(MIME type)的数据格式标签</li><li>当web 浏览器从服务器取回一个对象时,会去查看相关的MIME 类型,根据MIME 类型去进行相应的处理</li><li>例如<ul><li>html 文档对应的是 text&#x2F;html</li><li>普通ASCII 文本文档 为 text&#x2F;plain</li><li>JPEG 为 image&#x2F;jpge  GIF 为 image&#x2F;gif</li><li>Apple 的 QuickTime 电影为 video&#x2F;quicktime 类型</li></ul></li><li>如 nginx 会维护一个 MIME type 的文件 里面为 所有支持的MIME 类型</li></ul></li></ul></li></ul></li><li>URI URL 与URN 的关系<ul><li>所有的资源都是存在于web 服务器上,那么每一个资源对应都存在一个名称,Uniform Resource Identifier  服务器资源名被称为 统一资源标识符URI</li><li>统一资源定位符URL 是资源标识符最常见的形式<ul><li>URL 描述了一台特定服务器上某资源的特定位置.</li><li>URL 一般遵循一种标准格式,包括三个部分<ul><li>第一部分被称为方案(scheme) 说明了访问资源所使用的协议类型.这部分通常就是HTTP协议(http:&#x2F;&#x2F;)</li><li>第二部分给出了服务器对应的域名地址 比如(<a href="http://www.google.com/">www.google.com</a>)</li><li>第三部分指定了web 服务器上的某个资源(&#x2F;index.html)</li><li>现在几乎所有的URI 都是URL</li></ul></li><li>URN 也是 URI的一种,目标是只存在名字无需域名即可获取,目前尚在试验阶段</li></ul></li></ul></li><li>事务<ul><li>基本<ul><li>一个HTTP事务是由一个http请求和一个http响应组成的</li><li>这种通信是通过一种叫HTTP报文的格式化数据来完成的</li></ul></li><li>方法<ul><li>HTTP 支持不同的请求命令,这些命令被称为 HTTP 请求方式 (http method)</li><li>GET POST PUT DELETE HEAD</li><li>每个方法都有对应的含义</li></ul></li></ul></li><li>状态码<ul><li>每个响应都会携带 一个状态码 来告知客户端请求是否成功</li><li>200 301 302 404</li></ul></li><li>报文</li></ul>]]></content>
    
    
    <categories>
      
      <category>http权威指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的一年预备书单与flag</title>
    <link href="/posts/6ec1e389/"/>
    <url>/posts/6ec1e389/</url>
    
    <content type="html"><![CDATA[<h1 id="2019-预备的书单与感想"><a href="#2019-预备的书单与感想" class="headerlink" title="2019 预备的书单与感想"></a>2019 预备的书单与感想</h1><h2 id="迷惑"><a href="#迷惑" class="headerlink" title="迷惑"></a>迷惑</h2><ul><li>越来越多的事件发生,但是本质是什么却无从分析,技术也好,做人也罢,我越来越相信苦痛多半是自找的</li><li>有的苦痛是你能感知的,更多的来自于未来对于现在的懊悔</li><li>如果你未来 没有觉得现在的自己SB 那就更要小心,因为你完全没有进步</li><li>我思故我在,前提是要有一个正确的思维方式,即使是人类一思考,上帝就发笑,也不能放弃,相信自己比相信上帝还是要划来的多</li><li>不思考也能过一辈子,运气好的能过的特别舒服,观其他人的人生,发现一辈子本来要做选择的就只是几件大事,其他的无关紧要的事情,不要让自己太过伤神,</li><li>小聪明擅长局部最优,但整体输了,那还是输了,不管是游戏还是人生大抵如此</li></ul><h2 id="目标与实践"><a href="#目标与实践" class="headerlink" title="目标与实践"></a>目标与实践</h2><h3 id="读书与目的"><a href="#读书与目的" class="headerlink" title="读书与目的"></a>读书与目的</h3><ul><li>读好书真的是开阔视野与沉淀文化最好的方式</li><li>而读一些别有目的的书,那对于没有分辨能力的人来说真的是大害</li><li>当然对于没有产生自己思辨能力的人来说,那也只能是,你说什么就是什么</li></ul><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>程序员自我修养系列<ul><li>《刻意练习:如何从新手到大师》安德斯-埃里克森</li><li>《思考,快与慢》 丹尼尔-卡尼曼</li><li>《实现模式（修订版） 》</li><li>《重构：改善既有代码的设计》</li><li>《重构与模式（修订版）》</li><li>《代码整洁之道》</li><li>《领域驱动设计：软件核心复杂性应对之道》</li><li>《敏捷软件开发：原则、模式与实践》</li><li>《企业应用架构模式》</li><li>《持续交付：发布可靠软件的系统方法》</li><li>《用户故事与敏捷方法》</li><li>《成为技术领导者：掌握全面解决问题的方法》</li><li>《程序员修炼之道：从小工到专家》</li><li>《你的灯亮着吗？发现问题的真正所在》</li><li>《软技能：代码之外的生存指南》</li><li>《卓有成效的管理者（珍藏版）》</li><li>《麦肯锡方法》</li><li>《博弈论经典》</li><li>《点石成金：访客至上的Web和移动可用性设计秘笈（原书第3版） 》</li><li>《面向模式的软件架构（第1卷）：模式系统》</li><li>《第五项修炼：学习型组织的艺术与实践》</li><li>《从0到1：开启商业与未来的秘密》</li><li>《精益思想（白金版）》</li></ul></li><li>Web前端<ul><li>《HTTP权威指南》</li><li>《图解HTTP》</li><li>《HTML5权威指南》</li><li>《Web设计与前端开发秘籍》</li><li>《精通CSS》</li><li>《CSS揭秘》</li><li>《JavaScript DOM编程艺术》</li><li>《JavaScript高级程序设计》</li><li>《JavaScript权威指南》</li><li>《JavaScript语言精粹》</li><li>《你不知道的JavaScript》（上中下三卷）</li><li>《深入理解ES6》</li><li>《Web性能权威指南》</li><li>《JavaScript面向对象精要》</li><li>《JavaScript面向对象编程指南（第2版）》</li><li>《编写可维护的JavaScript》</li><li>《JavaScript函数式编程》</li><li>《数据结构与算法JavaScript描述》</li><li>《JavaScript忍者秘籍 》</li><li>《JavaScript设计模式与开发实践》</li><li>《高性能JavaScript》</li><li>《高性能网站建设指南》</li><li>《高性能网站建设进阶指南》</li><li>《Vue.js权威指南》</li><li>《深入React技术栈》</li><li>《Node.js实战》</li></ul></li><li>后端<ul><li>《深入理解计算机系统（第三版）》</li><li>Tanenbaum 《计算机网络（第5版）》</li><li>《HTTP权威指南》</li><li>《TCP&#x2F;IP详解卷1：协议》</li><li>《算法导论（原书第3版）》</li><li>《性能之巅：洞悉系统、企业与云计算》</li><li>《编程珠玑（第2版·修订版）》</li><li>《代码整洁之道》</li><li>《UNIX编程艺术》</li><li>《重构：改善既有代码的设计》</li><li>《Head First设计模式（中文版）》</li><li>《Java编程思想（第4版）》</li><li>《Effective Java中文版（第2版）》</li><li>《Head First Java中文版（第2版）》</li><li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</li><li>《揭秘Java虚拟机》</li><li>《七周七语言：理解多种编程范型》</li><li>《MySQL必知必会》</li><li>《高性能MySQL（第3版）》</li><li>《Redis设计与实现》</li><li>《Redis实战》</li><li>《白帽子讲Web安全（纪念版）》</li><li>《数学之美（第二版）》</li><li>《软件随想录》</li><li>《程序员修炼之道：从小工到专家》</li><li>《黑客与画家：硅谷创业之父Paul Graham文集》</li><li>《必然》</li></ul></li><li>运维<ul><li>《SRE：Google运维解密》</li><li>《HTTPS权威指南》</li><li>《鸟哥的Linux私房菜：基础学习篇（第三版）》</li><li>《SQL学习指南（第2版 修订版）》</li><li>《MySQL必知必会》</li><li>《MySQL技术内幕：Innodb存储引擎》</li><li>《高性能MySQL（第3版）》</li><li>《高可用MySQL（第2版）》</li><li>《NoSQL数据库技术实战》</li><li>《Redis设计与实现》</li><li>《ZooKeeper：分布式过程协同技术详解》</li><li>《软技能：代码之外的生存指南》</li><li>《编程语言实现模式（修订版）》</li></ul></li></ul><h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><ul><li>越往后越发现,对于自己身体的掌控真的很重要</li><li>一个健康的体魄才能支撑我走过艰难的岁月</li></ul><h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><ul><li>我觉得饮食重在 不挑食,适量与规律 </li><li>再搭上 合理的饮水 适量的运动和规律的作息</li><li>人会精神与舒适很多</li></ul><h3 id="第二职业与装扮"><a href="#第二职业与装扮" class="headerlink" title="第二职业与装扮"></a>第二职业与装扮</h3><ul><li>第二职业<ul><li>在第一职业不占据生活大多数时间的情况下</li><li>可以考虑适量的时间 去开启第二职业</li><li>第二职业 最主要就是兴趣 很简单的比如 写作与摄影</li></ul></li><li>装扮<ul><li>别人看你的第一印象肯定是是打扮与长相</li><li>长相真的就随缘,除非是动刀子</li><li>但是健康的生活与体魄可以保证正常的审美</li><li>装扮就只能是花钱去多买多看了,你自己看自己都不顺眼,别人就更不会瞧得起你</li></ul></li></ul><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><ul><li>这个真的跑不掉的</li><li>你的物质生活需要金钱,那就要去了解金钱是什么</li><li>怎么才能不受金钱节制,过的好一点</li></ul><h3 id="一个积极向上的心态"><a href="#一个积极向上的心态" class="headerlink" title="一个积极向上的心态"></a>一个积极向上的心态</h3><ul><li>没有想向上的心态,别人不会都是你爸妈,想让你天天向上</li><li>自我调节与反思真的很重要</li></ul><h3 id="以上就是我-2019-主要会去实践的几个方向-也是我记录生活的开始-变化越难-改变越大-谨以此文作为我-2019-生活的开端-希望每个人都能成长为更好的自己"><a href="#以上就是我-2019-主要会去实践的几个方向-也是我记录生活的开始-变化越难-改变越大-谨以此文作为我-2019-生活的开端-希望每个人都能成长为更好的自己" class="headerlink" title="以上就是我 2019 主要会去实践的几个方向,也是我记录生活的开始,变化越难,改变越大,谨以此文作为我 2019 生活的开端,希望每个人都能成长为更好的自己!"></a>以上就是我 2019 主要会去实践的几个方向,也是我记录生活的开始,变化越难,改变越大,谨以此文作为我 2019 生活的开端,希望每个人都能成长为更好的自己!</h3>]]></content>
    
    
    <categories>
      
      <category>书单与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-blog折腾记录</title>
    <link href="/posts/13c4aac6/"/>
    <url>/posts/13c4aac6/</url>
    
    <content type="html"><![CDATA[<h2 id="安装折腾总览"><a href="#安装折腾总览" class="headerlink" title="安装折腾总览"></a>安装折腾总览</h2><p>目前的 blog 折腾经过了</p><ul><li><del>自己用 PHP 写 自建，样式太丑，放弃（17年）</del></li><li><del>Github page 国内访问速度太慢，加上 next 的样式太素（19年）</del></li><li><del>最后改成 fluid 这个样式，page 换到 Gitee（20年）</del></li><li>gitee 启动审查机制，弃用 ，jsdelivr 被污染，更换 cdn源 ，重回GitHub（2022年5月）</li></ul><h3 id="目录也分为三块"><a href="#目录也分为三块" class="headerlink" title="目录也分为三块"></a>目录也分为三块</h3><ul><li>hexo 安装</li><li>hexo 的主题 next 与 fluid 的修改</li><li>最后就是 过程中碰到的一些问题<ul><li>样式与生成出来文件的分支管理？</li><li>多主机如何进行发布？</li><li>git 如何超高速拉取 github 仓库的文件？</li></ul></li></ul><h2 id="HEXO-基础安装流程"><a href="#HEXO-基础安装流程" class="headerlink" title="HEXO 基础安装流程"></a>HEXO 基础安装流程</h2><ul><li><p><code>npm</code> 跟 <code>cnpm</code> 的区别就不说了</p><ul><li>安装 <code>hexo</code> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo -g <br></code></pre></td></tr></table></figure></li><li>验证版本<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure></li><li>初始化目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init dir<br></code></pre></td></tr></table></figure></li><li>新建文章<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &quot;关于hexo的安装的一些记录&quot;<br></code></pre></td></tr></table></figure></li><li>启动服务，可访问 <a href="http://localhost:4000/">http://localhost:4000</a> 进行预览<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure></li><li>编译生成静态文件，并上传至 git 服务上<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo generate --deploy<br></code></pre></td></tr></table></figure></li><li>上传前需要清理缓存来避免样式错乱问题，编译缩写<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean &amp;&amp; hexo d -g<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="hexo-的主题-next-与-fluid-的修改-hexo-进阶-next"><a href="#hexo-的主题-next-与-fluid-的修改-hexo-进阶-next" class="headerlink" title="hexo 的主题 next 与 fluid 的修改 hexo  进阶 next"></a>hexo 的主题 next 与 fluid 的修改 <code>hexo</code>  进阶 <code>next</code></h2><ul><li>next 主题相关</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd themes # 进入主题目录<br>git clone https://github.com/iissnan/hexo-theme-next themes/next #克隆主题文件<br></code></pre></td></tr></table></figure><ul><li>fluid 主题相关</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd themes # 进入主题目录<br>git clone https://github.com/fluid-dev/hexo-theme-fluid.git    #克隆主题文件<br>// 主要参考 : https://hexo.fluid-dev.com/ 进行配置<br></code></pre></td></tr></table></figure><h2 id="过程中可能碰到的一些问题"><a href="#过程中可能碰到的一些问题" class="headerlink" title="过程中可能碰到的一些问题"></a>过程中可能碰到的一些问题</h2><h3 id="样式与生成出来文件的分支管理？"><a href="#样式与生成出来文件的分支管理？" class="headerlink" title="样式与生成出来文件的分支管理？"></a>样式与生成出来文件的分支管理？</h3><ul><li>需要 新建一个 hexo 分支 来避免 master 主分支被覆盖 ，主分支 master 为静态文件目录 ，hexo 分支为 样式与配置文件目录</li></ul><h3 id="配置未生效"><a href="#配置未生效" class="headerlink" title="配置未生效"></a>配置未生效</h3><ul><li>老版本配置写在  <code>_data/fluid_conf</code>  中，导致新版本修改配置无效</li></ul><h3 id="未生成-index-html-内容-layout-无内容"><a href="#未生成-index-html-内容-layout-无内容" class="headerlink" title="未生成 index.html 内容 layout 无内容"></a>未生成 index.html 内容 layout 无内容</h3><ul><li>需要把 <code>hexo theme</code> 文件复制到 <code>themes</code> 目录下</li></ul><h3 id="多主机如何进行发布？"><a href="#多主机如何进行发布？" class="headerlink" title="多主机如何进行发布？"></a>多主机如何进行发布？</h3><ul><li><code>git checkout hexo</code> 拉下代码后 切换分支  至配置生成目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo                     # 重新安装 hexo<br>npm install                          # 重新拉所需的运行所需文件<br>npm install hexo-deployer-git --save # 重新生成 钩子才能上传成功<br></code></pre></td></tr></table></figure><h3 id="git-设置-https-代理的正确姿势"><a href="#git-设置-https-代理的正确姿势" class="headerlink" title="git 设置 https 代理的正确姿势?"></a>git 设置 https 代理的正确姿势?</h3><ul><li><p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code> 仅设置 github 在 https 端口的 代理</p></li><li><p>前提条件，你的 SS 开了，而且本地端口为 1080</p></li><li><p>git 全局 设置代理</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27; # http全局设置代理<br>git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;# https全局设置代理<br>git config --global --unset http.proxy # http全局取消代理<br>git config --global --unset https.proxy# https全局取消代理<br></code></pre></td></tr></table></figure></li></ul><h3 id="搭建-hexo，在执行-hexo-deploy-时-出现-ERROR-Deployer-not-found-git-的错误"><a href="#搭建-hexo，在执行-hexo-deploy-时-出现-ERROR-Deployer-not-found-git-的错误" class="headerlink" title="搭建 hexo，在执行 hexo deploy 时,出现 ERROR Deployer not found: git 的错误"></a>搭建 hexo，在执行 hexo deploy 时,出现 ERROR Deployer not found: git 的错误</h3><ul><li><code>npm install hexo-deployer-git --save</code> #重新生成 钩子才能上传成功</li></ul><h3 id="deployer-失败"><a href="#deployer-失败" class="headerlink" title="deployer 失败"></a>deployer 失败</h3><p><code>Please make sure you have the correct access rights. and the repository exists.</code></p><ul><li>重新生成 ssh key<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;your mail address &quot;<br></code></pre></td></tr></table></figure></li><li>一路 enter 生成 ssh key, 然后将生成的 key 添加到 github 上<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li><li>然后在 github 上添加 ssh key <a href="https://github.com/settings/keys">https://github.com/settings/keys</a></li></ul><h3 id="hexo-怎么删除文章？"><a href="#hexo-怎么删除文章？" class="headerlink" title="hexo 怎么删除文章？"></a>hexo 怎么删除文章？</h3><ul><li>先使用 hexo clean 再删除</li><li>最后再重新 hexo generate –deploy 生成就OK</li></ul><h3 id="如何让-百度收录"><a href="#如何让-百度收录" class="headerlink" title="如何让 百度收录"></a>如何让 百度收录</h3><ul><li><p><a href="https://ziyuan.baidu.com/linksubmit/url">https://ziyuan.baidu.com/linksubmit/url</a> 自行提交</p></li><li><p><strong>如果想自行安装，请学习检索</strong></p></li><li><p>技能点需求 难度 ♥ ♥</p></li><li><p><code>git</code>、 <code>hexo</code> 、<code>npm</code>、 <code>md</code> 、<code>html/文件目录</code> 相关基础知识</p></li><li><p>这样就能继续愉快的写<code>blog</code>了</p></li></ul><h3 id="设置流量统计"><a href="#设置流量统计" class="headerlink" title="设置流量统计"></a>设置流量统计</h3><p>使用 <code>busuanzi</code> 来处理 </p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>使用 gittalk 来实现，依赖较少，github 也有 oauth 功能倒是第一次用<br>创建入口被隐藏了，可以通过 <a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a> 进入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs config">Application name             // 应用名称，随便填<br>Homepage URL                 // 填自己的博客地址<br>Application description      // 应用描述，描述一下，无要求<br>Authorization callback URL   // 填自己要使用 `Gitalk` 的博客地址，不可乱填<br></code></pre></td></tr></table></figure><p><strong>参考</strong><br><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a><br><a href="https://hexo.fluid-dev.com/">fluid官方文档</a><br><a href="https://www.jianshu.com/p/9f0e90cc32c2">配置相关说明</a></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>git</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
